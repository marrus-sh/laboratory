<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>README.litcoffee</code></p>

#  _LABORATORY_  #

 - - -

##  Description  ##

Welcome to the Laboratory source code!
Laboratory is an open-source, client-side engine for Mastodon written in Literate CoffeeScript.
Its source files are parseable as regular Markdown documents, and this file is in fact part of the Laboratory source!

###  How to read Laboratory source code:

Each Laboratory source code file is broadly split up into two parts: the *description*, which describes what the file does and how to use it, and the *implementation*, which actually implements the described algorithms and processes.
The implementation will always be the last section in the document, and it is the one that it is safest to ignore—any important information should have already been covered in the description of what goes on in the file.
However, you can turn to the implementation if you are curious on how specific Laboratory features are actually coded.
(And, of course, if you are a computer, the compiled implementation is the only part of this file you will ever see!)

####  What to read.

If you're looking to use Laboratory in your project, then you should definitely familiarize yourself with the [Events API](API/), as this is the primary means of interfacing with the Laboratory engine.
Each file of the API provides a different module, and you should probably take a look at the descriptions for each.
These will give you an overview of each API component and direct you towards further information.

The [Constructors](Constructors/) documentation provides details on the various data types you might encounter while interacting with Laboratory.
You should turn to these files whenever you are unclear on what specific properties or methods an object provides.

####  Notable conventions.

Laboratory contains a number of constructors, functions, and objects which are made available on the `window.Laboratory` object.
For simplicity's sake, this documentation omits the `Laboratory` part in prose; for example, `Laboratory.Authorization` will be referred to as `Authorization` and `Laboratory.dispatch()` will be represented as `dispatch()`.
In code examples, the `Laboratory` prefix should be included.

Laboratory follows the conventions set forward in the [Laboratory Style Guide](https://github.com/marrus-sh/laboratory-style).

 - - -

##  Implementation  ##

This file doesn't actually do much, but it's the first thing that our Laboratory script runs.
In case this is a popup generated by an OAuth request, we handle the information quickly now so that the user can proceed uninterrupted.

###  Strict mode:

Laboratory runs in strict mode.

    "use strict"

###  Introduction:

This is the first file in our compiled source, so let's identify ourselves real fast.

    ###

        ............. LABORATORY ..............

        A client-side API for Mastodon, a free,
           open-source social network server
                  - - by Kibigo! - -

            Licensed under the MIT License.
               Source code available at:
        https://github.com/marrus-sh/laboratory

                    Version 0.3.1

    ###

Laboratory uses an [MIT License](../LICENSE.md) because it's designed to be included in other works.
Feel free to make it your own!

###  First steps:

We include an informative url for the `Laboratory` package on `Laboratory.ℹ` and give the version number on `Laboratory.Nº` for intersted parties.
Laboratory follows semantic versioning, which translates into `Nº` as follows: `Major * 100 + Minor + Patch / 100`.
Laboratory thus assures that minor and patch numbers will never exceed `99` (indeed this would be quite excessive!).

    Laboratory =
        ℹ: "https://github.com/marrus-sh/laboratory"
        Nº: 3.1

###  Popup handling:

If this is a popup (`window.opener.Laboratory` exists) and an API redirect (a `code` parameter exists in our query), then we hand our opener our code.

    do -> Mommy.dispatch "LaboratoryAuthorizationGranted", {code} if (code = (location.search.match(/code=([^&]*)/) || [])[1]) and Mommy = window.opener.Laboratory

###  API and exposed properties:

The Laboratory API is available through the `Laboratory` object.

Although Laboratory does not expose its store to outsiders, it does carefully reveal a few key properties.
These are:

- `ready`, which indicates whether `LaboratoryInitializationReady` has fired yet
- `auth`, which gives the `Authorization` object that `Laboratory` is currently using.

For now, we'll keep these properties in the `Exposed` object, and define getters on `Laboratory` for accessing them.

    Exposed =
        ready: no
        auth: null

    (do (prop) -> Object.defineProperty Laboratory, prop, {get: (-> Exposed[prop]), enumerable: yes}) for prop of Exposed

###  `CustomEvent()`:

`CustomEvent()` is required for our event handling.
This is a CoffeeScript re-implementation of the polyfill available on [the MDN](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent).

    do ->
        return if typeof CustomEvent is "function"
        CustomEvent = (event, params) ->
            params = params or {bubbles: no, cancelable: no, detail: undefined}
            e = document.createEvent "CustomEvent"
            e.initCustomEvent event, params.bubbles, params.cancelable, params.detail
            return e
        CustomEvent.prototype = window.Event.prototype
        Object.freeze CustomEvent
        Object.freeze CustomEvent.prototype

###  `serverRequest()`:

`serverRequest()` is a convenience function for dealing with XMLHttpRequest.
We will use it in our handlers to actually send our requests to the API.
It isn't exposed to the window.

    serverRequest = (method, location, data, accessToken, onComplete, onError) ->

####  Creating the request.

This is fairly simple; we just create an XMLHttpRequest.
You can see we set the `Authorization` header using our access token, if one was provided.

        return unless method is "GET" or method is "POST" or method is "DELETE"
        location = String location
        data = Object data
        request = new XMLHttpRequest

####  Setting the contents.

Note that `FormData` isn't supported in IE 9.

        contents = if method is "POST" and FormData? and data instanceof FormData then data else (
            (
                for key, value of data when value?
                    if value instanceof Array then (
                        (encodeURIComponent key) + "[]=" + (encodeURIComponent subvalue) for subvalue in value
                    ).join "&"
                    else (encodeURIComponent key) + "=" + (encodeURIComponent value)
            ).join "&"
        ).replace /%20/g, '+'

####  Opening the request.

If our `method` isn't `"POST"` then we need to append our `contents` to our `location`.

        location += (if (location.indexOf "?") isnt -1 then "&" else "?") + contents unless contents is "" or method is "POST"
        request.open method, location
        request.setRequestHeader "Content-type", "application/x-www-form-urlencoded" if method is "POST" and not (FormData? and contents instanceof FormData)
        request.setRequestHeader "Authorization", "Bearer " + accessToken if accessToken

####  The callback.

This is the function that is called once the request finishes loading.
We will consider a status code in the range `200` to `205` (inclusive) to be a success, and anything else to be an error.
Laboratory doesn't support HTTP status codes like `206 PARTIAL CONTENT`.

>   __Note :__
>   We use numbers instead of the easier-to-read state names because state names are different in IE.
>   However, the standard names are as follows:
>
>   - `XMLHttpRequest.UNSENT` (`0`)
>   - `XMLHttpRequest.OPENED` (`1`)
>   - `XMLHttpRequest.HEADERS_RECEIVED` (`2`)
>   - `XMLHttpRequest.LOADING` (`3`)
>   - `XMLHttpRequest.DONE` (`4`)

        callback = ->
            switch request.readyState
                when 0 then  #  Do nothing
                when 1 then dispatch "LaboratoryRequestOpen", request
                when 2, 3 then dispatch "LaboratoryRequestUpdate", request
                when 4
                    status = request.status
                    response =
                        try if request.responseText then JSON.parse request.responseText else null
                        catch
                            error: "The response could not be parsed."
                    params =
                        status: status
                        url: location
                        prev: (((request.getResponseHeader "Link")?.match /<\s*([^,]*)\s*>\s*;[^,]*[;\s]rel="?prev(?:ious)?"?/) or [])[1]
                        next: (((request.getResponseHeader "Link")?.match /<\s*([^,]*)\s*>\s*;[^,]*[;\s]rel="?next"?/) or [])[1]
                    switch
                        when 200 <= status <= 205
                            if response?.error?
                                onError response, data, params
                                dispatch "LaboratoryRequestError", request
                            else
                                onComplete response, data, params
                                dispatch "LaboratoryRequestComplete", request
                        else
                            onError response, data, params
                            dispatch "LaboratoryRequestError", request
                    request.removeEventListener "readystatechange", callback

####  Sending the request.

We can now add our event listener and send the request.

        request.addEventListener "readystatechange", callback
        if method is "POST" then request.send contents else do request.send


- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>Constructors/README.litcoffee</code></p>

#  LABORATORY CONSTRUCTORS  #

 - - -

##  Description  ##

The data received from Laboratory event responses is processed and converted into one of several object types before it makes its way to users.
This process is handled by __Laboratory constructors,__ which define the basic data types used when interacting with the API.
Many Laboratory constructors are also API modules; however, some are more "passive" and don't have events directly associated with them.

The Laboratory constructors are as follows:

- [__Application__](Application.litcoffee)
- [__Attachment__](Attachment.litcoffee)
- [__Authorization__](Authorization.litcoffee)
- [__Client__](Client.litcoffee)
- [__Enumeral__](Enumeral.litcoffee)
- [__Failure__](Failure.litcoffee)
- [__Post__](Post.litcoffee)
- [__Profile__](Profile.litcoffee)
- [__Rolodex__](Rolodex.litcoffee)
- [__Timeline__](Timeline.litcoffee)

###  API spoofing:

Most Laboratory constructors expect a Mastodon API response as their first argument.
If you find yourself needing to call them yourself (to dispatch your own `Post`s, for example), then you should feed them an object that matches what would be sent out by the Mastodon server.
See the [Mastodon API documentation](https://github.com/tootsuite/mastodon/blob/master/docs/Using-the-API/API.md) for details on what these objects look like.

 - - -

##  Implementation  ##

See specific constructor pages for details on their implementation.

- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>Constructors/Enumeral.litcoffee</code></p>

#  LABORATORY ENUMERALS  #

 - - -

##  Description  ##

If you have experience working with JavaScript and the DOM, you may have encountered DOM attributes whose values are described by an enumerated type.
For example, `Node.NodeType` can have values which include `Node.ELEMENT_NODE`, with a value of `1`, and `Node.TEXT_NODE`, with a value of `3`.
__Laboratory enumerals__ are an extension of this principle.
They aim to accomplish these things:

1.  **Provide a unique, static identifier for a response value.**
    Laboratory enumerals are unique, immutable objects that do not equate to anything but themselves under strict (`===`) equality.

2.  **Allow checking of specific properties using binary flags.**
    Laboratory enumerals compute to numbers which are non-arbitrary in their meaning.
    You can use binary tests to check for specific enumeral properties; for example, `visibility & Laboratory.Post.Visibility.LISTED` can be used to tell if a given `visibility` is listed or not.

3.  **Provide easy type identification.**
    Each Laboratory enumeral is an instance of the object in which it is contained.
    Thus, `Laboratory.PostType.STATUS instanceof Laboratory.PostType` evaluates to `true`.

4.  **Guarantee uniqueness of value.**
    It is guaranteed that no two enumerals of a given type will share the same value.

###  Enumeral types:

Enumeral types can be created by calling `Enumeral.generate()` with an object whose properties and values give the names and values for the resultant enumerals, like so:

>   ```javascript
>   MyType = Enumeral.generate({
>       TYPE_A: 1
>       TYPE_B: 2
>       TYPE_AB: 3
>       TYPE_C: 4
>       TYPE_F: 32
>   });
>   console.log(MyType.TYPE_A instanceof MyType && MyType.TYPE_A == 1 && !(MyType.TYPE_A === 1)); // -> `true`
>   ```

Further discussion of specific enumeral types takes place in the various files in which they are defined.

####  `fromValue()`.

>   ```javascript
>       MyType.fromValue(n);
>   ```
>
>   - __`n` :__ An integer value

The `fromValue()` method of an enumeral type can be used to get the enumeral associated with the given value.

 - - -

##  Implementation  ##

We implement `Enumeral` inside of a closure to prevent it from functioning outside of the context of `Enumeral.generate()`.

    Laboratory.Enumeral = Enumeral = null
    do ->

        generator = off

###  The constructor:

The `Enumeral()` constructor takes a numeric `value`, which the resultant enumeral will compute to.

        Laboratory.Enumeral = Enumeral = (value) ->

            throw new Error "Laboratory Error : The `Enumeral()` constructor cannot be called directly—try `Enumeral.generate()` instead" unless generator
            throw new Error "Laboratory Error : `Enumeral()` must be called as a constructor" unless this and this instanceof Enumeral

            @value = value | 0
            return Object.freeze this

###  The prototype:

The `Enumeral` prototype overwrites `valueOf()` to allow for easy numeric conversion.
It also adjusts `toString()` and `toSource()` slightly.

        Object.defineProperty Enumeral, "prototype",
            value: Object.freeze
                toString: -> "Enumeral(" + @value + ")"
                toSource: ->"Enumeral(" + @value + ")"
                valueOf: -> @value

###  Generating enumerals:

The `generate()` function creates an `Enumeral` type that meets our specifications.
The provided `data` should be an object whose enumerable own properties associate enumeral names with values.

        Enumeral.generate = (data) ->

First, we need to "fork" the main `Enumeral` constructor so that typechecking will work.
We create a new constructor that just passes everything on.

            type = (n) -> Enumeral.call this, n
            type.prototype = Object.create Enumeral.prototype

Next, we define our enumerals.
We also create a hidden object which store the relationship going the other way.
Note that since values are not guaranteed to be unique, this object may not contain every enumeral (some might be overwritten).

            generator = on
            byValue = {}
            for own enumeral, value of data
                continue if byValue[value]?
                type[enumeral] = new type value
                byValue[value] = type[enumeral]
            generator = off

This function allows quick conversion from value to enumeral.

            type.fromValue = (n) -> byValue[n | 0]

We can now freeze our enumerals and return them.

            return Object.freeze type


- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>Constructors/Application.litcoffee</code></p>

#  THE APPLICATION CONSTRUCTOR  #

 - - -

##  Description  ##

The `Application()` constructor creates a unique, read-only object which represents an application used to interface with the Mastodon API.
Its properties are summarized below, alongside their Mastodon API equivalents:

| Property | API Response | Description |
| :------: | :----------: | :---------- |
|  `name`  |    `name`    | The name of the application |
|  `href`  |  `website`   | The url of the application's homepage or website |

 - - -

##  Implementation  ##

###  The constructor:

The `Application()` constructor takes a `data` object from an API response and reads its attributes into an instance's properties.

    Laboratory.Application = Application = (data) ->

        throw new Error "Laboratory Error : `Application()` must be called as a constructor" unless this and this instanceof Application
        throw new Error "Laboratory Error : `Application()` was called without any `data`" unless data?

        @name = data.name
        @href = data.website

        return Object.freeze this

###  The prototype:

The `Application` prototype just inherits from `Object`.

    Object.defineProperty Application, "prototype",
        value: Object.freeze {}


- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>Constructors/Attachment.litcoffee</code></p>

#  THE ATTACHMENT CONSTRUCTOR  #

 - - -

##  Description  ##

The `Attachment()` constructor creates a unique, read-only object which represents an attached piece of media sent through the Mastodon API.
Its properties are summarized below, alongside their Mastodon API equivalents:

| Property  | API Response  | Description |
| :-------: | :-----------: | :---------- |
|   `id`    |     `id`      | The id of the media attachment |
|  `href`   |     `url`     | The url of the media attachment |
| `preview` | `preview_url` | The url of a preview for the media attachment |
|  `type`   |    `type`     | An `Attachment.Type` |

###  Media types:

The possible `Attachment.Type`s are as follows:

| Enumeral | Binary Value | Description |
| :------: | :----------: | :---------- |
| `Attachment.Type.UNKNOWN` | `00` | The media type cannot be determined |
| `Attachment.Type.PHOTO` | `01` | The media is a photo |
| `Attachment.Type.VIDEO` | `10` | The media is a video |
| `Attachment.Type.GIFV` | `11` | The media is a gif-video |

 - - -

##  Implementation  ##

###  The constructor:

The `Attachment()` constructor takes a `data` object from an API response and reads its attributes into an instance's properties.

    Laboratory.Attachment = Attachment = (data) ->

        throw new Error "Laboratory Error : `Attachment()` must be called as a constructor" unless this and this instanceof Attachment
        throw new Error "Laboratory Error : `Attachment()` was called without any `data`" unless data?

        @id = Number data.id
        @href = String data.url
        @preview = String data.preview_url
        @type = switch data.type
            when "image" then Attachment.Type.IMAGE
            when "video" then Attachment.Type.VIDEO
            when "gifv" then Attachment.Type.GIFV
            else Attachment.Type.UNKNOWN

        return Object.freeze this

###  The prototype:

The `Attachment` prototype just inherits from `Object`.

    Object.defineProperty Attachment, "prototype",
        value: Object.freeze {}

###  Defining media types:

Here we define our `Attachment.Type`s, as described above:

    Attachment.Type = Enumeral.generate
        UNKNOWN : 0b00
        PHOTO   : 0b01
        VIDEO   : 0b10
        GIFV    : 0b11


- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>Constructors/Authorization.litcoffee</code></p>

#  THE AUTHORIZATION CONSTRUCTOR  #

 - - -

##  Description  ##

The `Authorization()` constructor creates a unique, read-only object which represents a successful authorization request.
Its properties are summarized below, alongside their Mastodon API equivalents:

|   Property    |  API Response  | Description |
| :-----------: | :------------: | :---------- |
|   `origin`    | *Not provided* | The origin of the API request |
| `accessToken` | `access_token` | The access token received by the authorization |
|  `datetime`   |  `created_at`  | The `Date` the token was created |
|    `scope`    |    `scope`     | The `Authorization.Scope` associated with the access token |
|  `tokenType`  |  `token_type`  | Should always be the string `"bearer"` |
|     `me`      | *Not provided* | The id of the currently-signed-in account |

###  Scopes:

The possible `Authorization.Scope`s are as follows:

| Enumeral | Binary Value | Description |
| :------: | :----------: | :---------- |
| `Authorization.Scope.NONE` | `000` | No scope is defined |
| `Authorization.Scope.READ` | `001` | The scope is `"read"` |
| `Authorization.Scope.WRITE` | `010` | The scope is `"write"` |
| `Authorization.Scope.READWRITE` | `011` | The scope is `"read write"` |
| `Authorization.Scope.FOLLOW` | `100` | The scope is `"follow"` |
| `Authorization.Scope.READFOLLOW` | `101` | The scope is `"read follow"` |
| `Authorization.Scope.WRITEFOLLOW` | `110` | The scope is `"write follow"` |
| `Authorization.Scope.READWRITEFOLLOW` | `111` | The scope is `"read write follow"` |

 - - -

##  Implementation  ##

###  The constructor:

The `Authorization()` constructor takes a `data` object from an API response and reads its attributes into an instance's properties.
We also need to provide it with an `origin`.

    Laboratory.Authorization = Authorization = (data, origin, me) ->

        throw new Error "Laboratory Error : `Authorization()` must be called as a constructor" unless this and this instanceof Authorization
        throw new Error "Laboratory Error : `Authorization()` was called without any `data`" unless data?

        @origin = String origin
        @accessToken = String data.access_token
        @datetime = new Date data.created_at
        @scope = Authorization.Scope.fromValue Authorization.Scope.READ * (((scopes = (String data.scope).split /[\s\+]+/g).indexOf "read") isnt -1) + Authorization.Scope.WRITE * ((scopes.indexOf "write") isnt -1) + Authorization.Scope.FOLLOW * ((scopes.indexOf "follow") isnt -1)
        @tokenType = String data.tokenType
        @me = +me

        return Object.freeze this

###  The prototype:

The `Authorization` prototype just inherits from `Object`.

    Object.defineProperty Authorization, "prototype",
        value: Object.freeze {}

###  Defining our scopes:

Here we define our `Authorization.Scope`s, as described above:

    Authorization.Scope = Enumeral.generate
        NONE            : 0b000
        READ            : 0b001
        WRITE           : 0b010
        READWRITE       : 0b011
        FOLLOW          : 0b100
        READFOLLOW      : 0b101
        WRITEFOLLOW     : 0b110
        READWRITEFOLLOW : 0b111


- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>Constructors/Client.litcoffee</code></p>

#  THE CLIENT CONSTRUCTOR  #

 - - -

##  Description  ##

The `Client()` constructor creates a unique, read-only object which represents a registered Mastodon client.
It is unlikely you will ever need to call this constructor yourself.
Its properties are summarized below, alongside their Mastodon API equivalents:

|    Property    |  API Response   | Description |
| :------------: | :-------------: | :---------- |
|    `origin`    | *Not provided*  | The origin of the API request |
|     `name`     | *Not provided*  | The name of the client |
|      `id`      |      `id`       | The internal id for the client|
|   `clientID`   |   `client_id`   | The public id of the client |
| `clientSecret` | `client_secret` | The private (secret) id of the client |
|    `scope`     | *Not provided*  | The [`Authorization.Scope`](Authorization.litcoffee) associated with the client |
|   `redirect`   | `redirect_uri`  | The redirect URL associated with the client |

 - - -

##  Implementation  ##

###  The constructor:

The `Client()` constructor takes a `data` object from an API response and reads its attributes into an instance's properties.
We also need to provide it with the parameters of the API request, through the `params` object, and the origin of the request, through `origin`.

    Laboratory.Client = Client = (data, params, origin) ->

        throw new Error "Laboratory Error : `Client()` must be called as a constructor" unless this and this instanceof Client
        throw new Error "Laboratory Error : `Client()` was called without any `data`" unless data?

        @origin = origin
        @name = params.client_name
        @id = data.id
        @clientID = data.client_id
        @clientSecret = data.client_secret
        @scope = Authorization.Scope.fromValue Authorization.Scope.READ * (params.scopes.indexOf("read") isnt -1) + Authorization.Scope.WRITE * (params.scopes.indexOf("write") isnt -1) + Authorization.Scope.FOLLOW * (params.scopes.indexOf("follow") isnt -1)
        @redirect = data.redirect_uri

        return Object.freeze this

###  The prototype:

The `Client` prototype just inherits from `Object`.

    Object.defineProperty Client, "prototype",
        value: Object.freeze {}


- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>Constructors/Timeline.litcoffee</code></p>

#  THE FAILURE CONSTRUCTOR  #

 - - -

##  Description  ##

The `Failure()` constructor creates a unique, read-only object which represents a failed request.
Its properties are summarized below, alongside their Mastodon API equivalents:

| Property  |  API Response  | Description |
| :-------: | :------------: | :---------- |
|  `error`  |    `error`     | The text of the error |
|  `code`   | *Not provided* | The HTTP access code of the error, if applicable |
| `request` | *Not provided* | The request which failed |

 - - -

##  Implementation  ##

###  The constructor:

The `Failure()` constructor takes a `data` object from an API response and reads its attributes into an instance's properties.
We have to provide it with the `request` we made and the HTTP `code` of the response as well.

    Laboratory.Failure = Failure = (data, request, code) ->

        throw new Error "Laboratory Error : `Failure()` must be called as a constructor" unless this and this instanceof Failure
        throw new Error "Laboratory Error : `Failure()` was called without any `data`" unless data?

        @request = String request
        @error = String data.error
        @code = null unless isFinite @code = Number code

        return Object.freeze this

###  The prototype:

The `Failure` prototype just inherits from `Object`.

    Object.defineProperty Failure, "prototype",
        value: Object.freeze {}


- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>Constructors/Post.litcoffee</code></p>

#  THE POST CONSTRUCTOR  #

 - - -

##  Description  ##

The `Post()` constructor creates a unique, read-only object which represents an account's profile information.
Its properties are summarized below, alongside their Mastodon API equivalents:

|      Property      |    API Response     | Description |
| :----------------: | :-----------------: | :---------- |
|       `type`       |   *Not provided*    | A `Post.Type` |
|       `id`         |        `id`         | The id of the post |
|       `uri`        |        `uri`        | A fediverse-unique identifier for the post |
|      `href`        |        `url`        | The url of the post's page |
|     `author`      |       `account`      | The account who made the post |
|    `inReplyTo`     |  `in_reply_to_id`   | The id of the account who made the post |
|     `content`      |      `content`      | The content of the status |
|     `datetime`     |    `created_at`     | The time when the post was created |
|   `reblogCount`    |   `reblogs_count`   | The number of reblogs the post has |
|  `favouriteCount`  | `favourites_count`  | The number of favourites the post has |
|   `isReblogged`    |     `reblogged`     | Whether or not the user has reblogged the post |
|   `isFavourited`   |    `favourited`     | Whether or not the user has favourited the post |
|      `isNSFW`      |     `sensitive`     | Whether or not the post's media contains sensitive content |
|     `message`      |   `spoiler_text`    | The message to hide the post behind, if any |
|    `visibility`    |    `visibility`     | A `Post.Visibility` |
| `mediaAttachments` | `media_attachments` | An array of [`Attachment`](Attachment.litcoffee)s |
|     `mentions`     |     `mentions`      | An array of [`Profile`](Profile.litcoffee)s |
|   `application`    |   `application`     | A [`Application`](Application.litcoffee) identifying the application which created the post |
|   `rebloggedBy`    |   *Not provided*    | The account who reblogged the post; only set for reblog notifications |
|   `favouritedBy`   |   *Not provided*    | The account who favourited the post; only set for favourite notifications |

`Post`s will not necessarily contain all of the above properties.
Follow notifcations will only have a `type`, `id`, and `author`, and the `rebloggedBy` and `favouritedBy` properties only show up on reblog and favourite reactions, respectively.
If a reaction has neither of these properties, then it must be a mention.

###  Post types:

The available `Post.Type`s are as follows:

| Enumeral | Hex Value | Description |
| :------: | :-------: | :---------- |
| `Post.Type.UNKNOWN` | `0x00` | The post type cannot be determined |
| `Post.Type.STATUS` | `0x10` | The post is an status |
| `Post.Type.NOTIFICATION` | `0x20` | The post is a notification |
| `Post.Type.FOLLOW` | `0x21` | The post is a notification |
| `Post.Type.REACTION` | `0x30` | The post is a notification responding to another post |
| `Post.Type.FAVOURITE` | `0x31` | The post is a notification responding to another post |
| `Post.Type.REBLOG` | `0x32` | The post is a notification responding to another post |
| `Post.Type.MENTION` | `0x33` | The post is a notification responding to another post |

Note that not all of the above types will necessarily ever appear on posts; `Post.Type.NOTIFICATION` and `Post.Type.REACTION` exist purely for use with binary comparison tests.

###  Post visibilities:

The available `Post.Visibility`s are as follows:

| Enumeral | Binary Value | Description |
| :------: | :-----------: | :---------- |
| `Post.Visibility.PRIVATE` | `00` | The post cannot be reblogged and appears as unlisted |
| `Post.Visibility.REBLOGGABLE` | `01` | The post is unlisted but can be reblogged |
| `Post.Visibility.LISTED` | `10` | The post is listed but can't be reblogged |
| `Post.Visibility.PUBLIC` | `11` | The post is listed and can be reblogged |

However, note that `Visibility.LISTED` (`0x02`) is not a valid visibility for a Mastodon post.

The visibility of the post can be evaluating using bitwise comparisons: `visibility & Post.Visibility.LISTED` will detect whether a post is listed or unlisted, for example.

###  Prototype methods:

####  `compare()`.

>   ```javascript
>       Laboratory.Post.prototype.compare(post);
>   ```
>
>   - __`post` :__ A `Post` to compare with

The `compare()` prototype method compares a `Post` with another and returns `true` if they have the same properties.
For efficiency, if two `Post`s have the same `id` then `compare()` will only test those properties which are likely to change.

 - - -

##  Implementation  ##

###  The constructor:

The `Post()` constructor takes a `data` object from an API response and reads its attributes into an instance's properties.

    Laboratory.Post = Post = (data) ->

        throw new Error "Laboratory Error : `Post()` must be called as a constructor" unless this and this instanceof Post
        throw new Error "Laboratory Error : `Post()` was called without any `data`" unless data?

We'll use the `getProfile()` function in our various account getters.

        profiles = Store.profiles
        getProfile = (id) -> profiles[id]

The `Post()` constructor can be called with either a status response or a notification one.
We can check this fairly readily by checking for the presence of the `status` attibute.
If `data` has an associated `type`, then it must be a notification.
We pull the notification data and then overwrite `data` to just show the post.

        if data.type?
            @id = data.id
            fromID = data.account.id
            if data.status
                switch data.type
                    when "reblog"
                        @type = Post.Type.REBLOG
                        Object.defineProperty this, "rebloggedBy",
                            get: getProfile.bind this, fromID
                            enumerable: yes
                    when "favourite"
                        @type = Post.Type.FAVOURITE
                        Object.defineProperty this, "favouritedBy",
                            get: getProfile.bind this, fromID
                            enumerable: yes
                    when "mention" then @type = Post.Type.MENTION
                    else @type = Post.Type.REACTION
                data = data.status
            else
                Object.defineProperty this, "author",
                    get: getProfile.bind this, fromID
                    enumerable: yes
                switch data.type
                    when "follow" then @type = Post.Type.FOLLOW
                    else @type = Post.Type.NOTIFICATION
                return Object.freeze this


If our `data` isn't a notification then we can use its `id` like normal.

        else
            @type = Post.Type.STATUS
            @id = data.id

That said, it is possible our `data` is a normal (non-notification) reblog.
In which case, we want to use the original post for extracting our data.

            if data.reblog
                Object.defineProperty this, "rebloggedBy",
                    get: getProfile.bind this, data.account.id
                    enumerable: yes
                data = data.reblog

Now we can set the rest of our properties.

        @uri = String data.uri
        @href = String data.url
        Object.defineProperty this, "author",
            get: getProfile.bind this, data.account.id
            enumerable: yes
        @inReplyTo = Number data.in_reply_to_id
        @content = String data.content
        @datetime = new Date data.created_at
        @reblogCount = Number data.reblogs_count
        @favouriteCount = Number data.favourites_count
        @isReblogged = !!data.reblogged
        @isFavourited = !!data.favourited
        @isNSFW = !!data.sensitive
        @message = String data.spoiler_text
        @visibility = {
            private: Post.Visibility.PRIVATE
            unlisted: Post.Visibility.REBLOGGABLE
            public: Post.Visibility.PUBLIC
        }[data.visibility] or Post.Visibility.PRIVATE
        @mediaAttachments = (new Attachment item for item in data.media_attachments)
        @mentions = do =>
            mentions = []
            Object.defineProperty mentions, index, {get: getProfile.bind(this, mention.id), enumerable: yes} for mention, index in data.mentions
            return mentions
        @application = if data.application? then new Application data.application else null

        return Object.freeze this

###  The prototype:

The `Post` prototype has one function.

    Object.defineProperty Post, "prototype",
        value: Object.freeze

`compare` does a quick comparison between two `Post`s, and tells whether or not they are equivalent.
For efficiency's sake, if the ids of the two posts are the same, it only compares those values which should be considered mutable.

            compare: (other) ->

                return no unless this instanceof Post and other instanceof Post

                return (
                    @type is other.type and
                    @id is other.id and
                    @reblogCount is other.reblogCount and
                    @favouriteCount is other.favouriteCount and
                    @isReblogged is other.isReblogged and
                    @isFavourited is other.isFavourited
                )

###  Defining our enumerals:

Here we define our enumerals as described above.

    Post.Type = Enumeral.generate
        UNKNOWN      : 0x00
        STATUS       : 0x10
        NOTIFICATION : 0x20
        FOLLOW       : 0x21
        REACTION     : 0x30
        FAVOURITE    : 0x31
        REBLOG       : 0x32
        MENTION      : 0x33

    Post.Visibility = Enumeral.generate
        PRIVATE      : 0x00
        REBLOGGABLE  : 0x01
        LISTED       : 0x02
        PUBLIC       : 0x03



- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>Constructors/Profile.litcoffee</code></p>

#  THE PROFILE CONSTRUCTOR  #

 - - -

##  Description  ##

The `Profile()` constructor creates a unique, read-only object which represents an account's profile information.
Its properties are summarized below, alongside their Mastodon API equivalents:

|     Property     |    API Response   | Description |
| :--------------: | :---------------: | :---------- |
|       `id`       |       `id`        | The id of the account |
|    `username`    |    `username`     | The account's username |
|     `account`    |  *Not provided*   | The account's username, followed by their domain |
|  `localAccount`  |      `acct`       | The account's username, followed by their domain for remote users only |
|  `displayName`   |  `display_name`   | The account's display name |
|      `bio`       |      `note`       | The account's profile bio |
|      `href`      |      `url`        | The URL for the account's profile page |
|     `avatar`     |     `avatar`      | The URL for the account's avatar |
|     `header`     |     `header`      | The URL for the account's header |
|    `isLocked`    |     `locked`      | `true` if the account is locked; `false` otherwise |
| `followerCount`  | `followers_count` | The number of accounts following the given one |
| `followingCount` | `following_count` | The number of accounts that the given one is following |
|  `statusCount`   | `statuses_count`  | The number of statuses that the given account has posted |
|  `relationship`  |  *Not provided*   | A `Laboratory.Profile.Relationship`, providing the relationship between the given account and the current user. |

###  Profile relationiships:

The available `Profile.Relationship`s are as follows:

| Enumeral | Binary Value | Description |
| :------: | :----------: | :---------- |
| `Profile.Relationship.NOT_FOLLOWING` | `00000000` | Neither the account nor the user are following each other |
| `Profile.Relationship.FOLLOWER` | `00000001` | The user is being followed by the account |
| `Profile.Relationship.FOLLOWING` | `00000010` | The account is being followed by the user |
| `Profile.Relationship.MUTUAL` | `00000011` | The user and the account are following each other |
| `Profile.Relationship.REQUESTED` | `00000100` | The user has requested to follow the account |
| `Profile.Relationship.REQUESTED_MUTUAL` | `00000101` | The account follows the user, and the user has requested to follow the account |
| `Profile.Relationship.BLOCKING` | `00001000` | The user is blocking the account |
| `Profile.Relationship.MUTING` | `00010000` | The user is muting the account |
| `Profile.Relationship.MUTING_FOLLOWER` | `00010001` | The user is muting, and being followed by, the account |
| `Profile.Relationship.MUTING_FOLLOWING` | `00010010` | The user is muting and following the account |
| `Profile.Relationship.MUTING_MUTUAL` | `00010011` | The user and the account are following each other, but the user is muting the account |
| `Profile.Relationship.MUTING_REQUESTED` | `00010100` | The user is muting the account, but has also requested to follow it |
| `Profile.Relationship.MUTING_REQUESTED_MUTUAL` | `00010101` | The user is muting, and being followed by, the accoung, but has also requested to follow it |
| `Profile.Relationship.UNKNOWN` | `01000000` | The relationship between the user and the account is unknown |
| `Profile.Relationship.SELF` | `10000000` | The account is the user |

You can use bitwise comparisons on these enumerals to test for a specific relationship status.
Of course, many combinations are not possible.

|    Flag    | Enumeral | Meaning |
| :--------: | -------- | ------- |
| `00000001` | `Profile.Relationship.FOLLOWER` | The user is followed by the account |
| `00000010` | `Profile.Relationship.FOLLOWING` | The account is followed by the user |
| `00000100` | `Profile.Relationship.REQUESTED` | The user has sent a follow request to the account |
| `00001000` | `Profile.Relationship.BLOCKING` | The user is blocking the account |
| `00010000` | `Profile.Relationship.MUTING` | The user is muting the account |
| `00100000` | _Unused_ | Reserved for later use |
| `01000000` | `Profile.Relationship.UNKNOWN` | The relationship status between the user and the account is unknown |
| `10000000` | `Profile.Relationship.SELF` | The user is the same as the account |

###  Prototype methods:

####  `compare()`.

>   ```javascript
>       Laboratory.Profile.prototype.compare(profile);
>   ```
>
>   - __`profile` :__ A `Profile` to compare with

The `profile()` prototype method compares a `Profile` with another and returns `true` if they have the same properties.

 - - -

##  Implementation  ##

###  The constructor:

The `Profile()` constructor takes a `data` object from an API response (or another `Profile` object) and reads its attributes into an instance's properties.
Additionally, the `relationship` argument can be used to set the Profile relationship.

    Laboratory.Profile = Profile = (data, relationship) ->

        throw new Error "Laboratory Error : `Profile()` must be called as a constructor" unless this and this instanceof Profile
        throw new Error "Laboratory Error : `Profile()` was called without any `data`" unless data?
        
If the `relationship` isn't provided, we check to see if we already have one for this id in our `Store`.

        relationship = Store.profiles[data.id]?.relationship unless relationship?

If our `data` is already a `Profile`, we can just copy its info over.

        if data instanceof Profile then {@id, @username, @account, @localAccount, @displayName, @bio, @href, @avatar, @header, @isLocked, @followerCount, @followingCount, @statusCount, @relationship} = data

Otherwise, we have to change some variable names around.

        else
            @id = Number data.id
            @username = String data.username
            @account = String data.acct + (if (origin = Store.auth.origin)? and data.acct.indexOf("@") is -1 then "@" + origin else "")
            @localAccount = String data.acct
            @displayName = String data.display_name
            @bio = String data.note
            @href = String data.url
            @avatar = String data.avatar
            @header = String data.header
            @isLocked = !!data.locked
            @followerCount = Number data.followers_count
            @followingCount = Number data.following_count
            @statusCount = Number data.statuses_count
            @relationship = if data.id is Store.auth.me then Profile.Relationship.SELF else Profile.Relationship.UNKNOWN

We set the relationship last, overwriting any previous relationship if one is provided.
This code will coerce the provided relationship into an Number and then back to an enumeral if possible.
Remember that because enumerals are objects, they will always evaluate to `true` even if their value is `0x00`.

        @relationship = Profile.Relationship.fromValue(relationship) || @relationship if relationship?

        return Object.freeze this

###  The prototype:

The `Profile` prototype has one function.

    Object.defineProperty Profile, "prototype",
        value: Object.freeze

`compare` does a quick comparison between two `Profile`s, and tells whether or not they are equivalent.
For efficiency's sake, it compares attributes with the most-likely-to-be-different ones first.

            compare: (other) ->

                return false unless this instanceof Profile and other instanceof Profile

                return (
                    @id is other.id and
                    @relationship is other.relationship and
                    @followerCount is other.followerCount and
                    @followingCount is other.followingCount and
                    @statusCount is other.statusCount and
                    @bio is other.bio and
                    @displayName is other.displayName and
                    @avatar is other.avatar and
                    @header is other.header and
                    @isLocked is other.isLocked and
                    @username is other.username and
                    @localAccount is other.localAccount and
                    @account is other.account and
                    @href is other.href
                )

###  Defining profile relationships:

Here we define profile relationships, as specified above.

    Profile.Relationship = Enumeral.generate
        NOT_FOLLOWING           : 0b00000000
        FOLLOWER                : 0b00000001
        FOLLOWING               : 0b00000010
        MUTUAL                  : 0b00000011
        REQUESTED               : 0b00000100
        REQUESTED_MUTUAL        : 0b00000101
        BLOCKING                : 0b00001000
        MUTING                  : 0b00010000
        MUTING_FOLLOWER         : 0b00010001
        MUTING_FOLLOWING        : 0b00010010
        MUTING_MUTUAL           : 0b00010011
        MUTING_REQUESTED        : 0b00010100
        MUTING_REQUESTED_MUTUAL : 0b00010101
        UNKNOWN                 : 0b01000000
        SELF                    : 0b10000000


- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>Constructors/Rolodex.litcoffee</code></p>

#  THE ROLODEX CONSTRUCTOR  #

 - - -

##  Description  ##

The `Rolodex()` constructor creates a unique, read-only object which represents a list of [`Profile`](Profile.litcoffee)s.
Its properties are summarized below, alongside their Mastodon API equivalents:

>   __[Issue #15](https://github.com/marrus-sh/laboratory/issues/15) :__
>   The object returned by this constructor might be radically different in future versions of Laboratory.

|  Property  |  API Response  | Description |
| :--------: | :------------: | :---------- |
| `profiles` | [The response] | An ordered array of profiles, in reverse-chronological order |
|   `type`   | *Not provided* | A `Rolodex.Type` |
|  `query`   | *Not provided* | The query associated with the `Rolodex` |
|  `before`  | *Not provided* | The upper limit of the `Rolodex` |
|  `after`   | *Not provided* | The lower limit of the `Rolodex` |

Note that `before` and `after` are special identifiers which may depend on the `Rolodex.Type`.

###  Rolodex types:

The possible `Rolodex.Type`s are as follows:

>   __[Issue #18](https://github.com/marrus-sh/laboratory/issues/18) :__
>   There should also be a follow-request rolodex.

| Enumeral | Hex Value | Description |
| :------: | :----------: | :---------- |
| `Rolodex.Type.UNDEFINED` | `0x00` | No type is defined |
| `Rolodex.Type.SEARCH` | `0x10` | A search of profiles |
| `Rolodex.Type.FOLLOWERS` | `0x21` | The followers of an account |
| `Rolodex.Type.FOLLOWING` | `0x22` | Those following an account |
| `Rolodex.Type.FAVOURITED_BY` | `0x41` | Those who favourited a given status |
| `Rolodex.Type.REBLOGGED_BY` | `0x45` | Those who reblogged a given status |
| `Rolodex.Type.BLOCKS` | `0x83` | Those who have been blocked |
| `Rolodex.Type.MUTES` | `0x84` | Those who have been muted |

The `Rolodex()` constructor does not use or remember its `Rolodex.Type`, but these values are used when requesting new `Rolodex`es using `LaboratoryRolodexRequested`.

###  Prototype methods:

####  `join()`.

>   ```javascript
>       Laboratory.Rolodex.prototype.join(data);
>   ```
>
>   - __`data` :__ A `Profile`, array of `Profile`s, or a `Rolodex`

The `join()` prototype method joins the `Profile`s of a `Rolodex` with that of the provided `data`, and returns a new `Rolodex` of the results.
When merging two `Rolodex`es, the `type` and `query` parameters will only be preserved if they match across both; in this case, `before` and `after` will be adjusted such that both `Rolodex`es are contained in the range.
Otherwise, the `type` of the resultant `Rolodex` will be `Rolodex.Type.UNDEFINED` and its `query` will be the empty string.

When joining a `Rolodex` with a different data type, the `type`, `query`, `before`, and `after` parameters remain unchanged.

####  `remove()`.

>   ```javascript
>       Laboratory.Rolodex.prototype.remove(data);
>   ```
>
>   - __`data` :__ A `Profile`, array of `Profile`s, or a `Rolodex`

The `remove()` prototype method collects the `Profile`s of a `Rolodex` except for those of the provided `data`, and returns a new `Rolodex` of the results.
The `type`, `query`, `before`, and `after` parameters are preserved from the original.

 - - -

##  Implementation  ##

###  The constructor:

The `Rolodex()` constructor takes a `data` object and uses it to construct a rolodex.
`data` can be either an API response or an array of `Profile`s.
`params` provides additional information not given in `data`.

    Laboratory.Rolodex = Rolodex = (data, params) ->

        throw new Error "Laboratory Error : `Rolodex()` must be called as a constructor" unless this and this instanceof Rolodex
        throw new Error "Laboratory Error : `Rolodex()` was called without any `data`" unless data?

This loads our `params`.

        @type = if params.type instanceof Rolodex.Type then params.type else Rolodex.Type.UNDEFINED
        @query = String params.query
        @before = Number params.before if isFinite params.before
        @after = Number params.after if isFinite params.after

We'll use the `getProfile()` function in our profile getters.

        getProfile = (id) -> Store.profiles[id]

We sort our data according to their ids.

        data.sort (first, second) -> second.id - first.id

The following loop removes any duplicates from our `data`.

        prev = null
        for index in [data.length - 1 .. 0]
            currentID = (current = data[index]).id
            if prev? and currentID is prev.id
                data.splice index, 1
                continue
            prev = current

Finally, we implement our list of `profiles` as getters such that they always return the most current data.
**Note that this will likely prevent optimization of the `profiles` array, so it is recommended that you make a static copy (using `Array.prototype.slice()` or similar) before doing intensive array operations with it.**

>   __[Issue #28](https://github.com/marrus-sh/laboratory/issues/28) :__
>   At some point in the future, `Rolodex` might instead be implemented using a linked list.

        @profiles = []
        Object.defineProperty @profiles, index, {get: getProfile.bind(this, value.id), enumerable: true} for value, index in data
        Object.freeze @profiles

        return Object.freeze this

###  The prototype:

The `Rolodex` prototype has two functions.

    Object.defineProperty Rolodex, "prototype",
        value: Object.freeze

####  `join()`.

The `join()` function creates a new `Rolodex` which combines the `Profile`s of the original and the provided `data`.
Its `data` argument can be either a `Profile`, an array thereof, or a `Rolodex`.
We don't have to worry about duplicates here because the `Rolodex()` constructor should take care of them for us.

            join: (data) ->
                return this unless data instanceof Profile or data instanceof Array or data instanceof Rolodex
                combined = profile for profile in switch
                    when data instanceof Profile then [data]
                    when data instanceof Rolodex then data.profiles
                    else data
                combined.push profile for profile in @profiles
                return new Rolodex combined, (
                    if data instanceof Rolodex
                        if data.type is @type and data.query is @query
                            type: @type
                            query: @query
                            before: switch
                                when data.before >= @before then data.before
                                when data.before <= @before then @before
                                else undefined
                            after: switch
                                when data.after <= @after then data.after
                                when data.after >= @after then @after
                                else undefined
                        else
                            type: if data.type is @type then @type else Rolodex.Type.UNDEFINED
                            query: ""
                            before: undefined
                            after: undefined
                    else
                        type: @type
                        query: @query
                        before: @before
                        after: @after
                )

####  `remove()`.

The `remove()` function returns a new `Rolodex` with the provided `Profile`s removed.
Its `data` argument can be either a `Profile`, an array thereof, or a `Rolodex`.

            remove: (data) ->
                return this unless data instanceof Profile or data instanceof Array or data instanceof Rolodex
                redacted = (profile for profile in @profiles)
                redacted.splice index, 1 for profile in (
                    switch
                        when data instanceof Profile then [data]
                        when data instanceof Rolodex then data.profiles
                        else data
                ) when (index = redacted.indexOf profile) isnt -1
                return new Rolodex redacted,
                    type: @type
                    query: @query
                    before: @before
                    after: @after

###  Defining rolodex types:

Here we define our `Rolodex.Type`s, as described above:

>   __[Issue #18](https://github.com/marrus-sh/laboratory/issues/18) :__
>   There should also be a follow-request rolodex.

    Rolodex.Type = Enumeral.generate
        UNDEFINED     : 0x00
        SEARCH        : 0x10
        FOLLOWERS     : 0x21
        FOLLOWING     : 0x22
        FAVOURITED_BY : 0x41
        REBLOGGED_BY  : 0x45
        BLOCKS        : 0x83
        MUTES         : 0x84


- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>Constructors/Timeline.litcoffee</code></p>

#  THE TIMELINE CONSTRUCTOR  #

 - - -

##  Description  ##

The `Timeline()` constructor creates a unique, read-only object which represents a Mastodon timeline.
Its properties are summarized below, alongside their Mastodon API equivalents:

>   __[Issue #15](https://github.com/marrus-sh/laboratory/issues/15) :__
>   The object returned by this constructor might be radically different in future versions of Laboratory.

| Property |  API Response  | Description |
| :------: | :------------: | :---------- |
| `posts`  | [The response] | An ordered array of posts in the timeline, in reverse-chronological order |
|  `type`  | *Not provided* | A `Timeline.Type` |
| `query`  | *Not provided* | The minimum id of posts in the timeline |
| `before` | *Not provided* | The upper limit of the timeline |
| `after`  | *Not provided* | The lower limit of the timeline |

###  Timeline types:

The possible `Timeline.Type`s are as follows:

>   __[Issue #16](https://github.com/marrus-sh/laboratory/issues/16) :__
>   Hashtag searches can also be global/local, so the values of these enumerals may change at some point in the future.

| Enumeral | Hex Value | Description |
| :------: | :----------: | :---------- |
| `Timeline.Type.UNDEFINED` | `0x00` | No type is defined |
| `Timeline.Type.HASHTAG` | `0x10` | A timeline of hashtags |
| `Timeline.Type.LOCAL` | `0x11` | A local timeline |
| `Timeline.Type.GLOBAL` | `0x12` | A global (whole-known-network) timeline |
| `Timeline.Type.HOME` | `0x22` | A user's home timeline |
| `Timeline.Type.NOTIFICATIONS` | `0x23` | A user's notifications |
| `Timeline.Type.FAVOURITES` | `0x24` | A list of a user's favourites |
| `Timeline.Type.ACCOUNT` | `0x40` | A timeline of an account's posts |

The `Timeline()` constructor does not use or remember its `Timeline.Type`, but these values are used when requesting new `Timeline`s using `LaboratoryTimelineRequested`.

###  Prototype methods:

####  `join()`.

>   ```javascript
>       Laboratory.Timeline.prototype.join(data);
>   ```
>
>   - __`data` :__ A `Post`, array of `Post`s, or a `Timeline`

The `join()` prototype method joins the `Post`s of a timeline with that of the provided `data`, and returns a new `Timeline` of the results.
When merging two `Timeline`s, the `type` and `query` parameters will only be preserved if they match across both; in this case, `before` and `after` will be adjusted such that both `Timeline`s are contained in the range.
Otherwise, the `type` of the resultant `Timeline` will be `Timeline.Type.UNDEFINED` and its `query` will be the empty string.

When joining a `Timeline` with a different data type, the `type`, `query`, `before`, and `after` parameters remain unchanged.

####  `remove()`.

>   ```javascript
>       Laboratory.Timeline.prototype.remove(data);
>   ```
>
>   - __`data` :__ A `Post`, array of `Post`s, or a `Timeline`

The `remove()` prototype method collects the `Post`s of a timeline except for those of the provided `data`, and returns a new `Timeline` of the results.
The `type`, `query`, `before`, and `after` parameters are preserved from the original.

 - - -

##  Implementation  ##

###  The constructor:

The `Timeline()` constructor takes a `data` object and uses it to construct a timeline.
`data` can be either an API response or an array of `Post`s.
`params` provides additional information not given in `data`.

    Laboratory.Timeline = Timeline = (data, params) ->

        throw new Error "Laboratory Error : `Timeline()` must be called as a constructor" unless this and this instanceof Timeline
        throw new Error "Laboratory Error : `Timeline()` was called without any `data`" unless data?

This loads our `params`.

        @type = if params.type instanceof Timeline.Type then params.type else Timeline.Type.UNDEFINED
        @query = String params.query
        @before = Number params.before if isFinite params.before
        @after = Number params.after if isFinite params.after

Mastodon keeps track of ids for notifications separately from ids for posts, as best as I can tell, so we have to verify that our posts are of matching type before proceeding.
Really all we care about is whether the posts are notifications, so that's all we test.

        isNotification = (object) -> !!(
            (
                switch
                    when object instanceof Post then object.type
                    when object.type? then Post.Type.NOTIFICATION  #  This is an approximation; the post could be a reaction.
                    else Post.Type.STATUS
            ) & Post.Type.NOTIFICATION
        )

We'll use the `getPost()` function in our post getters.

        getPost = (id, isANotification) -> if isANotification then Store.notifications[id] else Store.statuses[id]

We sort our data according to when they were created, unless two posts were created at the same time.
Then we use their ids.

>   __Note :__
>   Until/unless Mastodon starts assigning times to notifications, there are a few (albeit extremely unlikely) edge-cases where the following `sort()` function will cease to be well-defined.
>   Regardless, attempting to create a timeline out of both notifications and statuses will likely result in a very odd sorting.

        data.sort (first, second) -> if not (isNotification first) and not (isNotification second) and (a = Number first instanceof Post and first.datetime or Date first.created_at) isnt (b = Number second instanceof Post and second.datetime or Date second.created_at) then -1 + 2 * (a > b) else second.id - first.id

Next we walk the array and look for any duplicates, removing them.

>   __Note :__
>   Although `Timeline()` purports to remove all duplicate `Post`s, this behaviour is only guaranteed for *contiguous* `Post`s—given our sort algorithm, this means posts whose `datetime` values are also the same.
>   If the same post ends up sorted to two different spots, `Timeline()` will leave both in place.
>   (Generally speaking, if you find yourself with two posts with identical `id`s but different `datetime`s, this is a sign that something has gone terribly wrong.)

        prev = null
        for index in [data.length - 1 .. 0]
            currentID = (current = data[index]).id
            if prev? and currentID is prev.id and (isNotification prev) is (isNotification current)
                data.splice index, 1
                continue
            prev = current

Finally, we implement our list of `posts` as getters such that they always return the most current data.
**Note that this will likely prevent optimization of the `posts` array, so it is recommended that you make a static copy (using `Array.prototype.slice()` or similar) before doing intensive array operations with it.**

>   __[Issue #28](https://github.com/marrus-sh/laboratory/issues/28) :__
>   At some point in the future, `Timeline` might instead be implemented using a linked list.

        @posts = []
        Object.defineProperty @posts, index, {get: getPost.bind(this, value.id, isNotification value), enumerable: true} for value, index in data
        Object.freeze @posts

        return Object.freeze this

###  The prototype:

The `Timeline` prototype has two functions.

    Object.defineProperty Timeline, "prototype",
        value: Object.freeze

####  `join()`.

The `join()` function creates a new `Timeline` which combines the `Post`s of the original and the provided `data`.
Its `data` argument can be either a `Post`, an array thereof, or a `Timeline`.
We don't have to worry about duplicates here because the `Timeline()` constructor should take care of them for us.

            join: (data) ->
                return this unless data instanceof Post or data instanceof Array or data instanceof Timeline
                combined = post for post in switch
                    when data instanceof Post then [data]
                    when data instanceof Timeline then data.posts
                    else data
                combined.push post for post in @posts
                return new Timeline combined, (
                    if data instanceof Timeline
                        if data.type is @type and data.query is @query
                            type: @type
                            query: @query
                            before: switch
                                when data.before >= @before then data.before
                                when data.before <= @before then @before
                                else undefined
                            after: switch
                                when data.after <= @after then data.after
                                when data.after >= @after then @after
                                else undefined
                        else
                            type: if data.type is @type then @type else Timeline.Type.UNDEFINED
                            query: ""
                            before: undefined
                            after: undefined
                    else
                        type: @type
                        query: @query
                        before: @before
                        after: @after
                )

####  `remove()`.

The `remove()` function returns a new `Timeline` with the provided `Post`s removed.
Its `data` argument can be either a `Post`, an array thereof, or a `Timeline`.

            remove: (data) ->
                return this unless data instanceof Post or data instanceof Array or data instanceof Timeline
                redacted = (post for post in @posts)
                redacted.splice index, 1 for post in (
                    switch
                        when data instanceof Post then [data]
                        when data instanceof Timeline then data.posts
                        else data
                ) when (index = redacted.indexOf post) isnt -1
                return new Timeline redacted,
                    type: @type
                    query: @query
                    before: @before
                    after: @after

###  Defining timeline types:

Here we define our `Timeline.Type`s, as described above:

>   __[Issue #16](https://github.com/marrus-sh/laboratory/issues/16) :__
>   Hashtag searches can also be global/local, so the values of these enumerals may change at some point in the future.

    Timeline.Type = Enumeral.generate
        UNDEFINED     : 0x00
        HASHTAG       : 0x10
        LOCAL         : 0x11
        GLOBAL        : 0x12
        HOME          : 0x22
        NOTIFICATIONS : 0x23
        FAVOURITES    : 0x24
        ACCOUNT       : 0x40


- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>API/README.litcoffee</code></p>

#  LABORATORY EVENT API  #

 - - -

##  Description  ##

Laboratory does not give you direct access to the information it receives from a Mastodon server.
Instead, it makes this information available using a special __Event API,__ which is documented here.
This page will provide the basics on the API and how it works, and then direct you to further resources for specific components.

###  Understanding the Event API:

In order to understand Laboratory's Event API, you first need to understand how Laboratory stores its data.
All of the information that Laboratory receives and keeps track of from a Mastodon server is kept within a single central __store,__ which is a large JavaScript object with numerous different parts.
The idea of a central store might be familiar to you if you've used systems like __Redux__ before.

However, unlike with Redux, many areas of Laboratory's store are left fully mutable.
This means that the store can be quickly modified in-place to add and remove data.
However, it also means that, in order to maintain the sanctity of its data, the Laboratory store can't be exposed to the public view.
**Laboratory's store is declared inside of a closure for which there is no external access.**
The only functions which are allowed to modify the Laboratory store are a collection of __Laboratory Event Handlers__ (colloquially, just "handlers"), which listen for Laboratory-specific events dispatched to the `document`.

The only means outside programs have to interact with the Laboratory store is then through a series of pre-defined __Laboratory Events__, which can be issued, listened for, and logged by external parties.
The Laboratory Event API describes these events and their function.

###  Creating and issuing Laboratory Events:

Laboratory Events are implemented as DOM `CustomEvents`.
Consequently, each event has just two pieces of information that you need to account for: its `type`, which identifies the event, and its `detail`, which is an object holding the event's data.
Every Laboratory Event will have a `detail` which is an immutable object.

It is rare that you will need to interact with events through traditional methods, ie using `document.addEventListener()`.
Instead, the special functions `Laboratory.dispatch()`, `Laboratory.listen()`, and `Laboratory.forget()` should be used to dispatch and listen for events.
The advantage to using these functions is that they will handle event and detail creation for you.
For example, the following code would dispatch the `LaboratorySomethingRequested` event with the provided `detail`.

>   ```javascript
>       Laboratory.dispatch("LaboratorySomethingRequested", detail);
>   ```

This code can be used to associate a callback with a `LaboratorySomethingReceieved` event:

>   ```javascript
>       Laboratory.listen("LaboratorySomethingReceived", callback);
>   ```

This code can be used to forget the previous association:

>   ```javascript
>       Laboratory.forget("LaboratorySomethingReceived", callback);
>   ```

####  Three types of event.

Laboratory Events are broken up into three general categories: __requests__, __responses__, and __failures__.
(There are a few miscellaneous events which don't fall into one of these categories, but they are few and far between.)
Requests usually have names like `LaboratorySomethingRequested`, responses usually have names like `LaboratorySomethingReceived`, and failures usually have names like `LaboratorySomethingFailed`.
Typically, you will dispatch requests, and listen for their associated responses (or failures if the response doesn't go through).
Of course, there is nothing stopping you from dispatching your own responses and failures, or from listening for others' requests.
However, generally speaking this should not be necessary.

>   __[Issue #4](https://github.com/marrus-sh/laboratory/issues/4) :__
>   Events of the form `LaboratorySomethingFailed` will probably be consolidated into a single `LaboratoryFailure` event at some point in the future.

####  Event promises.

If your environment supports `Promise`s, then the `Laboratory.request()` function will handle the request/response/failure pipeline for you; for example:

>   ```javascript
>       Laboratory.request("LaboratorySomethingRequested", detail).then(callback).else(onError);
>   ```

####  Event details.

Dispatching most events requires calling `Laboratory.dispatch()` with not only a string specifying the event, but also a `detail`, which is an object containing additional event information.
The kind of information expected by a `detail` varies from event to event, so be sure to check the documentation to see what is required.

When you listen for an event using `Laboratory.listen()`, the callback function you provide will be called with the event's `detail` as its argument.
For responses, `detail`s will be instances of the modules to which the events belong; for example, the detail for a `LaboratoryProfileRequested` event is an instance of `Laboratory.Profile`.
The `detail`s for failures are all objects of type `Laboratory.Failure`.

###  Laboratory Event reference:

Laboratory Events are broken up into several __modules__, each of which is documented within its source.
These are as follows:

- [__Initialization__](Initialization.litcoffee)
- [__Request__](Request.litcoffee)
- [__Client__](Client.litcoffee)
- [__Authorization__](Authorization.litcoffee)
- [__Profile__](Profile.litcoffee)
- [__Rolodex__](Rolodex.litcoffee)
- [__Attachment__](Attachment.litcoffee)
- [__Post__](Post.litcoffee)
- [__Timeline__](Timeline.litcoffee)

 - - -

##  Implementation  ##

There is a lot that goes on behind-the-scenes to make Laboratory events so easy to dispatch and listen for.
Roughly speaking, we have to:

1.  Keep a record of all accepted Laboratory events.
2.  Specify what is expected of an event's *detail*, and give default values
3.  Associate requests with responses and failures
4.  Associate our handlers with events and keep track of them for later
5.  Create the `dispatch()`, `listen()`, and `forget()` functions
6.  Create promises and the `request()` function for accessing them.

For simplicity's sake, we will store our events inside a giant object called `LaboratoryEvent`, whose methods will greatly ease this process.
`LaboratoryEvent` won't be exposed to the window, it's just for our own internal use.

    LaboratoryEvent =

        Events: {}
        Handlers: []

###  Adding new events:

The `LaboratoryEvent.create()` function registers a new event and associates it with a `detail`.
If the provided `detail` is an object, then its own properties will determine the allowed and default properties of the event's detail; if it is a constructor, then the provided detail must be an instance (or `null`).

        create: (type, detail) ->
            LaboratoryEvent.Events[type] = {detail: Object detail} unless LaboratoryEvent.Events[type]?
            return LaboratoryEvent

###  Associating requests with responses and failures:

The `LaboratoryEvent.associate()` function associates a request with its response or failure.

        associate: (request, response, failure) ->
            return LaboratoryEvent unless typeof (levent = LaboratoryEvent.Events[request]) is "object"
            levent.response = response if response?
            levent.failure = failure if failure?
            return LaboratoryEvent

###  Setting up handlers:

The `LaboratoryEvent.handle()` function just associates a `type` with a `callback`.
It sets things up so we can easily add our handlers later.

>   __Note :__
>   The `handle()` function directly modifies and stores its `callback` argument, which would definitely be a no-go if we were exposing it to outsiders.
>   It saves us having to wrap the callback in an object or, worse, yet another function though, so let's just treat it responsibly and keep this between us.

        handle: (type, callback) ->
            return LaboratoryEvent unless LaboratoryEvent.Events[type = String type]?
            callback.type = type
            LaboratoryEvent.Handlers.push callback
            return LaboratoryEvent

###  Dispatching events:

We can now create our `dispatch()` function.
It just sets up our detail and dispatches the event to `document`.

    Laboratory.dispatch = dispatch = (event, props) ->
        return no unless (levent = LaboratoryEvent.Events[event = String event])?
        if typeof (initials = levent.detail) is "function"
            return no unless (detail = props) instanceof initials
        else
            detail = {}
            (detail[prop] = if props? and props[prop]? then props[prop] else initial) for prop, initial of initials
        document.dispatchEvent new CustomEvent event, {detail: Object.freeze detail}
        return yes

###  Listening for and forgetting events:

Our `listen()` function is just a wrapper for `document.addEventListener()`.

    Laboratory.listen = listen = (event, callback) ->
        return no unless (levent = LaboratoryEvent.Events[event = String event])? and typeof callback is "function"
        document.addEventListener event, callback
        return yes

Similarly, our `forget()` function is just a wrapper for `document.removeEventListener()`.

    Laboratory.forget = forget = (event, callback) ->
        return no unless (levent = LaboratoryEvent.Events[event = String event])? and typeof callback is "function"
        document.removeEventListener event, callback
        return yes

###  Making promises:

The `request()` function handles the listening and forgetting for us, returning a `Promise`.

    Laboratory.request = request = (event, detail) -> new Promise (resolve, reject) ->
        return unless (levent = LaboratoryEvent.Events[event])?
        respond = (detail) ->
            forget response, respond if response?
            forget failure, fail if failure?
            resolve detail
        fail = (detail) ->
            forget response, respond if response?
            forget failure, fail if failure?
            reject detail
        listen response, respond if (response = levent.response)?
        listen failure, fail if (failure = levent.failure)?
        dispatch event, detail
        return


- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>API/Attachment.litcoffee</code></p>

#  ATTACHMENT EVENTS  #

 - - -

##  Description  ##

The __Attachment__ module of the Laboratory API is comprised of those events which are related to Mastodon media attachments.

###  Quick reference:

| Event | Description |
| :---- | :---------- |
| `LaboratoryAttachmentRequested` | Requests an `Attachment` from the Mastodon server |
| `LaboratoryAttachmentReceived` | Fires when an `Attachment` has been processed |
| `LaboratoryAttachmentFailed` | Fires when an `Attachment` fails to process |

###  Requesting an attachment:

>   - __API equivalent :__ `/api/v1/media`
>   - __Request parameters :__
>       - __`file` :__ The file to upload
>   - __Request :__ `LaboratoryAttachmentRequested`
>   - __Response :__ `LaboratoryAttachmentReceived`
>   - __Failure :__ `LaboratoryAttachmentFailed`

Laboratory Attachment events are used to upload files to the server and receive media `Attachment`s which can then be linked to posts.
The only relevant parameter is `file`, which should be the `File` to upload.

 - - -

##  Implementation  ##

###  Creating the events:

Here we create the events as per our specifications.

    LaboratoryEvent
        .create "LaboratoryAttachmentRequested",
            file: undefined
        .create "LaboratoryAttachmentReceived", Attachment
        .create "LaboratoryAttachmentFailed", Failure
        .associate "LaboratoryAttachmentRequested", "LaboratoryAttachmentReceived", "LaboratoryAttachmentFailed"

###  Handling the events:

Laboratory provides handlers for the following Authorization events:

- `LaboratoryAttachmentRequested`

####  `LaboratoryAttachmentRequested`.

The `LaboratoryAttachmentRequested` event uploads a file to the Mastodon API and turns the response into an `Attachment`.

        .handle "LaboratoryAttachmentRequested", (event) ->

            unless File? and (file = event.detail.file) instanceof File
                dispatch "LaboratoryAttachmentFailed", new Failure "Unable to create attachment; none provided", "LaboratoryAttachmentRequested"
                return
            unless FormData?
                dispatch "LaboratoryAttachmentFailed", new Failure "Unable to create attachment; `FormData` is not supported on this platform"

            onComplete = (response, data, params) -> dispatch "LaboratoryAttachmentReceived", new Attachment response
            onError = (response, data, params) -> dispatch "LaboratoryAttachmentFailed", new Failure response.error, "LaboratoryAttachmentRequested", params.status
            serverRequest "POST", Store.auth.origin + "/api/v1/media", (
                form = new FormData
                form.append "file", file
                form
            ), Store.auth.accessToken, onComplete, onError


- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>API/Authorization.litcoffee</code></p>

#  AUTHORIZATION EVENTS  #

 - - -

##  Description  ##

The __Authorization__ module of Laboratory Events is comprised of those events which are related to OAuth registration of the Laboratory client with the Mastodon server.

###  Quick reference:

| Event | Description |
| :-------------- | :---------- |
| `LaboratoryAuthorizationRequested` | Fires when a new access token should be requested from the OAuth server |
| `LaboratoryAuthorizationReceived` | Fires when an access token has been received from the OAuth server |
| `LaboratoryAuthorizationFailed` | Fires when a request for an access token failed |
| `LaboratoryAuthorizationGranted` | Fires when a popup receives an authorization code |

###  Requesting authorization:

>   - __API equivalent :__ `/oauth/token`, `/api/v1/verify_credentials`
>   - __Request parameters :__
>       - __`name` :__ The name of the client application (default: `"Laboratory"`)
>       - __`url` :__ The location of the Mastodon server (default: `"/"`)
>       - __`redirect` :__ The base url for the application (default: `""`)
>       - __`scope` :__ An `Authorization.Scope` (default: `Authorization.Scope.READ`)
>   - __Request :__ `LaboratoryAuthorizationRequested`
>   - __Response :__ `LaboratoryAuthorizationReceived`
>   - __Failure :__ `LaboratoryAuthorizationFailed`
>   - __Miscellanous events :__
>       - `LaboratoryAuthorizationGranted`

The `LaboratoryAuthorizationRequested` event requests an access token for use with OAuth.
This will likely be the first request you make when interacting with Laboratory.
You probably don't need to keep track of its response, since this data will be made available through the `Laboratory` object.

The `LaboratoryAuthorizationGranted` event fires when a user has granted authorization through the OAuth popup.
Its `detail` will contain either a `code` or an `accessToken`, alongside an optional `window`, `origin` and `scope`.
If you have somehow acquired an access token from somewhere else, passing this value to `LaboratoryAuthorizationGranted` alongside its origin and scope will allow Laboratory to use it as well.
Alternatively, you can pass an `Authorization` object to `LaboratoryAuthorizationReceived`, but note that doing so requires more information.

>   __[Issue #13](https://github.com/marrus-sh/laboratory/issues/13) :__
>   The purpose and functioning of `LaboratoryAuthorizationGranted` may change radically (or the event might be removed) at some point in the future.

 - - -

##  Implementation  ##

###  Recalling the origin:

Only one authorization attempt can be made at a time, since it is made in a named window.
`recalledOrigin`, `recalledClient`, and `recalledSecret` remember these values from between when authorization is requested and when it is granted.

    do ->
        recalledOrigin = undefined
        recalledClient = undefined
        recalledSecret = undefined

###  Creating the events:

Here we create the events as per our specifications.

        LaboratoryEvent

            .create "LaboratoryAuthorizationRequested",
                name: "Laboratory"
                url: "/"
                redirect: ""
                scope: Authorization.Scope.READ
            .create "LaboratoryAuthorizationReceived", Authorization
            .create "LaboratoryAuthorizationFailed", Failure
            .associate "LaboratoryAuthorizationRequested", "LaboratoryAuthorizationReceived", "LaboratoryAuthorizationFailed"

            .create "LaboratoryAuthorizationGranted",
                code: undefined
                accessToken: undefined
                origin: undefined
                scope: Authorization.Scope.NONE

###  Handling the events:

Laboratory provides handlers for the following Authorization events:

- `LaboratoryAuthorizationRequested`
- `LaboratoryAuthorizationGranted`
- `LaboratoryAuthorizationReceived`

####  `LaboratoryAuthorizationRequested`.

The `LaboratoryAuthorizationRequested` handler starts a request for a new access token from the API.
The code for this handler is very complex, largely because it takes place across multiple asynchronous requests and two separate windows.
`LaboratoryAuthorizationRequested` only handles the first half of the request; see `LaboratoryAuthorizationGranted` for the second half.

            .handle "LaboratoryAuthorizationRequested", (event) ->

If we weren't provided with a scope, we'll set it to the default.

                scope = Authorization.Scope.READ unless (scope = event.detail.scope) instanceof Authorization.Scope

First, we normalize our URL.
We also get our redirect URI at this point.

                a = document.createElement "a"
                a.href = event.detail.url
                origin = a.origin
                a.href = event.detail.redirect or ""
                redirect = a.href

The `makeRequest()` function will request our token once we acquire a client id and secret.
Of course, it is possible that we already have these.

                makeRequest = ->

The actual token requesting takes place after authorization has been granted by the popup window (see the script at the beginning of [README](../README.litcoffee)); but we open it up here.

>   __Note :__
>   This window **will be blocked** by popup blockers unless it has already been opened previously in response to a click or keyboard event.

                    window.open origin + "/oauth/authorize?" + (
                        (
                            (encodeURIComponent key) + "=" + (encodeURIComponent value) for key, value of {
                                client_id: clientID
                                response_type: "code"
                                redirect_uri: redirect
                                scope: (
                                    scopeList = []
                                    scopeList.push "read" if scope & Authorization.Scope.READ
                                    scopeList.push "write" if scope & Authorization.Scope.WRITE
                                    scopeList.push "follow" if scope & Authorization.Scope.FOLLOW
                                    scopeList.join " "
                                )
                            }
                        ).join "&"
                    ), "LaboratoryOAuth"
                    recalledOrigin = origin
                    recalledClient = clientID
                    recalledSecret = clientSecret

We can only make our request once we have been registered as a client.
Laboratory stores its client and authorization data in `localStorage`.
Here we try to access that data if present:

                [storedRedirect, clientID, clientSecret, storedScope, accessToken] = (localStorage.getItem "Laboratory | " + origin).split " ", 5 if localStorage?.getItem "Laboratory | " + origin

If we have an access token which supports our requested `scope` then we can immediately try using it.
We'll just forward it to `LaboratoryAuthorizationGranted`.
It is important that we `return` here or else we'll end up requesting another token anyway.

                if accessToken and (scope & storedScope) is +scope
                    dispatch "LaboratoryAuthorizationGranted",
                        accessToken: accessToken
                        origin: origin
                        scope: scope
                    return

If we have client credentials and they are properly associated with our `redirect` and `scope`, we can go ahead and `makeRequest()`.

                if storedRedirect is redirect and (scope & storedScope) is +scope and clientID? and clientSecret? then do makeRequest

Otherwise, we need to get new client credentials before proceeding.

                else

                    handleClient = (e) ->
                        return unless (client = e.detail) instanceof Client and client.origin is origin and (scope & client.scope) is +scope and client.redirect is redirect and client.clientID? and client.clientSecret?
                        {clientID, clientSecret, scope} = client
                        localStorage.setItem "Laboratory | " + origin, [redirect, clientID, clientSecret, +scope].join " "
                        forget "LaboratoryClientReceived", handleClient
                        clearTimeout timeout
                        do makeRequest

                    listen "LaboratoryClientReceived", handleClient

                    dispatch "LaboratoryClientRequested",
                        name: event.detail.name
                        url: origin
                        redirect: redirect
                        scope: Authorization.Scope.fromValue scope

If we aren't able to acquire a client ID within 30 seconds, we timeout.

                    timeout = setTimeout (
                        ->
                            forget "LaboratoryClientReceived", handleClient
                            dispatch "LaboratoryAuthorizationFailed", new Failure "Unable to authorize client", "LaboratoryAuthorizationRequested"
                    ), 30000

####  `LaboratoryAuthorizationGranted`.

>   __[Issue #13](https://github.com/marrus-sh/laboratory/issues/13) :__
>   This event may change radically (or be removed) in the future.

The `LaboratoryAuthorizationGranted` handler does the *actual* requesting of an access token, using the authorization code in its `detail`.
It then attempts to verify the access token through a simple request to `/api/v1/accounts/verify_credentials`.
If this succeeds, then it will respond with the `Authorization`.

            .handle "LaboratoryAuthorizationGranted", (event) ->

                do (window.open "about:blank", "LaboratoryOAuth").close

Our authorization must have an associated `origin`.
If it doesn't, we can't proceed.

                unless origin = event.detail.origin or recalledOrigin
                    dispatch "LaboratoryAuthorizationFailed", new Failure "Authorization data wasn't associated with an origin", "LaboratoryAuthorizationRequested"
                    return

We also initialize our `scope`, `datetime`, and `tokenType` variables now.
We'll only use these initial values if an `accessToken` was directly provided, otherwise we'll overwrite them using the server's response.

                scope = if event.detail.scope instanceof Authorization.Scope then (
                    scopeList = []
                    scopeList.push "read" if scope & Authorization.Scope.READ
                    scopeList.push "write" if scope & Authorization.Scope.WRITE
                    scopeList.push "follow" if scope & Authorization.Scope.FOLLOW
                    scopeList.join " "
                ) else ""
                datetime = NaN
                tokenType = "bearer"

The function `verify()` will attempt to verify our access token.
The response should be an account object.

                verify = ->

                    verifyComplete = (response, data, params) ->
                        dispatch "LaboratoryAuthorizationReceived", new Authorization {
                            access_token: String accessToken
                            created_at: String +datetime
                            scope: scope
                            token_type: tokenType
                        }, origin, response.id
                        localStorage.setItem "Laboratory | " + origin, [redirect, clientID, clientSecret, Authorization.Scope.READ * (((scopes = scope.split /[\s\+]+/g).indexOf "read") isnt -1) + Authorization.Scope.WRITE * ((scopes.indexOf "write") isnt -1) + Authorization.Scope.FOLLOW * ((scopes.indexOf "follow") isnt -1), accessToken].join " "
                        dispatch "LaboratoryProfileReceived", new Profile response

                    verifyError = (response, data, params) -> dispatch "LaboratoryAuthorizationFailed", new Failure response.error, "LaboratoryAuthorizationRequested", params.status

                    serverRequest "GET", origin + "/api/v1/accounts/verify_credentials", null, accessToken, verifyComplete, verifyError

If we were given an access token then we can go ahead and verify now.

                if accessToken = event.detail.accessToken then do verify

Otherwise we first have to acquire one.

                else if code = event.detail.code

We grab our client id and secret from our recalled values if possible, or localStorage otherwise.

                    if origin = recalledOrigin
                        clientID = recalledClient
                        cleintSecret = recalledSecret
                    else [redirect, clientID, clientSecret] = (localStorage.getItem "Laboratory | " + origin).split " ", 5 if localStorage?.getItem "Laboratory | " + origin

Here we make the actual request.

                    onComplete = (response, data, params) ->
                        accessToken = response.access_token
                        datetime = new Date response.created_at
                        scope = response.scope
                        tokenType = response.token_type
                        do verify
                    onError = (response, data, params) -> dispatch "LaboratoryAuthorizationFailed", new Failure response.error, "LaboratoryAuthorizationRequested", params.status
                    serverRequest "POST", origin + "/oauth/token", {
                        client_id: clientID
                        client_secret: clientSecret
                        redirect_uri: redirect
                        grant_type: "authorization_code"
                        code: code
                    }, null, onComplete, onError

If we weren't given an `accessToken` *or* a `code`, that's an error.

                else dispatch "LaboratoryAuthorizationFailed", new Failure "No authorization code or access token was granted", "LaboratoryAuthorizationRequested"

We can now reset our recalled variables.

                recalledOrigin = recalledClient = recalledSecret = undefined

####  `LaboratoryAuthorizationReceived`.

The `LaboratoryAuthorizationReceived` handler just saves the provided `Authorization` to the `Store`.
It also exposes it to the window through `Exposed`.

            .handle "LaboratoryAuthorizationReceived", (event) -> Exposed.auth = Store.auth = event.detail if event.detail instanceof Authorization


- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>API/Client.litcoffee</code></p>

#  CLIENT EVENTS  #

 - - -

##  Description  ##

The __Client__ module of Laboratory Events is comprised of those events which are related to OAuth registration of the Laboratory client with the Mastodon server.

###  Quick reference:

| Event | Description |
| :-------------- | :---------- |
| `LaboratoryClientRequested` | Fires when a client id and secret should be requested from the OAuth server |
| `LaboratoryClientReceived` | Fires when a client id and secret have been received from the OAuth server |
| `LaboratoryClientFailed` | Fires when a request for a client id and secret from the OAuth server failed |

###  Requesting client authorization:

>   - __API equivalent :__ `/api/v1/apps`
>   - __Request parameters :__
>       - __`name` :__ The name of the client application (default: `"Laboratory"`)
>       - __`url` :__ The location of the Mastodon server (default: `"/"`)
>       - __`redirect` :__ The base url for the application (default: `""`)
>       - __`scope` :__ A `Laboratory.Authorization.Scope` (default: `Laboratory.Authorization.Scope.READWRITEFOLLOW`)
>   - __Request :__ `LaboratoryClientRequested`
>   - __Response :__ `LaboratoryClientReceived`
>   - __Failure :__ `LaboratoryClientFailed`

The `LaboratoryClientRequested` event requests a new client id for use with OAuth.
Laboratory will fire this event automatically as necessary during the handling of `LaboratoryAuthorizationRequested`, so it isn't something you usually need to worry about.
However, you can request this yourself if you find yourself needing new client authorization.

 - - -

##  Implementation  ##

###  Creating the events:

Here we create the events as per our specifications.

    LaboratoryEvent
        .create "LaboratoryClientRequested",
            name: "Laboratory"
            url: "/"
            redirect: ""
            scope: Authorization.Scope.READ
        .create "LaboratoryClientReceived", Client
        .create "LaboratoryClientFailed", Failure
        .associate "LaboratoryClientRequested", "LaboratoryClientReceived", "LaboratoryClientFailed"

###  Handling the events:

Laboratory provides handlers for the following Client events:

- `LaboratoryClientRequested`

####  `LaboratoryClientRequested`.

The `LaboratoryClientRequested` handler requests a new client id and secret from the API, and fires `LaboratoryClientReceived` when it is granted.

        .handle "LaboratoryClientRequested", (event) ->

If we weren't provided with a scope, we'll set it to the default.

            scope = Authorization.Scope.READ unless (scope = event.detail.scope) instanceof Authorization.Scope

First, we normalize our URL.
We also get our redirect URI at this point.

            a = document.createElement "a"
            a.href = event.detail.url
            origin = a.origin
            a.href = event.detail.redirect or ""
            redirect = a.href

If our request completes, then we want to respond with a `Client` object.

            onComplete = (response, data, params) -> dispatch "LaboratoryClientReceived", new Client response, data, origin

Otherwise, we need to generate a `Failure`.

            onError = (response, data, params) -> dispatch "LaboratoryClientFailed", new Failure response.error, "LaboratoryClientRequested", params.status

Now we can send our request.

            serverRequest "POST", origin + "/api/v1/apps", {
                client_name: event.detail.name
                redirect_uris: event.detail.redirect
                scopes: do ->
                    scope = event.detail.scope
                    scopeList = []
                    scopeList.push "read" if scope & Authorization.Scope.READ
                    scopeList.push "write" if scope & Authorization.Scope.WRITE
                    scopeList.push "follow" if scope & Authorization.Scope.FOLLOW
                    return scopeList.join " "
            }, null, onComplete, onError


- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>API/Initialization.litcoffee</code></p>

#  INITIALIZATION EVENTS  #

 - - -

##  Description  ##

The __Initialization__ module of the Laboratory API is comprised of those events which are related to initialization of the Laboratory store and handlers.
These make up just two events: `LaboratoryInitializationLoaded` and `LaboratoryInitializationReady`.

You can check `window.Laboratory.ready` as a means of verifying if these events have fired after-the-fact:
If `window.Laboratory.ready` exists, then `LaboratoryInitializationLoaded` has fired.
If it is `true`, then `LaboratoryInitializationReady` has fired as well.

**You should not fire Laboratory Initialization events yourself.**
They will be ignored by Laboratory proper, but may confuse other components which you might have loaded.
However, you should listen for these events to know when proper communication with the Laboratory framework should begin.

###  Quick reference:

| Event | Description |
| :---- | :---------- |
| `LaboratoryInitializationLoaded` | Fires when the Laboratory script has been loaded and run |
| `LaboratoryInitializationReady` | Fires when the Laboratory event handlers are ready to receive events |

###  Checking initialization status:

>   - __API equivalent :__ _None_
>   - __Miscellanous events :__
>       - `LaboratoryInitializationLoaded`
>       - `LaboratoryInitializationReady`

The `LaboratoryInitializationLoaded` event fires when the Laboratory script has been loaded and run, and can be used when loading Laboratory in an asynchronous manner.
After this event fires, it is safe to use the `Laboratory` object in your code.
Before this event fires, the `Laboratory` object will likely not have been defined yet.

The `LaboratoryInitializationReady` event fires when the Laboratory handlers have been assigned to their appropriate events.
After this event fires, it is safe to dispatch `Laboratory` events.
Before this event fires, it is unlikely (although not *impossible*) that they will be acted upon.

Laboratory waits for the entire document to be loaded before assigning its handlers; consequently, there is a possibility that `LaboratoryInitializationLoaded` will fire well before `LaboratoryInitializationReady`, especially with scripts loaded synchronously.
Of the two, `LaboratoryInitializationReady` is almost always the one to listen for.

Neither of the Laboratory Initialization events have `detail`s.

 - - -

##  Implementation  ##

###  Creating the events:

Here we create the events as per our specifications.

    LaboratoryEvent
        .create "LaboratoryInitializationLoaded"
        .create "LaboratoryInitializationReady"

###  Handling the events:

Laboratory Initialization events do not have handlers.


- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>API/Post.litcoffee</code></p>

#  POST EVENTS  #

 - - -

##  Description  ##

The __Post__ module of the Laboratory API is comprised of those events which are related to Mastodon accounts.

###  Quick reference:

| Event | Description |
| :---- | :---------- |
| `LaboratoryPostRequested` | Requests a `Laboratory.Post` for a specified status or notification |
| `LaboratoryPostReceived` | Fires when a `Laboratory.Post` has been processed |
| `LaboratoryPostFailed` | Fires when a `Laboratory.Post` fails to process |
| `LaboratoryPostCreation` | Petitions the Mastodon server to create a new status |
| `LaboratoryPostDeletion` | Petitions the Mastodon server to delete the provided status |
| `LaboratoryPostSetReblog` | Petitions the Mastodon server to reblog or unreblog the provided status |
| `LaboratoryPostSetFavourite` | Petitions the Mastodon server to favourite or unfavourite the provided status |

###  Requesting a status:

>   - __API equivalent :__ `/api/v1/statuses/:id`, `/api/v1/notifications/:id`
>   - __Request parameters :__
>       - __`id` :__ The id of the status or notification to request
>       - __`type` :__ A `Post.Type` (default: `Post.Type.STATUS`)
>   - __Request :__ `LaboratoryPostRequested`
>   - __Response :__ `LaboratoryPostReceived`
>   - __Failure :__ `LaboratoryPostFailed`

Laboratory Post events are used to request [`Post`](../Constructors/Post.litcoffee)s containing data on a specified status or notification.
The request, `LaboratoryPostRequested`, takes an object whose `id` parameter specifies the account to fetch and whose `type` specifies whether the post is a status or notification.

Laboratory keeps track of all of the `Post`s it receives in its internal store.
If there is already information on the requested `Post` in the Laboratory store, it will fire `LaboratoryPostReceived` immediately, and then again once the server request completes.
However, Laboratory will only fire as many responses as necessary; if nothing has changed from the stored value, then only one response will be given.

###  Creating and deleting posts:

>   - __API equivalent :__ `/api/v1/statuses`, `/api/v1/statuses/:id`
>   - __Miscellaneous events :__
>       - `LaboratoryPostCreation`
>       - `LaboratoryPostDeletion`

The `LaboratoryPostCreation` event attempts to create a new status on the Mastodon server.
It should be fired with a `detail` containing the following properties:

- __`text` :__ The text of the post
- __`visibility` :__ A `Post.Visibility` (default: `Post.Visibility.PRIVATE`)
- __`inReplyTo` :__ A status id if the post is a reply
- __`attachments` :__ An array of `Attachment`s
- __`message` :__ A content/spoiler warning
- __`makeNSFW` :__ Whether or not the attached media contains NSFW content (default: `true`)

The `LaboratoryPostDeletion` event attempts to delete an existing status from the Mastodon server.
The `id` property of its `detail` should provide the id of the status to delete.

###  Favouriting and reblogging posts:

>   - __API equivalent :__ `/api/v1/statuses/:id/reblog`, `/api/v1/statuses/:id/unreblog`, `/api/v1/statuses/:id/favourite`, `/api/v1/statuses/:id/unfavourite`
>   - __Miscellanous events :__
>       - `LaboratoryPostSetReblog`
>       - `LaboratoryPostSetFavourite`

The `LaboratoryPostSetReblog` and `LaboratoryPostSetFavourite` events can be used to set the reblog or favourite status of posts.
They should be fired with a `detail` which has two properties: `id`, which gives the id of the account, and `value`, which should be `true` if the post should be favourited/reblogged, or `false` if it should be unfavourited/unreblogged.

 - - -

##  Implementation  ##

###  Creating the events:

Here we create the events as per our specifications.

    LaboratoryEvent
        .create "LaboratoryPostRequested",
            id: undefined
            type: Post.Type.STATUS
        .create "LaboratoryPostReceived", Post
        .create "LaboratoryPostFailed", Failure
        .associate "LaboratoryPostRequested", "LaboratoryPostReceived", "LaboratoryPostFailed"

        .create "LaboratoryPostCreation",
            text: ""
            visibility: Post.Visibility.PRIVATE
            inReplyTo: undefined
            attachments: undefined
            message: undefined
            makeNSFW: yes
        .create "LaboratoryPostDeletion",
            id: undefined

        .create "LaboratoryPostSetReblog",
            id: undefined
            value: on
        .create "LaboratoryPostSetFavourite",
            id: undefined
            value: on

###  Handling the events:

Laboratory provides handlers for the following Authorization events:

- `LaboratoryPostRequested`
- `LaboratoryPostReceived`
- `LaboratoryPostCreation`
- `LaboratoryPostDeletion`
- `LaboratoryPostSetReblog`
- `LaboratoryPostSetFavourite`

####  `LaboratoryPostRequested`.

The `LaboratoryPostRequested` event requests a status or notification from the Mastodon API, processes it, and fires a `LaboratoryPostReceived` event with the resultant `Post`.

        .handle "LaboratoryPostRequested", (event) ->

            unless isFinite id = Number event.detail.id
                dispatch "LaboratoryPostFailed", new Failure "Unable to fetch post; no id specified", "LaboratoryPostRequested"
                return
            unless (type = event.detail.type) instanceof Post.Type
                dispatch "LaboratoryPostFailed", new Failure "Unable to fetch post; no type specified", "LaboratoryPostRequested"
                return
            isANotification = type & Post.Type.Notification

If we already have information for the specified post loaded into our `Store`, we can go ahead and fire a `LaboratoryPostReceived` event with that information now.

            dispatch "LaboratoryPostReceived", Store.statuses[id] if not isANotification and Store.statuses[id]?
            dispatch "LaboratoryPostReceived", Store.notifications[id] if isANotification and Store.notifications[id]?

When our new post data is received, we'll process it and do the same—*if* something has changed.

            onComplete = (response, data, params) ->
                unless response.id is id
                    dispatch "LaboratoryPostFailed", new Failure "Unable to fetch post; returned post did not match requested id", "LaboratoryPostRequested"
                    return
                post = new Post response
                unless (post.type & Post.Type.NOTIFICATION) is isANotification
                    dispatch "LaboratoryPostFailed", new Failure "Unable to fetch post; returned post was not of specified type", "LaboratoryPostRequested"
                    return
                store = if isANotification then Store.notifications else Store.statuses
                dispatch "LaboratoryPostReceived", post unless post.compare store[id]

If something goes wrong, then we need to throw an error.

            onError = (response, data, params) -> dispatch "LaboratoryPostFailed", new Failure response.error, "LaboratoryPostRequested", params.status

Finally, we can make our server request.

            serverRequest "GET", Store.auth.origin + (if isANotification then "/api/v1/notifications/" else "/api/v1/statuses/") + id, null, Store.auth.accessToken, onComplete, onError

####  `LaboratoryPostReceived`.

The `LaboratoryPostReceived` event simply adds a received post to our store.

        .handle "LaboratoryPostReceived", (event) -> (if event.detail.type & Post.Type.NOTIFICATION then Store.notifications else Store.statuses)[id] = event.detail if event.detail instanceof Post and event.detail.type instanceof Post.Type and isFinite id = Number event.detail.id

####  `LaboratoryPostCreation`.

The `LaboratoryPostCreation` event attempts to create a new status, and fires a `LaboratoryPostReceived` event with the new `Post` if it succeeds.

        .handle "LaboratoryPostCreation", (event) ->

            onComplete = (response, data, params) -> dispatch "LaboratoryPostReceived", new Post response

            onError = (response, data, params) -> dispatch "LaboratoryPostFailed", new Failure response.error, "LaboratoryPostCreation", params.status

            serverRequest "POST", Store.auth.origin + "/api/v1/statuses/", (
                status: event.detail.text
                in_reply_to_id: if (inReplyTo = event.detail.inReplyTo) > 0 and isFinite inReplyTo then inReplyTo else undefined
                media_ids: if (attachments = event.detail.attachments) instanceof Array then (attachment.id for attachment in attachments when attachment instanceof Attachment) else undefined
                sensitive: if event.detail.makeNSFW then "true" else undefined
                spoiler_text: if (message = event.detail.message) then String message else undefined
                visibility: switch event.detail.visibility
                    when Post.Visibility.PUBLIC then "public"
                    when Post.Visibility.REBLOGGABLE then "unlisted"
                    else "private"
            ), Store.auth.accessToken, onComplete, onError

####  `LaboratoryPostDeletion`.

The `LaboratoryPostDeletion` event attempts to delete an existing status.

>   __[Issue #21](https://github.com/marrus-sh/laboratory/issues/21) :__
>   There needs to be better responses and error checking with regards to post deletion.

        .handle "LaboratoryPostDeletion", (event) ->

            unless isFinite id = Number event.detail.id
                dispatch "LaboratoryPostFailed", new Failure "Unable to delete post; no id specified", "LaboratoryPostDeletion"
                return

            onComplete = ->
            onError = (response, data, params) -> dispatch "LaboratoryPostFailed", new Failure response.error, "LaboratoryPostDeletion", params.status

            serverRequest "DELETE", Store.auth.origin + "/api/v1/statuses/" + id, null, Store.auth.accessToken, onComplete, onError

####  `LaboratoryPostSetReblog`.

The `LaboratoryPostSetReblog` event attempts to set the reblog status of a post according to the specified `value`.
It will fire a new `LaboratoryPostReceived` event updating the post's information if it succeeds.

        .handle "LaboratoryPostSetReblog", (event) ->

Obviously we need an `id` and `value` to do our work.

            dispatch "LaboratoryPostFailed", new Failure "Cannot set reblog status for post: Either value or id is missing", "LaboratoryPostSetReblog" unless (value = !!event.detail.value)? and isFinite id = Number event.detail.id

Here we handle the server response for our reblog setting:

            onComplete = (response, data, params) -> dispatch "LaboratoryPostReceived", new Post response
            onError = (response, data, params) -> dispatch "LaboratoryPostFailed", new Failure response.error, "LaboratoryPostSetReblog", params.status

If we already have a post for the specified id loaded into our `Store`, then we can test its current reblog value to avoid unnecessary requests.
We'll only send the request if the values differ.

            serverRequest "POST", Store.auth.origin + "/api/v1/statuses/" + id + (if value then "/reblog" else "/unreblog"), null, Store.auth.accessToken, onComplete, onError unless Store.statuses[id]?.isReblogged is value

####  `LaboratoryPostSetFavourite`.

The `LaboratoryPostSetFavourite` event attempts to set the favourite status of a post according to the specified `value`.
It will fire a new `LaboratoryPostReceived` event updating the post's information if it succeeds.

        .handle "LaboratoryPostSetFavourite", (event) ->

Obviously we need an `id` and `value` to do our work.

            dispatch "LaboratoryPostFailed", new Failure "Cannot set favourite status for post: Either value or id is missing", "LaboratoryPostSetFavourite" unless (value = !!event.detail.value)? and isFinite id = Number event.detail.id

Here we handle the server response for our favourite setting:

            onComplete = (response, data, params) -> dispatch "LaboratoryPostReceived", new Post response
            onError = (response, data, params) -> dispatch "LaboratoryPostFailed", new Failure response.error, "LaboratoryPostSetFavourite", params.status

If we already have a post for the specified id loaded into our `Store`, then we can test its current favourite value to avoid unnecessary requests.
We'll only send the request if the values differ.

            serverRequest "POST", Store.auth.origin + "/api/v1/statuses/" + id + (if value then "/favourite" else "/unfavourite"), null, Store.auth.accessToken, onComplete, onError unless Store.statuses[id]?.isFavourited is value


- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>API/Profile.litcoffee</code></p>

#  PROFILE EVENTS  #

 - - -

##  Description  ##

The __Profile__ module of the Laboratory API is comprised of those events which are related to Mastodon accounts.

###  Quick reference:

| Event | Description |
| :---- | :---------- |
| `LaboratoryProfileRequested` | Requests a `Laboratory.Profile` for a specified account |
| `LaboratoryProfileReceived` | Fires when a `Laboratory.Profile` has been processed |
| `LaboratoryProfileFailed` | Fires when a `Laboratory.Profile` fails to process |
| `LaboratoryProfileSetRelationship` | Petitions the Mastodon server to change the relationship between the user and the specified account |

###  Requesting a profile:

>   - __API equivalent :__ `/api/v1/accounts/:id`, `/api/v1/accounts/relationships`
>   - __Request parameters :__
>       - __`id` :__ The id of the profile to request
>       - __`requestRelationships` :__ Whether to request current relationship information regarding the specified account (default: `true`)
>   - __Request :__ `LaboratoryProfileRequested`
>   - __Response :__ `LaboratoryProfileReceived`
>   - __Failure :__ `LaboratoryProfileFailed`

Laboratory Profile events are used to request [`Profile`](../Constructors/Profile.litcoffee)s containing data on a specified account.
The request, `LaboratoryProfileRequested`, takes an object whose `id` parameter specifies the account to fetch.
Laboratory Profile events automatically request up-to-date relationship information for the accounts they fetch; if this is not needed, you can set the `requestRelationships` to `false`.

Laboratory keeps track of all of the `Profile`s it receives in its internal store.
This means that for each `LaboratoryProfileRequested` event, there could be as many as *three* `LaboratoryProfileReceived` responses: one containing the cached data from the store, one containing updated information from the server, and a third if the relationship information has changed as well.
However, Laboratory will only fire as many responses as necessary; if nothing has changed from the stored value, then only one response will be given.

###  Changing relationship status:

>   - __API equivalent :__ `/api/v1/accounts/follow`, `/api/v1/accounts/unfollow`, `/api/v1/accounts/block`, `/api/v1/accounts/unblock`, `/api/v1/accounts/mute`, `/api/v1/accounts/unmute`
>   - __Miscellanous events :__
>       - `LaboratoryProfileSetRelationship`

The `LaboratoryProfileSetRelationship` event can be used to set the relationship status for an account.
It should be fired with a `detail` which has two properties: `id`, which gives the id of the account, and `relationship`, which gives a new [`Laboratory.Profile.Relationship`](../Constructors/Profile.litcoffee) for the account.

Note that only some relationship aspects can be changed; you can't, for example, make an account stop following you using `LaboratoryProfileSetRelationship`.
For the purposes of this event, a follow and a follow request are treated as equivalent.

 - - -

##  Implementation  ##

###  Creating the events:

Here we create the events as per our specifications.

    LaboratoryEvent
        .create "LaboratoryProfileRequested",
            id: undefined
            requestRelationships: yes
        .create "LaboratoryProfileReceived", Profile
        .create "LaboratoryProfileFailed", Failure
        .associate "LaboratoryProfileRequested", "LaboratoryProfileReceived", "LaboratoryProfileFailed"

        .create "LaboratoryProfileSetRelationship",
            id: undefined
            relationship: undefined

###  Handling the events:

Laboratory provides handlers for the following Authorization events:

- `LaboratoryProfileRequested`
- `LaboratoryProfileReceived`
- `LaboratoryProfileSetRelationship`

####  `LaboratoryProfileRequested`.

The `LaboratoryProfileRequested` event requests an account from the Mastodon API, processes it, and fires a `LaboratoryProfileReceived` event with the resultant `Profile`.

        .handle "LaboratoryProfileRequested", (event) ->

            unless isFinite id = Number event.detail.id
                dispatch "LaboratoryProfileFailed", new Failure "Unable to fetch profile; no id specified", "LaboratoryProfileRequested"
                return

If we already have information for the specified account loaded into our `Store`, we can go ahead and fire a `LaboratoryProfileReceived` event with that information now.

            dispatch "LaboratoryProfileReceived", Store.profiles[id] if Store.profiles[id]?

When our new profile data is received, we'll process it and do the same—*if* something has changed.
We'll also request the account's relationships if necessary.

            onComplete = (response, data, params) ->
                unless response.id is id
                    dispatch "LaboratoryProfileFailed", new Failure "Unable to fetch profile; returned profile did not match requested id", "LaboratoryProfileRequested"
                    return
                profile = new Profile response
                dispatch "LaboratoryProfileReceived", profile unless profile.compare Store.profiles[id]
                serverRequest "GET", Store.auth.origin + "/api/v1/accounts/relationships", {id}, Store.auth.accessToken, onRelationshipsComplete, onError if event.detail.requestRelationships

The function call is a little different, but the same is true with our profile relationships.

            onRelationshipsComplete = (response, data, params) ->
                relationships = response[0]
                return if Store.profiles[id]?.relationship is relationship = Profile.Relationship.fromValue (
                    (
                        Profile.Relationship.FOLLOWER * relationships.followed_by +
                        Profile.Relationship.FOLLOWING * relationships.following +
                        Profile.Relationship.REQUESTED * relationships.requested +
                        Profile.Relationship.BLOCKING * relationships.blocking +
                        Profile.Relationship.MUTING * relationships.muting +
                        Profile.Relationship.SELF * (relationships.id is Store.auth.me)
                    ) or Profile.Relationship.UNKNOWN
                )
                dispatch "LaboratoryProfileReceived", new Profile Store.profiles[id], relationship

If something goes wrong, then we need to throw an error.

            onError = (response, data, params) -> dispatch "LaboratoryProfileFailed", new Failure response.error, "LaboratoryProfileRequested", params.status

Finally, we can make our server request.

            serverRequest "GET", Store.auth.origin + "/api/v1/accounts/" + id, null, Store.auth.accessToken, onComplete, onError

####  `LaboratoryProfileReceived`.

The `LaboratoryProfileReceived` event simply adds a received profile to our store.

        .handle "LaboratoryProfileReceived", (event) -> Store.profiles[id] = event.detail if event.detail instanceof Profile and isFinite id = Number event.detail.id

####  `LaboratoryProfileSetRelationship`.

The `LaboratoryProfileSetRelationship` event attempts to set the relationship of an account to match that given by the `relationship` parameter of its detail.
It will fire a new `LaboratoryProfileReceived` event updating the account's information if it succeeds.

        .handle "LaboratoryProfileSetRelationship", (event) ->

Obviously we need an `id` and `relationship` to do our work.

            dispatch "LaboratoryProfileFailed", new Failure "Cannot set relationship for account: Either relationship or id is missing", "LaboratoryProfileSetRelationship" unless (relationship = event.detail.relationship) instanceof Profile.Relationship and isFinite id = Number event.detail.id

Here we handle the server response for our relationship setting:

            onComplete = (response, data, params) -> dispatch "LaboratoryProfileReceived", new Profile response

            onError = (response, data, params) -> dispatch "LaboratoryProfileFailed", new Failure response.error, "LaboratoryProfileSetRelationship", params.status

If we already have a profile for the specified account loaded into our `Store`, then we can test its current relationship to avoid unnecessary requests.
The XOR operation `profile.relationship ^ relationship` will allow us to identify which aspects of the relationship have changed.
We'll store this information in `changes`.

            if (profile = Store.profiles[id]) instanceof Profile
                changes = profile.relationship ^ relationship
                if changes & Profile.FOLLOWING then serverRequest "POST", Store.auth.origin + "/api/v1/accounts/" + id + (if relationship & Profile.FOLLOWING then "/follow" else "/unfollow"), null, Store.auth.accessToken, onComplete, onError
                else if changes & Profile.REQUESTED then serverRequest "POST", Store.auth.origin + "/api/v1/accounts/" + id + (if relationship & Profile.REQUESTED then "/follow" else "/unfollow"), null, Store.auth.accessToken, onComplete, onError
                if changes & Profile.BLOCKING then serverRequest "POST", Store.auth.origin + "/api/v1/accounts/" + id + (if relationship & Profile.BLOCKING then "/block" else "/unblock"), null, Store.auth.accessToken, onComplete, onError
                if changes & Profile.MUTING then serverRequest "POST", Store.auth.origin + "/api/v1/accounts/" + id + (if relationship & Profile.MUTING then "/mute" else "/unmute"), null, Store.auth.accessToken, onComplete, onError

Otherwise (if we don't have a profile on file), we have no choice but to send a request for everything.

            else
                serverRequest "POST", Store.auth.origin + "/api/v1/accounts/" + id + (if relationship & Profile.FOLLOWING or relationship & Profile.REQUESTED then "/follow" else "/unfollow"), null, Store.auth.accessToken, onComplete, onError
                serverRequest "POST", Store.auth.origin + "/api/v1/accounts/" + id + (if relationship & Profile.BLOCKING then "/block" else "/unblock"), null, Store.auth.accessToken, onComplete, onError
                serverRequest "POST", Store.auth.origin + "/api/v1/accounts/" + id + (if relationship & Profile.MUTING then "/mute" else "/unmute"), null, Store.auth.accessToken, onComplete, onError


- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>API/Request.litcoffee</code></p>

#  REQUEST EVENTS  #

 - - -

##  Introduction  ##

The __Request__ module of the Laboratory API is comprised of those events which are related to Laboratory's various `XMLHttpRequest`s.
Generally speaking you shouldn't have to interact with these events yourself, but they provide an interface for logging which events Laboratory currently has open.

###  Quick reference:

| Event | Description |
| :---- | :---------- |
| `LaboratoryRequestOpen` | Fires when an XMLHttpRequest is opened |
| `LaboratoryRequestUpdate` | Fires when an XMLHttpRequest is updated |
| `LaboratoryRequestComplete` | Fires when an XMLHttpRequest is done loading |
| `LaboratoryRequestError` | Fires when an XMLHttpRequest fails |

###  Listening for requests:

>   - __API equivalent :__ _None_
>   - __Miscellanous events :__
>       - `LaboratoryRequestOpen`
>       - `LaboratoryRequestUpdate`
>       - `LaboratoryRequestComplete`
>       - `LaboratoryRequestError`

Laboratory Request events fire whenever the `readystate` of an `XMLHttpRequest` changes.
`LaboratoryRequestComplete` signifies that the request was successful; that is, it had an HTTP status code in the range `200`–`205` and its response could be parsed.
Alternatively, `LaboratoryRequestError` indicates that the request completed but one or both of those conditions was not true.

The `detail` of each Laboratory Request event is the associated `XMLHttpRequest`.

 - - -

##  Implementation  ##

###  Creating the events:

Here we create the events as per our specifications.

    LaboratoryEvent
        .create "LaboratoryRequestOpen", XMLHttpRequest
        .create "LaboratoryRequestUpdate", XMLHttpRequest
        .create "LaboratoryRequestComplete", XMLHttpRequest
        .create "LaboratoryRequestError", XMLHttpRequest

###  Handling the events:

Laboratory Request events do not have handlers.


- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>API/Rolodex.litcoffee</code></p>

#  ROLODEX EVENTS  #

 - - -

##  Description  ##

The __Rolodex__ module of the Laboratory API is comprised of those events which are related to rolodexes of Mastodon accounts.

>   __[Issue #15](https://github.com/marrus-sh/laboratory/issues/15) :__
>   This module of the Laboratory API may change radically, or be removed, in the future.

###  Quick reference:

| Event | Description |
| :---- | :---------- |
| `LaboratoryRolodexRequested` | Requests a `Rolodex` for a specified query |
| `LaboratoryRolodexReceived` | Fires when a `Rolodex` has been processed |
| `LaboratoryRolodexFailed` | Fires when a `Rolodex` fails to process |

###  Requesting a rolodex:

>   - __API equivalent :__ `/api/v1/accounts/search`, `/api/v1/accounts/:id/followers`, `/api/v1/accounts/:id/following`, `/api/v1/statuses/:id/reblogged_by`, `/api/v1/statuses/:id/favourited_by`, `/api/v1/blocks`, `/api/v1/mutes`
>   - __Request parameters :__
>       - __`type` :__ The [`Laboratory.Rolodex.Type`](../Constructors/Rolodex.litcoffee) of the `Rolodex`
>       - __`query` :__ The associated query
>       - __`before` :__ The id at which to end the rolodex
>       - __`after` :__ The id at which to begin the rolodex
>       - __`limit` :__ The number of accounts to show (for searches only)
>   - __Request :__ `LaboratoryRolodexRequested`
>   - __Response :__ `LaboratoryRolodexReceived`
>   - __Failure :__ `LaboratoryRolodexFailed`

Laboratory Rolodex events are used to request lists of [`Profile`](../Constructors/Profile.litcoffee)s according to the specified `type` and `query`.
If the `type` is `Rolodex.Type.SEARCH`, then `query` should provide the string to search for; otherwise, `query` should be the id of the relevant account or status.
In the case of `Rolodex.Type.BLOCKS` and `Rolodex.Type.MUTES`, no `query` is required.

For `Rolodex.Type.SEARCH`es, the number of accounts to return can be specified using the `limit` parameter; otherwise, the `before` and `after` parameters can be used to change the range of accounts returned.

 - - -

##  Implementation  ##

###  Creating the events:

Here we create the events as per our specifications.

    LaboratoryEvent
        .create "LaboratoryRolodexRequested",
            type: Rolodex.Type.SEARCH
            query: ""
            before: undefined
            after: undefined
            limit: undefined
        .create "LaboratoryRolodexReceived", Rolodex
        .create "LaboratoryRolodexFailed", Failure
        .associate "LaboratoryRolodexRequested", "LaboratoryRolodexReceived", "LaboratoryRolodexFailed"

###  Handling the events:

Laboratory provides handlers for the following Authorization events:

- `LaboratoryRolodexRequested`

####  `LaboratoryRolodexRequested`.

The `LaboratoryRolodexRequested` event requests an account from the Mastodon API, processes it, and fires a `LaboratoryRolodexReceived` event with the resultant `Rolodex`.

        .handle "LaboratoryRolodexRequested", (event) ->

            query = String event.detail.query
            limit = null unless isFinite limit = Number event.detail.limit
            before = null unless isFinite before = Number event.detail.before
            after = null unless isFinite after = Number event.detail.after
            unless (type = event.detail.type) instanceof Rolodex.Type and type isnt Rolodex.Type.UNDEFINED
                dispatch "LaboratoryRolodexFailed", new Failure "Unable to fetch rolodex; no type specified", "LaboratoryRolodexRequested"
                return

When our list of accounts is received, we'll process it and call a `LaboratoryRolodexReceived` event with the resulting `Rolodex`.
We'll also dispatch a `LaboratoryProfileReceived` event with each profile contained in the response.

>   __[Issue #27](https://github.com/marrus-sh/laboratory/issues/27) :__
>   This event should instead be dispatched from the `Rolodex` constructor.

            onComplete = (response, data, params) ->
                ids = []
                dispatch "LaboratoryProfileReceived", account for account in response when (ids.indexOf account.id) is -1 and ids.push account.id
                dispatch "LaboratoryRolodexReceived", new Rolodex response,
                    type: type
                    query: query
                    before: ((params.prev.match /.*since_id=([0-9]+)/) or [])[1]
                    after: ((params.next.match /.*max_id=([0-9]+)/) or [])[1]

If something goes wrong, then we need to throw an error.

            onError = (response, data, params) -> dispatch "LaboratoryRolodexFailed", new Failure response.error, "LaboratoryRolodexRequested", params.status

Finally, we can make our server request.
Note that `serverRequest` ignores data parameters which have a value of `undefined` or `null`.

            serverRequest "GET", Store.auth.origin + (
                switch type
                    when Rolodex.Type.SEARCH then "/api/v1/accounts/search"
                    when Rolodex.Type.FOLLOWERS then "/api/v1/accounts/" + query + "/followers"
                    when Rolodex.Type.FOLLOWING then "/api/v1/accounts/" + query + "/following"
                    when Rolodex.Type.FAVOURITED_BY then "/api/v1/statuses/" + query + "/favourited_by"
                    when Rolodex.Type.REBLOGGED_BY then "/api/v1/statuses/" + query + "/reblogged_by"
                    when Rolodex.Type.BLOCKS then "/api/v1/blocks"
                    when Rolodex.Type.MUTES then "/api/v1/mutes"
                    else "/api/v1"
            ), (
                switch type
                    when Rolodex.Type.SEARCH
                        q: query
                        limit: limit
                    when Rolodex.Type.FOLLOWERS, Rolodex.Type.FOLLOWING, Rolodex.Type.FAVOURITED_BY, Rolodex.Type.REBLOGGED_BY, Rolodex.Type.BLOCKS, Rolodes.Type.MUTES
                        max_id: before
                        since_id: after
                    else null
            ), Store.auth.accessToken, onComplete, onError


- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>API/Timeline.litcoffee</code></p>

#  TIMELINE EVENTS  #

 - - -

##  Description  ##

The __Timeline__ module of the Laboratory API is comprised of those events which are related to timelines of Mastodon accounts.

>   __[Issue #15](https://github.com/marrus-sh/laboratory/issues/15) :__
>   This module of the Laboratory API may change radically, or be removed, in the future.

###  Quick reference:

| Event | Description |
| :---- | :---------- |
| `LaboratoryTimelineRequested` | Requests a `Laboratory.Timeline` for a specified query |
| `LaboratoryTimelineReceived` | Fires when a `Laboratory.Timeline` has been processed |
| `LaboratoryTimelineFailed` | Fires when a `Laboratory.Timeline` fails to process |

###  Requesting a timeline:

>   - __API equivalent :__ `/api/v1/timelines/home`, `/api/v1/timelines/public`, `/api/v1/timelines/tag/:hashtag`, `/api/v1/notifications/`, `/api/v1/favourites`
>   - __Request parameters :__
>       - __`type` :__ The [`Laboratory.Timeline.Type`](../Constructors/Timeline.litcoffee) of the `Timeline`
>       - __`query` :__ The associated query
>       - __`before` :__ The id at which to end the timeline
>       - __`after` :__ The id at which to begin the timeline
>   - __Request :__ `LaboratoryTimelineRequested`
>   - __Response :__ `LaboratoryTimelineReceived`
>   - __Failure :__ `LaboratoryTimelineFailed`

Laboratory Timeline events are used to request lists of [`Post`](../Constructors/Post.litcoffee)s according to the specified `type` and `query`.
If the `type` is `Timeline.Type.HASHTAG`, then `query` should provide the hashtag; in the case of `Timeline.Type.ACCOUNT`, then `query` should provide the account id; otherwise, no `query` is required.

The `before` and `after` parameters can be used to change the range of statuses returned.

 - - -

##  Implementation  ##

###  Creating the events:

Here we create the events as per our specifications.

    LaboratoryEvent
        .create "LaboratoryTimelineRequested",
            type: Timeline.Type.HOME
            query: ""
            before: undefined
            after: undefined
        .create "LaboratoryTimelineReceived", Timeline
        .create "LaboratoryTimelineFailed", Failure
        .associate "LaboratoryTimelineRequested", "LaboratoryTimelineReceived", "LaboratoryTimelineFailed"

###  Handling the events:

Laboratory provides handlers for the following Authorization events:

- `LaboratoryTimelineRequested`

####  `LaboratoryTimelineRequested`.

The `LaboratoryTimelineRequested` event requests an account from the Mastodon API, processes it, and fires a `LaboratoryTimelineReceived` event with the resultant `Timeline`.

        .handle "LaboratoryTimelineRequested", (event) ->

            query = String event.detail.query
            before = null unless isFinite before = Number event.detail.before
            after = null unless isFinite after = Number event.detail.after
            unless (type = event.detail.type) instanceof Timeline.Type and type isnt Timeline.Type.UNDEFINED
                dispatch "LaboratoryTimelineFailed", new Failure "Unable to fetch timeline; no type specified", "LaboratoryTimelineRequested"
                return

When our list of accounts is received, we'll process it and call a `LaboratoryTimelineReceived` event with the resulting `Timeline`.
We'll also dispatch a `LaboratoryPostReceived` event with each post contained in the response, and a `LaboratoryProfileReceived` containing the profile data of each post author and mention.

>   __[Issue #27](https://github.com/marrus-sh/laboratory/issues/27) :__
>   These events should instead be dispatched from the `Timeline` constructor.

>   __Note :__
>   In order to prevent duplicates, `LaboratoryPostReceived` only fires for unique ids in the API response.
>   While it is possible for a status to have the same id as a (different) notification, we don't need to worry about this since statuses and notifications are never grouped together by the Mastodon API.

>   __Note :__
>   Note that the account data provided by mentions is not as complete as that which would be in a normal API response.

            onComplete = (response, data, params) ->
                acctIDs = []
                mentions = []
                mentionIDs = []
                ids = []
                for status in response when (ids.indexOf status.id) is -1 and ids.push status.id
                    dispatch "LaboratoryProfileReceived", new Profile status.account if (acctIDs.indexOf status.account.id) is -1 and acctIDs.push status.account.id
                    dispatch "LaboratoryProfileReceived", new Profile status.status.account if status.status?.account? and (acctIDs.indexOf status.status.account.id) is -1 and acctIDs.push status.status.account.id
                    dispatch "LaboratoryProfileReceived", new Profile status.reblog.account if status.reblog?.account? and (acctIDs.indexOf status.reblog.account.id) is -1 and acctIDs.push status.reblog.account.id
                    if status.mentions instanceof Array
                        for account in status.mentions when (mentionIDs.indexOf account.id) is -1
                            mentionIDs.push account.id
                            mentions.push account
                    dispatch "LaboratoryPostReceived", new Post status
                dispatch "LaboratoryProfileReceived", new Profile mention for mention in mentions when (acctIDs.indexOf mention.id) is -1 and not Store.profiles[mention.id]?
                dispatch "LaboratoryTimelineReceived", new Timeline response,
                    type: type
                    query: query
                    before: ((params.prev.match /.*since_id=([0-9]+)/) or [])[1]
                    after: ((params.next.match /.*max_id=([0-9]+)/) or [])[1]

If something goes wrong, then we need to throw an error.

            onError = (response, data, params) -> dispatch "LaboratoryTimelineFailed", new Failure response.error, "LaboratoryTimelineRequested", params.status

Finally, we can make our server request.
Note that `serverRequest` ignores data parameters which have a value of `undefined` or `null`.

            serverRequest "GET", Store.auth.origin + (
                switch type
                    when Timeline.Type.HASHTAG then "/api/v1/timelines/tag/" + query
                    when Timeline.Type.LOCAL then "/api/v1/timelines/public"
                    when Timeline.Type.GLOBAL then "/api/v1/timelines/public"
                    when Timeline.Type.HOME then "/api/v1/timelines/home"
                    when Timeline.Type.NOTIFICATIONS then "/api/v1/notifications"
                    when Timeline.Type.FAVOURITES then "/api/v1/favourites"
                    when Timeline.Type.ACCOUNT then "/api/v1/accounts/" + query + "/statuses"
                    else "/api/v1"
            ), (
                switch type
                    when Timeline.Type.LOCAL
                        local: yes
                        max_id: before
                        since_id: after
                    else
                        max_id: before
                        since_id: after
            ), Store.auth.accessToken, onComplete, onError


- - -

<p align="right"><i>Laboratory</i> <br> Source Code and Documentation <br> API Version: <i>0.4.0</i> <br> <code>INSTALLING.litcoffee</code></p>

#  USING LABORATORY  #

 - - -

##  Description  ##

Laboratory is written in Literate CoffeeScript, designed to compile to a single minified JavaScript file.
This file is available in [`/dist/laboratory.min.js`](../dist/laboratory.min.js).
If for some reason you feel the need to compile Laboratory from source yourself, the [`Cakefile`](../Cakefile) can be used to do so.

All of Laboratory's components are available through the `window.Laboratory` object, which this file provides.
Additionally, the `window.Laboratory.ready` property can be used to check if `LaboratoryInitializationReady` has already fired, and the `window.Laboratory.auth` property can be used to obtain the current [`Authorization`](Constructors/Authorization.litcoffee) object.
Laboratory doesn't have any external dependencies, and should run in any modern (ECMAScript 5–compliant; eg IE9) browser.

 - - -

##  Implementation  ##

This script loads and runs the Laboratory engine.
Consequently, it is the last thing we load.

###  The Store:

Laboratory data is all stored in a single `Store`, and then acted upon through events and event listeners.
The store is not exposed to the window.

    Store =
        auth: null
        notifications: {}
        profiles: {}
        statuses: {}

Because Laboratory is still in active development, `window["🏪"]` can be used to gain convenient access to our store.
Obviously, you shouldn't expect this to last.

>   __Note :__
>   It's an emoji because you're not supposed to use it in production code.
>   Don't use it in production code lol.

    window["🏪"] = Store

###  Loading Laboratory:

We now make our `Laboratory` object available to the window.

    Object.defineProperty window, "Laboratory",
        value: Object.freeze Laboratory
        enumerable: yes

Now that the `Laboratory` object is available to the `window`, we can fire our `LaboratoryInitializationLoaded` event.

    dispatch "LaboratoryInitializationLoaded"

###  Running Laboratory:

The `run()` function runs Laboratory once the document has finished loaded.

    run = ->

####  Adding our listeners.

Our first task is to initialize our event handlers.
It's pretty easy; we just enumerate over `LaboratoryEvent.Handlers`.

        listen handler.type, handler for handler in LaboratoryEvent.Handlers

####  Starting operations.

Finally, we fire our `LaboratoryInitializationReady` event, signalling that our handlers are ready to go.
We also set `Exposed.ready` to `true` so that scripts can tell Laboratory is running after-the fact.

        Exposed.ready = yes
        dispatch "LaboratoryInitializationReady"

####  Running asynchronously.

We don't want the store loading before `document.body` or any of our other scripts, so we'll attach a `window.onload` event handler if our window isn't currently loaded.
(If it is, then we'll just call `run` right now.)

    if document.readyState is "complete" then run() else window.addEventListener "load", run
