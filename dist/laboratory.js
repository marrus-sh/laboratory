// Generated by CoffeeScript 1.12.4
(function() {
  "use strict";

  /*
  
      ............. LABORATORY ..............
  
      A client-side API for Mastodon, a free,
         open-source social network server
                - - by Kibigo! - -
  
          Licensed under the MIT License.
             Source code available at:
      https://github.com/marrus-sh/laboratory
  
                  Version 0.4.0
   */
  var Application, Attachment, Authorization, Client, CustomEvent, Enumeral, Exposed, Failure, Laboratory, LaboratoryEvent, LaboratoryEventTarget, Post, Profile, Request, Rolodex, Store, Timeline, checkDecree, decree, dispatch, finishRequest, fn, getToken, makeRequest, police, prop, reset, run, startRequest, stopRequest,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Laboratory = {
    ℹ: "https://github.com/marrus-sh/laboratory",
    Nº: 4.0
  };

  (function() {
    var Mommy, code;
    if ((code = (location.search.match(/code=([^&]*)/) || [])[1]) && (Mommy = window.opener)) {
      return Mommy.postMessage(code, window.location.origin);
    }
  })();

  Exposed = {
    ready: false,
    auth: null
  };

  fn = function(prop) {
    return Object.defineProperty(Laboratory, prop, {
      enumerable: true,
      configurable: false,
      get: function() {
        return Exposed[prop];
      }
    });
  };
  for (prop in Exposed) {
    fn(prop);
  }

  decree = police = checkDecree = null;

  (function() {
    var isPrivileged;
    isPrivileged = false;
    decree = function(callback) {
      var result, wasPrivileged;
      wasPrivileged = isPrivileged;
      isPrivileged = true;
      result = callback();
      isPrivileged = wasPrivileged;
      return result;
    };
    police = function(callback) {
      var initial, result;
      initial = isPrivileged;
      isPrivileged = false;
      result = callback();
      isPrivileged = wasPrivileged;
      return result;
    };
    return checkDecree = function() {
      return isPrivileged;
    };
  })();

  CustomEvent = (function() {
    var CE;
    if (typeof window.CustomEvent === "function") {
      return window.CustomEvent;
    }
    CE = function(event, params) {
      var e;
      params = params || {
        bubbles: false,
        cancelable: false,
        detail: void 0
      };
      e = document.createEvent("CustomEvent");
      e.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return e;
    };
    CE.prototype = Object.freeze(Object.create(window.Event.prototype));
    return Object.freeze(CE);
  })();

  LaboratoryEventTarget = (function() {
    var LabEvtTgt, fragment, ref;
    fragment = document.createDocumentFragment();
    LabEvtTgt = function() {
      this.addEventListener = fragment.addEventListener.bind(this);
      this.removeEventListener = fragment.removeEventListener.bind(this);
      return this.dispatchEvent = fragment.dispatchEvent.bind(this);
    };
    LabEvtTgt.prototype = Object.freeze(Object.create((((ref = window.EventTarget) != null ? ref.prototype : void 0) ? window.EventTarget.prototype : window.Object.prototype)));
    return Object.freeze(LabEvtTgt);
  })();

  Enumeral = function(value) {
    if (!(this && this instanceof Enumeral)) {
      throw new TypeError("this is not a Enumeral");
    }
    this.value = value | 0;
    return Object.freeze(this);
  };

  Laboratory.Enumeral = function(value) {
    throw new TypeError("Illegal constructor");
  };

  Object.defineProperty(Enumeral, "prototype", {
    configurable: false,
    enumerable: false,
    writable: false,
    value: Object.freeze(Object.defineProperties({}, {
      constructor: {
        enumerable: false,
        value: Laboratory.Enumeral
      },
      toString: {
        enumerable: false,
        value: function() {
          return "Enumeral(" + this.value + ")";
        }
      },
      toSource: {
        enumerable: false,
        value: function() {
          return "Enumeral(" + this.value + ")";
        }
      },
      valueOf: {
        enumerable: false,
        value: function() {
          return this.value;
        }
      }
    }))
  });

  Object.defineProperty(Laboratory.Enumeral, "prototype", {
    configurable: false,
    enumerable: false,
    writable: false,
    value: Enumeral.prototype
  });

  Enumeral.generate = function(data) {
    var byValue, enumeral, type, value;
    type = function(n) {
      return Enumeral.call(this, n);
    };
    type.prototype = Object.create(Enumeral.prototype);
    byValue = {};
    for (enumeral in data) {
      if (!hasProp.call(data, enumeral)) continue;
      value = data[enumeral];
      if (byValue[value] != null) {
        continue;
      }
      type[enumeral] = new type(value);
      byValue[value] = type[enumeral];
    }
    type.fromValue = function(n) {
      return byValue[n | 0];
    };
    return Object.freeze(type);
  };

  Laboratory.Application = Application = function(data) {
    if (!(this && this instanceof Application)) {
      throw new TypeError("this is not an Application");
    }
    if (data == null) {
      throw new TypeError("Unable to create Application; no data provided");
    }
    this.name = data.name;
    this.href = data.website;
    return Object.freeze(this);
  };

  Object.defineProperty(Application, "prototype", {
    value: Object.freeze({})
  });

  Laboratory.Attachment = Attachment = function(data) {
    if (!(this && this instanceof Attachment)) {
      throw new TypeError("this is not an Attachment");
    }
    if (data == null) {
      throw new TypeError("Unable to create Attachment; no data provided");
    }
    this.id = Number(data.id);
    this.href = String(data.url);
    this.preview = String(data.preview_url);
    this.type = (function() {
      switch (data.type) {
        case "image":
          return Attachment.Type.IMAGE;
        case "video":
          return Attachment.Type.VIDEO;
        case "gifv":
          return Attachment.Type.GIFV;
        default:
          return Attachment.Type.UNKNOWN;
      }
    })();
    return Object.freeze(this);
  };

  Object.defineProperty(Attachment, "prototype", {
    value: Object.freeze({})
  });

  Attachment.Type = Enumeral.generate({
    UNKNOWN: 0x0,
    PHOTO: 0x1,
    VIDEO: 0x2,
    GIFV: 0x3
  });

  Laboratory.Authorization = Authorization = function(data, origin, me) {
    var scopes;
    if (!(this && this instanceof Authorization)) {
      throw new TypeError("this is not an Authorization");
    }
    if (data == null) {
      throw new TypeError("Unable to create Authorization; no data provided");
    }
    this.origin = String(origin);
    this.accessToken = String(data.access_token);
    this.datetime = new Date(data.created_at);
    this.scope = Authorization.Scope.fromValue(Authorization.Scope.READ * (indexOf.call((scopes = (String(data.scope)).split(/[\s\+]+/g)), "read") < 0) + Authorization.Scope.WRITE * (indexOf.call(scopes, "write") < 0) + Authorization.Scope.FOLLOW * (indexOf.call(scopes, "follow") < 0));
    this.tokenType = String(data.tokenType);
    this.me = +me;
    return Object.freeze(this);
  };

  Object.defineProperty(Authorization, "prototype", {
    value: Object.freeze({})
  });

  Authorization.Scope = Enumeral.generate({
    NONE: 0x0,
    READ: 0x1,
    WRITE: 0x2,
    READWRITE: 0x3,
    FOLLOW: 0x4,
    READFOLLOW: 0x5,
    WRITEFOLLOW: 0x6,
    READWRITEFOLLOW: 0x7
  });

  Laboratory.Client = Client = function(data, origin, name, scope) {
    if (!(this && this instanceof Client)) {
      throw new TypeError("this is not a Client");
    }
    if (data == null) {
      throw new TypeError("Unable to create Client; no data provided");
    }
    this.origin = origin;
    this.name = name;
    this.id = data.id;
    this.clientID = data.client_id;
    this.clientSecret = data.client_secret;
    this.scope = scope;
    this.redirect = data.redirect_uri;
    return Object.freeze(this);
  };

  Object.defineProperty(Client, "prototype", {
    value: Object.freeze({})
  });

  Laboratory.Failure = Failure = function(data, request, code) {
    if (!(this && this instanceof Failure)) {
      throw new TypeError("this is not a Failure");
    }
    if (data == null) {
      throw new TypeError("Unable to create Failure; no data provided");
    }
    this.request = String(request);
    this.error = String(data.error);
    if (!isFinite(this.code = Number(code))) {
      this.code = null;
    }
    return Object.freeze(this);
  };

  Object.defineProperty(Failure, "prototype", {
    value: Object.freeze({})
  });

  Laboratory.Post = Post = function(data) {
    var fromID, getProfile, item, profiles;
    if (!(this && this instanceof Post)) {
      throw new TypeError("this is not a Post");
    }
    if (data == null) {
      throw new TypeError("Unable to create Post; no data provided");
    }
    profiles = Store.profiles;
    getProfile = function(id) {
      return profiles[id];
    };
    if (data.type != null) {
      this.id = data.id;
      fromID = data.account.id;
      if (data.status) {
        switch (data.type) {
          case "reblog":
            this.type = Post.Type.REBLOG;
            Object.defineProperty(this, "rebloggedBy", {
              get: getProfile.bind(this, fromID),
              enumerable: true
            });
            break;
          case "favourite":
            this.type = Post.Type.FAVOURITE;
            Object.defineProperty(this, "favouritedBy", {
              get: getProfile.bind(this, fromID),
              enumerable: true
            });
            break;
          case "mention":
            this.type = Post.Type.MENTION;
            break;
          default:
            this.type = Post.Type.REACTION;
        }
        data = data.status;
      } else {
        Object.defineProperty(this, "author", {
          get: getProfile.bind(this, fromID),
          enumerable: true
        });
        switch (data.type) {
          case "follow":
            this.type = Post.Type.FOLLOW;
            break;
          default:
            this.type = Post.Type.NOTIFICATION;
        }
        return Object.freeze(this);
      }
    } else {
      this.type = Post.Type.STATUS;
      this.id = data.id;
      if (data.reblog) {
        Object.defineProperty(this, "rebloggedBy", {
          get: getProfile.bind(this, data.account.id),
          enumerable: true
        });
        data = data.reblog;
      }
    }
    this.uri = String(data.uri);
    this.href = String(data.url);
    Object.defineProperty(this, "author", {
      get: getProfile.bind(this, data.account.id),
      enumerable: true
    });
    this.inReplyTo = Number(data.in_reply_to_id);
    this.content = String(data.content);
    this.datetime = new Date(data.created_at);
    this.reblogCount = Number(data.reblogs_count);
    this.favouriteCount = Number(data.favourites_count);
    this.isReblogged = !!data.reblogged;
    this.isFavourited = !!data.favourited;
    this.isNSFW = !!data.sensitive;
    this.message = String(data.spoiler_text);
    this.visibility = {
      "private": Post.Visibility.PRIVATE,
      unlisted: Post.Visibility.REBLOGGABLE,
      "public": Post.Visibility.PUBLIC
    }[data.visibility] || Post.Visibility.PRIVATE;
    this.mediaAttachments = (function() {
      var i, len, ref, results;
      ref = data.media_attachments;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        results.push(new Attachment(item));
      }
      return results;
    })();
    this.mentions = (function(_this) {
      return function() {
        var i, index, len, mention, mentions, ref;
        mentions = [];
        ref = data.mentions;
        for (index = i = 0, len = ref.length; i < len; index = ++i) {
          mention = ref[index];
          Object.defineProperty(mentions, index, {
            enumerable: true,
            get: getProfile.bind(_this, mention.id)
          });
        }
        return Object.freeze(mentions);
      };
    })(this)();
    this.application = data.application != null ? new Application(data.application) : null;
    return Object.freeze(this);
  };

  Object.defineProperty(Post, "prototype", {
    value: Object.freeze({
      compare: function(other) {
        if (!(this instanceof Post && other instanceof Post)) {
          return false;
        }
        return this.type === other.type && this.id === other.id && this.reblogCount === other.reblogCount && this.favouriteCount === other.favouriteCount && this.isReblogged === other.isReblogged && this.isFavourited === other.isFavourited;
      }
    })
  });

  Post.Type = Enumeral.generate({
    UNKNOWN: 0x00,
    STATUS: 0x10,
    NOTIFICATION: 0x20,
    FOLLOW: 0x21,
    REACTION: 0x30,
    FAVOURITE: 0x31,
    REBLOG: 0x32,
    MENTION: 0x33
  });

  Post.Visibility = Enumeral.generate({
    PRIVATE: 0x00,
    REBLOGGABLE: 0x01,
    LISTED: 0x02,
    PUBLIC: 0x03
  });

  Laboratory.Profile = Profile = function(data, relationship) {
    var origin, ref;
    if (!(this && this instanceof Profile)) {
      throw new TypeError("this is not a Profile");
    }
    if (data == null) {
      throw new TypeError("Unable to create Profile; no data provided");
    }
    if (relationship == null) {
      relationship = (ref = Store.profiles[data.id]) != null ? ref.relationship : void 0;
    }
    if (data instanceof Profile) {
      this.id = data.id, this.username = data.username, this.account = data.account, this.localAccount = data.localAccount, this.displayName = data.displayName, this.bio = data.bio, this.href = data.href, this.avatar = data.avatar, this.header = data.header, this.isLocked = data.isLocked, this.followerCount = data.followerCount, this.followingCount = data.followingCount, this.statusCount = data.statusCount, this.relationship = data.relationship;
    } else {
      this.id = Number(data.id);
      this.username = String(data.username);
      this.account = String(data.acct + (((origin = Store.auth.origin) != null) && indexOf.call(data.acct, "@") < 0 ? "@" + origin : ""));
      this.localAccount = String(data.acct);
      this.displayName = String(data.display_name);
      this.bio = String(data.note);
      this.href = String(data.url);
      this.avatar = String(data.avatar);
      this.header = String(data.header);
      this.isLocked = !!data.locked;
      this.followerCount = Number(data.followers_count);
      this.followingCount = Number(data.following_count);
      this.statusCount = Number(data.statuses_count);
      this.relationship = data.id === Store.auth.me ? Profile.Relationship.SELF : Profile.Relationship.UNKNOWN;
    }
    if (relationship != null) {
      this.relationship = Profile.Relationship.fromValue(relationship) || this.relationship;
    }
    return Object.freeze(this);
  };

  Object.defineProperty(Profile, "prototype", {
    value: Object.freeze({
      compare: function(other) {
        if (!(this instanceof Profile && other instanceof Profile)) {
          return false;
        }
        return this.id === other.id && this.relationship === other.relationship && this.followerCount === other.followerCount && this.followingCount === other.followingCount && this.statusCount === other.statusCount && this.bio === other.bio && this.displayName === other.displayName && this.avatar === other.avatar && this.header === other.header && this.isLocked === other.isLocked && this.username === other.username && this.localAccount === other.localAccount && this.account === other.account && this.href === other.href;
      }
    })
  });

  Profile.Relationship = Enumeral.generate({
    NOT_FOLLOWING: 0x0,
    FOLLOWER: 0x1,
    FOLLOWING: 0x2,
    MUTUAL: 0x3,
    REQUESTED: 0x4,
    REQUESTED_MUTUAL: 0x5,
    BLOCKING: 0x8,
    MUTING: 0x10,
    MUTING_FOLLOWER: 0x11,
    MUTING_FOLLOWING: 0x12,
    MUTING_MUTUAL: 0x13,
    MUTING_REQUESTED: 0x14,
    MUTING_REQUESTED_MUTUAL: 0x15,
    UNKNOWN: 0x40,
    SELF: 0x80
  });

  Request = function(method, location, data, token, onComplete) {
    var callback, contents, key, request, response, subvalue, value;
    if (!(this && this instanceof Request)) {
      throw new TypeError("this is not a Request");
    }
    response = null;
    Object.defineProperty(this, "response", {
      configurable: true,
      enumerable: true,
      get: function() {
        return response;
      },
      set: function(n) {
        if (checkDecree()) {
          return police((function(_this) {
            return function() {
              response = n;
              return _this.dispatchEvent(new CustomEvent("response", {
                request: _this,
                response: n
              }));
            };
          })(this));
        }
      }
    });
    if (!(method === "GET" || method === "POST" || method === "DELETE")) {
      return this;
    }
    location = String(location);
    data = Object(data);
    request = new XMLHttpRequest;
    contents = method === "POST" && typeof FormData === "function" && data instanceof FormData ? data : (((function() {
      var results;
      results = [];
      for (key in data) {
        value = data[key];
        if (value != null) {
          if (value instanceof Array) {
            results.push(((function() {
              var i, len, results1;
              results1 = [];
              for (i = 0, len = value.length; i < len; i++) {
                subvalue = value[i];
                results1.push((encodeURIComponent(key)) + "[]=" + encodeURIComponent(subvalue));
              }
              return results1;
            })()).join("&"));
          } else {
            results.push((encodeURIComponent(key)) + "=" + encodeURIComponent(value));
          }
        }
      }
      return results;
    })()).join("&")).replace(/%20/g, '+');
    if (!(contents === "" || method === "POST")) {
      location += ((location.indexOf("?")) !== -1 ? "&" : "?") + contents;
    }
    callback = (function(_this) {
      return function() {
        var link, params, status;
        switch (request.readyState) {
          case 0:
            break;
          case 1:
            return dispatch("LaboratoryRequestOpen", request);
          case 2:
          case 3:
            return dispatch("LaboratoryRequestUpdate", request);
          case 4:
            status = request.status;
            data = (function() {
              try {
                if (request.responseText) {
                  return JSON.parse(request.responseText);
                } else {
                  return null;
                }
              } catch (error) {
                return {
                  error: "The response could not be parsed."
                };
              }
            })();
            link = request.getResponseHeader("Link");
            params = {
              status: status,
              url: location,
              prev: ((link != null ? link.match(/<\s*([^,]*)\s*>\s*;(?:[^,]*[;\s])?rel="?prev(?:ious)?"?/) : void 0) || [])[1],
              next: ((link != null ? link.match(/<\s*([^,]*)\s*>\s*;(?:[^,]*[;\s])?rel="?next"?/) : void 0) || [])[1]
            };
            switch (false) {
              case !((200 <= status && status <= 205)):
                if ((data != null ? data.error : void 0) != null) {
                  _this.dispatchEvent(new CustomEvent("failure", {
                    request: _this,
                    response: new Failure(data.error, status)
                  }));
                  dispatch("LaboratoryRequestError", request);
                } else {
                  if (typeof onComplete === "function") {
                    onComplete(data, params);
                  }
                  dispatch("LaboratoryRequestComplete", request);
                }
                break;
              default:
                _this.dispatchEvent(new CustomEvent("failure", {
                  request: _this,
                  response: new Failure(data != null ? data.error : void 0, status)
                }));
                dispatch("LaboratoryRequestError", request);
            }
            return request.removeEventListener("readystatechange", callback);
        }
      };
    })(this);
    Object.defineProperties(this, {
      start: {
        configurable: true,
        enumerable: false,
        writable: false,
        value: function() {
          request.open(method, location);
          if (method === "POST" && !((typeof FormData !== "undefined" && FormData !== null) && contents instanceof FormData)) {
            request.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
          }
          if (token != null) {
            request.setRequestHeader("Authorization", "Bearer " + token);
          }
          request.addEventListener("readystatechange", callback);
          request.send(method === "POST" ? contents : void 0)();
        }
      },
      stop: {
        configurable: true,
        enumerable: false,
        writable: false,
        value: function() {
          request.removeEventListener("readystatechange", callback);
          request.abort();
        }
      }
    });
    return this;
  };

  Laboratory.Request = function(data) {
    throw new TypeError("Illegal constructor");
  };

  Object.defineProperty(Request, "prototype", {
    configurable: false,
    enumerable: false,
    writable: false,
    value: Object.freeze(Object.create(LaboratoryEventTarget.prototype, {
      constructor: {
        enumerable: false,
        value: Laboratory.Request
      },
      start: {
        enumerable: false,
        value: function() {}
      },
      stop: {
        enumerable: false,
        value: function() {}
      }
    }))
  });

  Object.defineProperty(Laboratory.Request, "prototype", {
    configurable: false,
    enumerable: false,
    writable: false,
    value: Request.prototype
  });

  Laboratory.Rolodex = Rolodex = function(data) {
    var current, currentID, getProfile, i, index, j, len, prev, ref, value;
    if (!(this && this instanceof Rolodex)) {
      throw new TypeError("this is not a Rolodex");
    }
    if (data == null) {
      throw new TypeError("Unable to create Rolodex; no data provided");
    }
    getProfile = function(id) {
      return Store.profiles[id];
    };
    data.sort(function(first, second) {
      return second.id - first.id;
    });
    prev = null;
    for (index = i = ref = data.length - 1; ref <= 0 ? i <= 0 : i >= 0; index = ref <= 0 ? ++i : --i) {
      currentID = (current = data[index]).id;
      if ((prev != null) && currentID === prev.id) {
        data.splice(index, 1);
        continue;
      }
      prev = current;
    }
    this.profiles = [];
    for (index = j = 0, len = data.length; j < len; index = ++j) {
      value = data[index];
      Object.defineProperty(this.profiles, index, {
        enumerable: true,
        get: getProfile.bind(this, value.id)
      });
    }
    Object.freeze(this.profiles);
    this.length = data.length;
    return Object.freeze(this);
  };

  Object.defineProperty(Rolodex, "prototype", {
    value: Object.freeze({
      join: function(data) {
        var combined, i, j, len, len1, profile, ref, ref1;
        if (!(data instanceof Profile || data instanceof Array || data instanceof Rolodex)) {
          return this;
        }
        ref = (function() {
          switch (false) {
            case !(data instanceof Profile):
              return [data];
            case !(data instanceof Rolodex):
              return data.profiles;
            default:
              return data;
          }
        })();
        for (i = 0, len = ref.length; i < len; i++) {
          profile = ref[i];
          combined = profile;
        }
        ref1 = this.profiles;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          profile = ref1[j];
          combined.push(profile);
        }
        return new Rolodex(combined);
      },
      remove: function(data) {
        var i, index, len, profile, redacted, ref;
        if (!(data instanceof Profile || data instanceof Array || data instanceof Rolodex)) {
          return this;
        }
        redacted = (function() {
          var i, len, ref, results;
          ref = this.profiles;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            profile = ref[i];
            results.push(profile);
          }
          return results;
        }).call(this);
        ref = ((function() {
          switch (false) {
            case !(data instanceof Profile):
              return [data];
            case !(data instanceof Rolodex):
              return data.profiles;
            default:
              return data;
          }
        })());
        for (i = 0, len = ref.length; i < len; i++) {
          profile = ref[i];
          if ((index = redacted.indexOf(profile)) !== -1) {
            redacted.splice(index, 1);
          }
        }
        return new Rolodex(redacted);
      }
    })
  });

  Rolodex.Type = Enumeral.generate({
    UNDEFINED: 0x00,
    SEARCH: 0x10,
    FOLLOWERS: 0x21,
    FOLLOWING: 0x22,
    FAVOURITED_BY: 0x41,
    REBLOGGED_BY: 0x45,
    BLOCKS: 0x83,
    MUTES: 0x84,
    FOLLOW_REQUESTS: 0x86
  });

  Laboratory.Timeline = Timeline = function(data) {
    var current, currentID, getPost, i, index, isNotification, j, len, prev, ref, value;
    if (!(this && this instanceof Timeline)) {
      throw new TypeError("this is not a Timeline");
    }
    if (data == null) {
      throw new TypeError("Unable to create Timeline; no data provided");
    }
    isNotification = function(object) {
      return !!(((function() {
        switch (false) {
          case !(object instanceof Post):
            return object.type;
          case object.type == null:
            return Post.Type.NOTIFICATION;
          default:
            return Post.Type.STATUS;
        }
      })()) & Post.Type.NOTIFICATION);
    };
    getPost = function(id, isANotification) {
      if (isANotification) {
        return Store.notifications[id];
      } else {
        return Store.statuses[id];
      }
    };
    data.sort(function(first, second) {
      var a, b;
      if (!(isNotification(first)) && !(isNotification(second)) && (a = Number(first instanceof Post && first.datetime || Date(first.created_at))) !== (b = Number(second instanceof Post && second.datetime || Date(second.created_at)))) {
        return -1 + 2 * (a > b);
      } else {
        return second.id - first.id;
      }
    });
    prev = null;
    for (index = i = ref = data.length - 1; ref <= 0 ? i <= 0 : i >= 0; index = ref <= 0 ? ++i : --i) {
      currentID = (current = data[index]).id;
      if ((prev != null) && currentID === prev.id && (isNotification(prev)) === (isNotification(current))) {
        data.splice(index, 1);
        continue;
      }
      prev = current;
    }
    this.posts = [];
    for (index = j = 0, len = data.length; j < len; index = ++j) {
      value = data[index];
      Object.defineProperty(this.posts, index, {
        enumerable: true,
        get: getPost.bind(this, value.id, isNotification(value))
      });
    }
    Object.freeze(this.posts);
    this.length = data.length;
    return Object.freeze(this);
  };

  Object.defineProperty(Timeline, "prototype", {
    value: Object.freeze({
      join: function(data) {
        var combined, i, j, len, len1, post, ref, ref1;
        if (!(data instanceof Post || data instanceof Array || data instanceof Timeline)) {
          return this;
        }
        ref = (function() {
          switch (false) {
            case !(data instanceof Post):
              return [data];
            case !(data instanceof Timeline):
              return data.posts;
            default:
              return data;
          }
        })();
        for (i = 0, len = ref.length; i < len; i++) {
          post = ref[i];
          combined = post;
        }
        ref1 = this.posts;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          post = ref1[j];
          combined.push(post);
        }
        return new Timeline(combined);
      },
      remove: function(data) {
        var i, index, len, post, redacted, ref;
        if (!(data instanceof Post || data instanceof Array || data instanceof Timeline)) {
          return this;
        }
        redacted = (function() {
          var i, len, ref, results;
          ref = this.posts;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            post = ref[i];
            results.push(post);
          }
          return results;
        }).call(this);
        ref = ((function() {
          switch (false) {
            case !(data instanceof Post):
              return [data];
            case !(data instanceof Timeline):
              return data.posts;
            default:
              return data;
          }
        })());
        for (i = 0, len = ref.length; i < len; i++) {
          post = ref[i];
          if ((index = redacted.indexOf(post)) !== -1) {
            redacted.splice(index, 1);
          }
        }
        return new Timeline(redacted);
      }
    })
  });

  Timeline.Type = Enumeral.generate({
    UNDEFINED: 0x00,
    PUBLIC: 0x10,
    HOME: 0x20,
    NOTIFICATIONS: 0x21,
    FAVOURITES: 0x22,
    ACCOUNT: 0x40,
    HASHTAG: 0x80
  });

  LaboratoryEvent = {
    Events: {},
    Handlers: [],
    create: function(type, detail) {
      if (LaboratoryEvent.Events[type] == null) {
        LaboratoryEvent.Events[type] = Object(detail);
      }
      return LaboratoryEvent;
    },
    handle: function(type, callback) {
      if (LaboratoryEvent.Events[type = String(type)] == null) {
        return LaboratoryEvent;
      }
      callback.type = type;
      LaboratoryEvent.Handlers.push(callback);
      return LaboratoryEvent;
    }
  };

  Laboratory.dispatch = dispatch = function(event, props) {
    var detail, initial, initials;
    if ((initials = LaboratoryEvent.Events[event = String(event)]) == null) {
      return false;
    }
    if (typeof initials === "function") {
      if (!((detail = props) instanceof initials)) {
        return false;
      }
    } else if (props != null) {
      detail = {};
      for (prop in initials) {
        initial = initials[prop];
        detail[prop] = props[prop] != null ? props[prop] : initial;
      }
      Object.freeze(detail);
    }
    document.dispatchEvent(new CustomEvent(event, {
      detail: detail
    }));
    return true;
  };

  Object.defineProperty(Attachment, "Request", {
    configurable: false,
    enumerable: true,
    writable: false,
    value: (function() {
      var AttachmentRequest;
      AttachmentRequest = function(data) {
        var file, form;
        if (!(this && this instanceof AttachmentRequest)) {
          throw new TypeError("this is not an AttachmentRequest");
        }
        if (!(typeof File === "function" && (file = data.file) instanceof File)) {
          throw new TypeError("Unable to create attachment; none provided");
        }
        if (typeof FormData !== "function") {
          throw new TypeError("Unable to create attachment; `FormData` not supported");
        }
        form = new FormData;
        form.append("file", file);
        Request.call(this, "POST", Store.auth.origin + "/api/v1/media", form, Store.auth.accessToken, (function(_this) {
          return function(result) {
            return dispatch("LaboratoryAttachmentReceived", decree(function() {
              return _this.response = police(function() {
                return new Attachment(result);
              });
            }));
          };
        })(this));
        return Object.freeze(this);
      };
      Object.defineProperty(AttachmentRequest, "prototype", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Object.freeze(Object.create(Request.prototype, {
          constructor: {
            enumerable: false,
            value: AttachmentRequest
          }
        }))
      });
      return AttachmentRequest;
    })()
  });

  stopRequest = function() {
    var ref;
    if (!((this != null ? this.currentRequest : void 0) instanceof Authorization.Request)) {
      throw new TypeError("No defined AuthorizationRequest");
    }
    if (typeof this.wrapup === "function") {
      this.wrapup();
    }
    if (typeof ((ref = this.waitingRequest) != null ? ref.stop : void 0) === "function") {
      this.waitingRequest.stop();
    }
    if (this.window instanceof Window) {
      this.window.close();
    }
    this.waitingRequest = this.callback = this.window = void 0;
  };

  startRequest = function(window) {
    var accessToken, handleClient, ref, scopeList, storedAccessToken, storedRedirect, storedScope, timeout;
    if (!((this != null ? this.currentRequest : void 0) instanceof Authorization.Request)) {
      throw new TypeError("No defined AuthorizationRequest");
    }
    this.currentRequest.stop();
    if ((window != null) && !window.closed) {
      this.window = window;
    }
    ref = (typeof localStorage !== "undefined" && localStorage !== null ? localStorage.getItem("Laboratory | " + this.origin) : void 0) ? (localStorage.getItem("Laboratory | " + this.origin)).split(" ", 5) : [], storedRedirect = ref[0], this.clientID = ref[1], this.clientSecret = ref[2], storedScope = ref[3], storedAccessToken = ref[4];
    if ((accessToken = this.accessToken) || (accessToken = storedAccessToken) && (this.scope & storedScope) === +this.scope) {
      finishRequest.call(this, {
        access_token: accessToken,
        created_at: 0/0,
        scope: (scopeList = [], this.scope & Authorization.Scope.READ ? scopeList.push("read") : void 0, this.scope & Authorization.Scope.WRITE ? scopeList.push("write") : void 0, this.scope & Authorization.Scope.FOLLOW ? scopeList.push("follow") : void 0, scopeList.join(" ")),
        token_type: "bearer"
      });
      return;
    }
    if (storedRedirect === this.redirect && (this.scope & storedScope) === +this.scope && this.clientID && this.clientSecret) {
      makeRequest.call(this);
    } else {
      handleClient = (function(_this) {
        return function(event) {
          var client, ref1;
          if (!((client = event.detail.response) instanceof Client && currentRequest && client.origin === _this.origin && (_this.scope & client.scope) === +_this.scope && client.redirect === _this.redirect && client.clientID && client.clientSecret)) {
            return;
          }
          ref1 = [client.clientID, client.clientSecret], _this.clientID = ref1[0], _this.clientSecret = ref1[1];
          localStorage.setItem("Laboratory | " + _this.origin, [client.redirect, client.clientID, client.clientSecret, +client.scope].join(" "));
          clearTimeout(timeout);
          _this.wrapup = void 0;
          _this.waitingRequest.removeEventListener("response", handleClient);
          return makeRequest.call(_this);
        };
      })(this);
      this.waitingRequest = new Client.Request({
        name: recalled.name,
        url: recalled.origin,
        redirect: recalled.redirect,
        scope: recalled.scope
      });
      this.waitingRequest.addEventListener("response", handleClient);
      this.wrapup = (function(_this) {
        return function() {
          return _this.waitingRequest.removeEventListener("response", handleClient);
        };
      })(this);
      this.waitingRequest.start();
      timeout = setTimeout((function() {
        this.currentRequest.stop();
        return this.dispatchEvent(new CustomEvent("failure", {
          request: this,
          response: new Failure("Unable to authorize client")
        }));
      }), 30000);
    }
  };

  makeRequest = function() {
    var callback, key, location, scopeList, value;
    if (!((this != null ? this.currentRequest : void 0) instanceof Authorization.Request)) {
      throw new TypeError("No defined AuthorizationRequest");
    }
    location = this.origin + "/oauth/authorize?" + (((function() {
      var ref, results;
      ref = {
        client_id: this.clientID,
        response_type: "code",
        redirect_uri: this.redirect,
        scope: (scopeList = [], this.scope & Authorization.Scope.READ ? scopeList.push("read") : void 0, this.scope & Authorization.Scope.WRITE ? scopeList.push("write") : void 0, this.scope & Authorization.Scope.FOLLOW ? scopeList.push("follow") : void 0, scopeList.join(" "))
      };
      results = [];
      for (key in ref) {
        value = ref[key];
        results.push((encodeURIComponent(key)) + "=" + (encodeURIComponent(value)));
      }
      return results;
    }).call(this)).join("&"));
    if (this.window) {
      this.window.location = location;
    } else {
      this.window = window.open(location, "LaboratoryOAuth");
    }
    callback = (function(_this) {
      return function(event) {
        if (!(event.source === _this.window && event.origin === window.location.origin)) {
          return;
        }
        getToken.call(_this, event.data);
        event.source.close();
        _this.window = null;
        _this.wrapup = void 0;
        window.removeEventListener("message", callback);
        return callback = void 0;
      };
    })(this);
    window.addEventListener("message", callback);
    return this.wrapup = function() {
      return window.removeEventListener("message", callback);
    };
  };

  getToken = function(code) {
    var ref;
    if (!((this != null ? this.currentRequest : void 0) instanceof Authorization.Request)) {
      throw new TypeError("No defined AuthorizationRequest");
    }
    if (typeof ((ref = this.waitingRequest) != null ? ref.stop : void 0) === "function") {
      this.waitingRequest.stop();
    }
    return (this.waitingRequest = new Request("POST", this.origin + "/oauth/token", {
      client_id: this.clientID,
      client_secret: this.clientSecret,
      redirect_uri: this.redirect,
      grant_type: "authorization_code",
      code: code
    }, null, finishRequest.bind(this))).start();
  };

  finishRequest = function(result) {
    var location, ref;
    if (!((this != null ? this.currentRequest : void 0) instanceof Authorization.Request)) {
      throw new TypeError("No defined AuthorizationRequest");
    }
    if (typeof ((ref = this.waitingRequest) != null ? ref.stop : void 0) === "function") {
      this.waitingRequest.stop();
    }
    location = this.origin + "/api/v1/accounts/verify_credentials";
    this.accessToken = String(result.access_token);
    return (this.waitingRequest = new Request("GET", location, null, this.accessToken, (function(_this) {
      return function(mine) {
        var scopes;
        decree(function() {
          return this.currentRequest.response = police(function() {
            return new Authorization(result, this.origin, mine.id);
          });
        });
        dispatch("LaboratoryAuthorizationReceived", _this.currentRequest.response);
        localStorage.setItem("Laboratory | " + _this.origin, [_this.redirect, _this.clientID, _this.clientSecret, Authorization.Scope.READ * (indexOf.call((scopes = result.scope.split(/[\s\+]+/g)), "read") >= 0) + Authorization.Scope.WRITE * (indexOf.call(scopes, "write") >= 0) + Authorization.Scope.FOLLOW * (indexOf.call(scopes, "follow") >= 0), _this.access_token].join(" "));
        dispatch("LaboratoryProfileReceived", new Profile(mine));
        return _this.currentRequest.stop();
      };
    })(this))).start();
  };

  Object.defineProperty(Authorization, "Request", {
    configurable: false,
    enumerable: true,
    writable: false,
    value: (function() {
      var AuthorizationRequest;
      AuthorizationRequest = function(data) {
        var a, recalled;
        if (!(this && this instanceof AuthorizationRequest)) {
          throw new TypeError("this is not an AuthorizationRequest");
        }
        recalled = {
          currentRequest: this,
          waitingRequest: void 0,
          callback: void 0,
          scope: data.scope instanceof Authorization.Scope ? data.scope : Authorization.Scope.READ,
          name: (String(data.name)) || "Laboratory",
          accessToken: (String(data.accessToken)) || null,
          window: void 0,
          clientID: void 0,
          clientSecret: void 0,
          origin: (a = document.createElement("a"), a.href = data.origin || "/", a.origin),
          redirect: (a.href = data.redirect || "", a.href)
        };
        Request.call(this);
        Object.defineProperties(this, {
          start: {
            enumerable: false,
            value: startRequest.bind(recalled)
          },
          stop: {
            enumerable: false,
            value: stopRequest.bind(recalled)
          }
        });
        return Object.freeze(this);
      };
      Object.defineProperty(AuthorizationRequest, "prototype", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Object.freeze(Object.create(Request.prototype, {
          constructor: {
            enumerable: false,
            value: AuthorizationRequest
          }
        }))
      });
      return AuthorizationRequest;
    })()
  }, LaboratoryEvent.create("LaboratoryAuthorizationReceived", Authorization).handle("LaboratoryAuthorizationReceived", function(event) {
    if (event.detail instanceof Authorization) {
      reset();
      return Exposed.auth = Store.auth = event.detail;
    }
  }));

  Object.defineProperty(Client, "Request", {
    configurable: false,
    enumerable: true,
    writable: false,
    value: (function() {
      var ClientRequest;
      ClientRequest = function(data) {
        var a, name, origin, redirect, scope, scopeList;
        if (!(this && this instanceof ClientRequest)) {
          throw new TypeError("this is not a ClientRequest");
        }
        name = (String(data.name)) || "Laboratory";
        scope = data.scope(instance in Authorization.Scope) ? data.scope : Authorization.Scope.READ;
        a = document.createElement("a");
        a.href = data.origin || "/";
        origin = a.origin;
        a.href = data.redirect || "";
        redirect = a.href;
        Request.call(this, "POST", origin + "/api/v1/apps", {
          client_name: name,
          redirect_uris: redirect,
          scopes: (scope = event.detail.scope, scopeList = [], scope & Authorization.Scope.READ ? scopeList.push("read") : void 0, scope & Authorization.Scope.WRITE ? scopeList.push("write") : void 0, scope & Authorization.Scope.FOLLOW ? scopeList.push("follow") : void 0, scopeList.join(" "))
        }, null, (function(_this) {
          return function(result) {
            return dispatch("LaboratoryClientReceived", decree(function() {
              return _this.response = police(function() {
                return new Client(result, origin, name, scope);
              });
            }));
          };
        })(this));
        return Object.freeze(this);
      };
      Object.defineProperty(ClientRequest, "prototype", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Object.freeze(Object.create(Request.prototype, {
          constructor: {
            enumerable: false,
            value: ClientRequest
          }
        }))
      });
      return ClientRequest;
    })()
  });

  LaboratoryEvent.create("LaboratoryClientReceived", Client);

  LaboratoryEvent.create("LaboratoryInitializationLoaded").create("LaboratoryInitializationReady");

  Object.defineProperties(Post, {
    Request: {
      configurable: false,
      enumerable: true,
      writable: false,
      value: (function() {
        var PostRequest;
        PostRequest = function(data, isLive, useCached) {
          var callback, isNotification, postID, ref, requestStart, requestStop, store, type;
          if (isLive == null) {
            isLive = true;
          }
          if (useCached == null) {
            useCached = true;
          }
          if (!(this && this instanceof PostRequest)) {
            throw new TypeError("this is not a PostRequest");
          }
          if (!((2e308 > (ref = (postID = Math.floor(data != null ? data.id : void 0))) && ref > 0))) {
            throw new TypeError("Unable to request post; no id provided");
          }
          if (!((type = Post.Type.fromValue(data.type)) && type !== Post.Type.UNKNOWN)) {
            type = Post.Type.STATUS;
          }
          isNotification = type & Post.Type.NOTIFICATION;
          store = isNotification ? Store.notifications : Store.statuses;
          callback = (function(_this) {
            return function(event) {
              var response;
              response = event.detail;
              if (response instanceof Post && response.id === postID && (response.type & Post.Type.NOTIFICATION) === isNotification) {
                if (!((response.compare != null) && response.compare(_this.response))) {
                  decree(function() {
                    return _this.response = response;
                  });
                }
                if (!isLive) {
                  return _this.stop();
                }
              }
            };
          })(this);
          Request.call(this, "GET", Store.auth.origin + (isNotification ? "/api/v1/notifications/" : "/api/v1/statuses/") + postID, null, Store.auth.accessToken, (function(_this) {
            return function(result) {
              var post;
              if (result.id !== postID) {
                _this.dispatchEvent(new CustomEvent("failure", {
                  request: _this,
                  response: new Failure("Unable to fetch post; returned post did not match requested id")
                }));
                return;
              }
              post = new Post(result);
              if ((post.type & Post.Type.NOTIFICATION) !== isNotification) {
                _this.dispatchEvent(new CustomEvent("failure", {
                  request: _this,
                  response: new Failure("Unable to fetch post; returned post was not of specified type")
                }));
                return;
              }
              return dispatch("LaboratoryPostReceived", post);
            };
          })(this));
          requestStart = this.start;
          requestStop = this.stop;
          Object.defineProperties(this, {
            start: {
              enumerable: false,
              value: function() {
                if (useCached && store[postID] instanceof Post) {
                  decree((function(_this) {
                    return function() {
                      return _this.response = store[postID];
                    };
                  })(this));
                  if (!isLive) {
                    return;
                  }
                }
                document.addEventListener("LaboratoryPostReceived", callback);
                return requestStart();
              }
            },
            stop: {
              enumerable: false,
              value: function() {
                document.removeEventListener("LaboratoryPostReceived", callback);
                return requestStop();
              }
            }
          });
          return Object.freeze(this);
        };
        Object.defineProperty(PostRequest, "prototype", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: Object.freeze(Object.create(Request.prototype, {
            constructor: {
              enumerable: false,
              value: PostRequest
            }
          }))
        });
        return PostRequest;
      })()
    },
    Create: {
      configurable: false,
      enumerable: true,
      writable: false,
      value: (function() {
        var PostCreate;
        PostCreate = function(data) {
          var attachment, attachments, inReplyTo, makeNSFW, message, ref, text, visibility;
          if (!(this && this instanceof PostCreate)) {
            throw new TypeError("this is not a PostCreate");
          }
          if (!(data != null ? data.text : void 0)) {
            throw new TypeError("Unable to create post; no text provided");
          }
          text = String(data.text);
          if (!(visibility = Post.Visibility.fromValue(data.visibility))) {
            visibility = Post.Visibility.PRIVATE;
          }
          if (!((2e308 > (ref = (inReplyTo = Math.floor(data.inReplyTo))) && ref > 0))) {
            inReplyTo = void 0;
          }
          attachments = (data.attachments instanceof Array ? data.attachments : void 0);
          message = data.message != null ? String(data.message) : void 0;
          makeNSFW = data.makeNSFW != null ? !!data.makeNSFW : void 0;
          Request.call(this, "POST", Store.auth.origin + "/api/v1/statuses/", {
            status: text,
            in_reply_to_id: inReplyTo,
            media_ids: attachments ? (function() {
              var i, len, results;
              results = [];
              for (i = 0, len = attachments.length; i < len; i++) {
                attachment = attachments[i];
                if (attachment instanceof Attachment) {
                  results.push(attachment.id);
                }
              }
              return results;
            })() : void 0,
            sensitive: makeNSFW ? "true" : void 0,
            spoiler_text: message,
            visibility: (function() {
              switch (visibility) {
                case Post.Visibility.PUBLIC:
                  return "public";
                case Post.Visibility.REBLOGGABLE:
                  return "unlisted";
                default:
                  return "private";
              }
            })()
          }, Store.auth.accessToken, (function(_this) {
            return function(result) {
              return dispatch("LaboratoryPostReceived", decree(function() {
                return _this.response = police(function() {
                  return new Post(result);
                });
              }));
            };
          })(this));
          return Object.freeze(this);
        };
        Object.defineProperty(PostCreate, "prototype", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: Object.freeze(Object.create(Request.prototype, {
            constructor: {
              enumerable: false,
              value: PostCreate
            }
          }))
        });
        return PostCreate;
      })()
    },
    Delete: {
      configurable: false,
      enumerable: true,
      writable: false,
      value: (function() {
        var PostDelete;
        PostDelete = function(data) {
          var postID, ref;
          if (!(this && this instanceof PostDelete)) {
            throw new TypeError("this is not a PostDelete");
          }
          if (!((2e308 > (ref = (postID = Math.floor(data != null ? data.id : void 0))) && ref > 0))) {
            throw new TypeError("Unable to create post; no id provided");
          }
          Request.call(this, "DELETE", Store.auth.origin + "/api/v1/statuses/" + postID, null, Store.auth.accessToken, (function(_this) {
            return function(result) {
              return dispatch("LaboratoryPostDeleted", {
                id: postID
              });
            };
          })(this));
          return Object.freeze(this);
        };
        Object.defineProperty(PostDelete, "prototype", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: Object.freeze(Object.create(Request.prototype, {
            constructor: {
              enumerable: false,
              value: PostDelete
            }
          }))
        });
        return PostDelete;
      })()
    },
    SetReblog: {
      configurable: false,
      enumerable: true,
      writable: false,
      value: (function() {
        var PostSetReblog;
        PostSetReblog = function(data) {
          var postID, ref, value;
          if (!(this && this instanceof PostSetReblog)) {
            throw new TypeError("this is not a PostSetReblog");
          }
          if (!((2e308 > (ref = (postID = Math.floor(data != null ? data.id : void 0))) && ref > 0))) {
            throw new TypeError("Unable to reblog post; no id provided");
          }
          value = data.value ? !!data.value : true;
          Request.call(this, "POST", Store.auth.origin + "/api/v1/statuses/" + postID + (value ? "/reblog" : "/unreblog"), null, Store.auth.accessToken, (function(_this) {
            return function(result) {
              return dispatch("LaboratoryPostReceived", decree(function() {
                return _this.response = police(function() {
                  return new Post(result);
                });
              }));
            };
          })(this));
          return Object.freeze(this);
        };
        Object.defineProperty(PostSetReblog, "prototype", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: Object.freeze(Object.create(Request.prototype, {
            constructor: {
              enumerable: false,
              value: PostSetReblog
            }
          }))
        });
        return PostSetReblog;
      })()
    },
    SetFavourite: {
      configurable: false,
      enumerable: true,
      writable: false,
      value: (function() {
        var PostSetFavourite;
        PostSetFavourite = function(data) {
          var postID, ref, value;
          if (!(this && this instanceof PostSetFavourite)) {
            throw new TypeError("this is not a PostSetFavourite");
          }
          if (!((2e308 > (ref = (postID = Math.floor(data != null ? data.id : void 0))) && ref > 0))) {
            throw new TypeError("Unable to favourite post; no id provided");
          }
          value = data.value ? !!data.value : true;
          Request.call(this, "POST", Store.auth.origin + "/api/v1/statuses/" + postID + (value ? "/favourite" : "/unfavourite"), null, Store.auth.accessToken, (function(_this) {
            return function(result) {
              return dispatch("LaboratoryPostReceived", decree(function() {
                return _this.response = police(function() {
                  return new Post(result);
                });
              }));
            };
          })(this));
          return Object.freeze(this);
        };
        Object.defineProperty(PostSetFavourite, "prototype", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: Object.freeze(Object.create(Request.prototype, {
            constructor: {
              enumerable: false,
              value: PostSetFavourite
            }
          }))
        });
        return PostSetFavourite;
      })()
    }
  });

  LaboratoryEvent.create("LaboratoryPostReceived", Post).create("LaboratoryPostDeleted", {
    id: void 0
  }).handle("LaboratoryPostReceived", function(event) {
    var id, post, ref, type;
    if ((post = event.detail) instanceof Post && (type = post.type) instanceof Post.Type && (2e308 > (ref = (id = Math.floor(post.id))) && ref > 0)) {
      return Store[["notifications", "statuses"][+(!(type & Post.Type.NOTIFICATION))]][id] = post;
    }
  }).handle("LaboratoryPostDeleted", function(event) {
    var id, ref;
    if ((2e308 > (ref = (id = Math.floor(event.detail.id))) && ref > 0)) {
      return delete Store.statuses[id];
    }
  });

  Object.defineProperties(Profile, {
    Request: {
      configurable: false,
      enumerable: true,
      writable: false,
      value: (function() {
        var ProfileRequest;
        ProfileRequest = function(data, isLive, useCached) {
          var callback, profileID, ref, relationshipRequest, requestStart, requestStop;
          if (isLive == null) {
            isLive = true;
          }
          if (useCached == null) {
            useCached = true;
          }
          if (!(this && this instanceof ProfileRequest)) {
            throw new TypeError("this is not a ProfileRequest");
          }
          if (!((2e308 > (ref = (profileID = Math.floor(data != null ? data.id : void 0))) && ref > 0))) {
            throw new TypeError("Unable to request profile; no id provided");
          }
          callback = (function(_this) {
            return function(event) {
              var response;
              response = event.detail;
              if (response instanceof Profile && response.id === profileID) {
                if (!((response.compare != null) && response.compare(_this.response))) {
                  decree(function() {
                    return _this.response = response;
                  });
                }
                if (!isLive) {
                  return _this.stop();
                }
              }
            };
          })(this);
          Request.call(this, "GET", Store.auth.origin + "/api/v1/accounts/" + profileID, null, Store.auth.accessToken, (function(_this) {
            return function(result) {
              if (result.id !== profileID) {
                _this.dispatchEvent(new CustomEvent("failure", {
                  id: _this.id,
                  request: _this,
                  response: new Failure("Unable to fetch profile; returned profile did not match requested id")
                }));
                return;
              }
              dispatch("LaboratoryProfileReceived", new Profile(result));
              return relationshipRequest.start();
            };
          })(this));
          relationshipRequest = new Request("GET", Store.auth.origin + "/api/v1/accounts/relationships", {
            id: postID
          }, Store.auth.accessToken, (function(_this) {
            return function(result) {
              var ref1, relID, relationship, relationships;
              relationships = response[0];
              relID = relationships.id;
              relationship = Profile.Relationship.fromValue((Profile.Relationship.FOLLOWER * relationships.followed_by + Profile.Relationship.FOLLOWING * relationships.following + Profile.Relationship.REQUESTED * relationships.requested + Profile.Relationship.BLOCKING * relationships.blocking + Profile.Relationship.MUTING * relationships.muting + Profile.Relationship.SELF * (relID === Store.auth.me)) || Profile.Relationship.UNKNOWN);
              if (((ref1 = Store.profiles[relID]) != null ? ref1.relationship : void 0) !== relaltionship) {
                return dispatch("LaboratoryProfileReceived", new Profile(Store.profiles[relID] || {
                  id: relID
                }, relationship));
              }
            };
          })(this));
          requestStart = this.start;
          requestStop = this.stop;
          Object.defineProperties(this, {
            start: {
              enumerable: false,
              value: function() {
                if (useCached && Store.profiles[profileID] instanceof Profile) {
                  decree((function(_this) {
                    return function() {
                      return _this.response = Store.profiles[profileID];
                    };
                  })(this));
                  if (!isLive) {
                    return;
                  }
                }
                document.addEventListener("LaboratoryProfileReceived", callback);
                return requestStart();
              }
            },
            stop: {
              enumerable: false,
              value: function() {
                document.removeEventListener("LaboratoryProfileReceived", callback);
                requestStop();
                return relationshipRequest.stop();
              }
            }
          });
          return Object.freeze(this);
        };
        Object.defineProperty(ProfileRequest, "prototype", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: Object.freeze(Object.create(Request.prototype, {
            constructor: {
              enumerable: false,
              value: ProfileRequest
            }
          }))
        });
        return ProfileRequest;
      })()
    },
    SetFollow: {
      configurable: false,
      enumerable: true,
      writable: false,
      value: (function() {
        var ProfileSetFollow;
        ProfileSetFollow = function(data) {
          var profileID, ref, value;
          if (!(this && this instanceof ProfileSetFollow)) {
            throw new TypeError("this is not a ProfileSetFollow");
          }
          if (!((2e308 > (ref = (profileID = Math.floor(data != null ? data.id : void 0))) && ref > 0))) {
            throw new TypeError("Unable to follow account; no id provided");
          }
          value = data.value ? !!data.value : true;
          Request.call(this, "POST", Store.auth.origin + "/api/v1/accounts/" + profileID + (value ? "/follow" : "/unfollow"), null, Store.auth.accessToken, (function(_this) {
            return function(result) {
              return dispatch("LaboratoryProfileReceived", decree(function() {
                return _this.response = police(function() {
                  return new Profile(result);
                });
              }));
            };
          })(this));
          return Object.freeze(this);
        };
        Object.defineProperty(ProfileSetFollow, "prototype", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: Object.freeze(Object.create(Request.prototype, {
            constructor: {
              enumerable: false,
              value: ProfileSetFollow
            }
          }))
        });
        return ProfileSetFollow;
      })()
    },
    SetBlock: {
      configurable: false,
      enumerable: true,
      writable: false,
      value: (function() {
        var ProfileSetBlock;
        ProfileSetBlock = function(data) {
          var profileID, ref, value;
          if (!(this && this instanceof ProfileSetBlock)) {
            throw new TypeError("this is not a ProfileSetBlock");
          }
          if (!((2e308 > (ref = (profileID = Math.floor(data != null ? data.id : void 0))) && ref > 0))) {
            throw new TypeError("Unable to block account; no id provided");
          }
          value = data.value ? !!data.value : true;
          Request.call(this, "POST", Store.auth.origin + "/api/v1/accounts/" + profileID + (value ? "/block" : "/unblock"), null, Store.auth.accessToken, (function(_this) {
            return function(result) {
              return dispatch("LaboratoryProfileReceived", decree(function() {
                return _this.response = police(function() {
                  return new Profile(result);
                });
              }));
            };
          })(this));
          return Object.freeze(this);
        };
        Object.defineProperty(ProfileSetBlock, "prototype", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: Object.freeze(Object.create(Request.prototype, {
            constructor: {
              enumerable: false,
              value: ProfileSetBlock
            }
          }))
        });
        return ProfileSetBlock;
      })()
    },
    SetMute: {
      configurable: false,
      enumerable: true,
      writable: false,
      value: (function() {
        var ProfileSetMute;
        ProfileSetMute = function(data) {
          var profileID, ref, value;
          if (!(this && this instanceof ProfileSetMute)) {
            throw new TypeError("this is not a ProfileSetMute");
          }
          if (!((2e308 > (ref = (profileID = Math.floor(data != null ? data.id : void 0))) && ref > 0))) {
            throw new TypeError("Unable to mute account; no id provided");
          }
          value = data.value ? !!data.value : true;
          Request.call(this, "POST", Store.auth.origin + "/api/v1/accounts/" + profileID + (value ? "/mute" : "/unmute"), null, Store.auth.accessToken, (function(_this) {
            return function(result) {
              return dispatch("LaboratoryProfileReceived", decree(function() {
                return _this.response = police(function() {
                  return new Profile(result);
                });
              }));
            };
          })(this));
          return Object.freeze(this);
        };
        Object.defineProperty(ProfileSetMute, "prototype", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: Object.freeze(Object.create(Request.prototype, {
            constructor: {
              enumerable: false,
              value: ProfileSetMute
            }
          }))
        });
        return ProfileSetMute;
      })()
    }
  });

  LaboratoryEvent.create("LaboratoryProfileReceived", Profile).handle("LaboratoryProfileReceived", function(event) {
    var id, profile, ref;
    if ((profile = event.detail) instanceof Profile && (2e308 > (ref = (id = Math.floor(profile.id))) && ref > 0)) {
      return Store.profiles[id] = profile;
    }
  });

  LaboratoryEvent.create("LaboratoryRequestOpen", XMLHttpRequest).create("LaboratoryRequestUpdate", XMLHttpRequest).create("LaboratoryRequestComplete", XMLHttpRequest).create("LaboratoryRequestError", XMLHttpRequest);

  Object.defineProperties(Rolodex, "Request", {
    configurable: false,
    enumerable: true,
    writable: false,
    value: (function() {
      var RolodexRequest;
      RolodexRequest = function(data, before, after) {
        var limit, query, ref, type;
        if (!(this && this instanceof RolodexRequest)) {
          throw new TypeError("this is not a RolodexRequest");
        }
        if (!((type = Rolodex.Type.fromValue(data.type)) && type !== Rolodex.Type.UNDEFINED)) {
          throw new TypeError("Unable to request rolodex; no type provided");
        }
        query = data.query != null ? String(data.query) : void 0;
        limit = (2e308 > (ref = data.limit) && ref > 0) ? Math.floor(data.limit) : void 0;
        before = void 0;
        after = void 0;
        Request.call(this, "GET", Store.auth.origin + ((function() {
          switch (type) {
            case Rolodex.Type.SEARCH:
              return "/api/v1/accounts/search";
            case Rolodex.Type.FOLLOWERS:
              return "/api/v1/accounts/" + query + "/followers";
            case Rolodex.Type.FOLLOWING:
              return "/api/v1/accounts/" + query + "/following";
            case Rolodex.Type.FAVOURITED_BY:
              return "/api/v1/statuses/" + query + "/favourited_by";
            case Rolodex.Type.REBLOGGED_BY:
              return "/api/v1/statuses/" + query + "/reblogged_by";
            case Rolodex.Type.BLOCKS:
              return "/api/v1/blocks";
            case Rolodex.Type.MUTES:
              return "/api/v1/mutes";
            case Rolodex.Type.FOLLOW_REQUESTS:
              return "/api/v1/follow_requests";
          }
        })()), ((function() {
          switch (type) {
            case Rolodex.Type.SEARCH:
              return {
                q: query,
                limit: limit
              };
            default:
              return {
                max_id: before,
                since_id: after
              };
          }
        })()), Store.auth.accessToken, (function(_this) {
          return function(result, params) {
            var account, i, ids, len, ref1, ref2, ref3;
            ids = [];
            before = (((ref1 = params.prev) != null ? ref1.match(/.*since_id=([0-9]+)/) : void 0) || [])[1];
            after = (((ref2 = params.next) != null ? ref2.match(/.*max_id=([0-9]+)/) : void 0) || [])[1];
            for (i = 0, len = result.length; i < len; i++) {
              account = result[i];
              if (!(ref3 = account.id, indexOf.call(ids, ref3) < 0)) {
                continue;
              }
              ids.push(account.id);
              dispatch("LaboratoryProfileReceived", new Profile(account));
            }
            return decree(function() {
              return _this.response = police(function() {
                return new Rolodex(result);
              });
            });
          };
        })(this));
        Object.defineProperties(this, {
          before: {
            enumerable: true,
            get: function() {
              return before;
            }
          },
          after: {
            enumerable: true,
            get: function() {
              return after;
            }
          },
          prev: {
            enumerable: false,
            value: function() {
              return new RolodexRequest({
                type: type,
                query: query,
                limit: limit
              }, void 0, before);
            }
          },
          next: {
            enumerable: false,
            value: function() {
              return new RolodexRequest({
                type: type,
                query: query,
                limit: limit
              }, after);
            }
          },
          loadMore: {
            enumerable: false,
            value: (function(_this) {
              return function() {
                var callback, next;
                callback = function(event) {
                  after = next.after;
                  decree(function() {
                    return _this.response = police(function() {
                      return this.response.join(next.response);
                    });
                  });
                  return next.removeEventListener("response", callback);
                };
                (next = _this.next()).addEventListener("response", callback);
                return next.start();
              };
            })(this)
          },
          update: {
            enumerable: false,
            value: (function(_this) {
              return function(keepGoing) {
                var callback, prev;
                callback = function(event) {
                  var prev;
                  before = prev.before;
                  decree(function() {
                    return _this.response = police(function() {
                      return this.response.join(prev.response);
                    });
                  });
                  prev.removeEventListener("response", callback);
                  if (keepGoing && prev.response.length) {
                    (prev = _this.prev()).addEventListener("response", callback);
                    return prev.start();
                  }
                };
                (prev = _this.prev()).addEventListener("response", callback);
                return prev.start();
              };
            })(this)
          }
        });
        return Object.freeze(this);
      };
      Object.defineProperty(RolodexRequest, "prototype", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Object.freeze(Object.create(Request.prototype, {
          constructor: {
            enumerable: false,
            value: RolodexRequest
          },
          prev: {
            enumerable: false,
            value: function() {}
          },
          next: {
            enumerable: false,
            value: function() {}
          },
          loadMore: {
            enumerable: false,
            value: function() {}
          },
          update: {
            enumerable: false,
            value: function() {}
          }
        }))
      });
      return RolodexRequest;
    })()
  });

  Object.defineProperty(Timeline, "Request", {
    configurable: false,
    enumerable: true,
    writable: false,
    value: (function() {
      var TimelineRequest;
      TimelineRequest = function(data, before, after) {
        var isLocal, limit, query, ref, type;
        if (!(this && this instanceof TimelineRequest)) {
          throw new TypeError("this is not a TimelineRequest");
        }
        if (!((type = Timeline.Type.fromValue(data.type)) && type !== Timeline.Type.UNDEFINED)) {
          throw new TypeError("Unable to request rolodex; no type provided");
        }
        query = data.query != null ? String(data.query) : void 0;
        isLocal = !!data.isLocal;
        limit = (2e308 > (ref = data.limit) && ref > 0) ? Math.floor(data.limit) : void 0;
        before = void 0;
        after = void 0;
        Request.call(this, "GET", Store.auth.origin + ((function() {
          switch (type) {
            case Timeline.Type.HASHTAG:
              return "/api/v1/timelines/tag/" + query;
            case Timeline.Type.LOCAL:
              return "/api/v1/timelines/public";
            case Timeline.Type.GLOBAL:
              return "/api/v1/timelines/public";
            case Timeline.Type.HOME:
              return "/api/v1/timelines/home";
            case Timeline.Type.NOTIFICATIONS:
              return "/api/v1/notifications";
            case Timeline.Type.FAVOURITES:
              return "/api/v1/favourites";
            case Timeline.Type.ACCOUNT:
              return "/api/v1/accounts/" + query + "/statuses";
            default:
              return "/api/v1";
          }
        })()), ((function() {
          switch (type) {
            case isLocal:
              return {
                local: true,
                max_id: before,
                since_id: after
              };
            default:
              return {
                max_id: before,
                since_id: after
              };
          }
        })()), Store.auth.accessToken, (function(_this) {
          return function(result, params) {
            var account, acctIDs, i, ids, j, k, l, len, len1, len2, len3, mention, mentionIDs, mentions, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, status;
            acctIDs = [];
            mentions = [];
            mentionIDs = [];
            ids = [];
            before = (((ref1 = params.prev) != null ? ref1.match(/.*since_id=([0-9]+)/) : void 0) || [])[1];
            after = (((ref2 = params.next) != null ? ref2.match(/.*max_id=([0-9]+)/) : void 0) || [])[1];
            for (i = 0, len = result.length; i < len; i++) {
              status = result[i];
              if (!(ref3 = status.id, indexOf.call(ids, ref3) < 0)) {
                continue;
              }
              ids.push(status.id);
              ref6 = [status.account, (ref4 = status.status) != null ? ref4.account : void 0, (ref5 = status.reblog) != null ? ref5.account : void 0];
              for (j = 0, len1 = ref6.length; j < len1; j++) {
                account = ref6[j];
                if (!(account)) {
                  continue;
                }
                acctIDs.push(account.id);
                dispatch("LaboratoryProfileReceived", new Profile(account));
              }
              if ((mentions = status.mentions || ((ref7 = status.status) != null ? ref7.mentions : void 0) || ((ref8 = status.reblog) != null ? ref8.mentions : void 0)) instanceof Array) {
                for (k = 0, len2 = mentions.length; k < len2; k++) {
                  account = mentions[k];
                  if (!(ref9 = account.id, indexOf.call(mentionIDs, ref9) < 0)) {
                    continue;
                  }
                  mentionIDs.push(account.id);
                  mentions.push(account);
                }
              }
              dispatch("LaboratoryPostReceived", new Post(status));
            }
            for (l = 0, len3 = mentions.length; l < len3; l++) {
              mention = mentions[l];
              if ((ref10 = mention.id, indexOf.call(acctIDs, ref10) < 0) && (Store.profiles[mention.id] == null)) {
                dispatch("LaboratoryProfileReceived", new Profile(mention));
              }
            }
            return decree(function() {
              return _this.response = police(function() {
                return new Timeline(result);
              });
            });
          };
        })(this));
        Object.defineProperties(this, {
          before: {
            enumerable: true,
            get: function() {
              return before;
            }
          },
          after: {
            enumerable: true,
            get: function() {
              return after;
            }
          },
          prev: {
            enumerable: false,
            value: function() {
              return new TimelineRequest({
                type: type,
                query: query,
                isLocal: isLocal
              }, void 0, before);
            }
          },
          next: {
            enumerable: false,
            value: function() {
              return new TimelineRequest({
                type: type,
                query: query,
                isLocal: isLocal
              }, after);
            }
          },
          loadMore: {
            enumerable: false,
            value: (function(_this) {
              return function() {
                var callback, next;
                callback = function(event) {
                  after = next.after;
                  decree(function() {
                    return _this.response = police(function() {
                      return this.response.join(next.response);
                    });
                  });
                  return next.removeEventListener("response", callback);
                };
                (next = _this.next()).addEventListener("response", callback);
                return next.start();
              };
            })(this)
          },
          update: {
            enumerable: false,
            value: (function(_this) {
              return function(keepGoing) {
                var callback, prev;
                callback = function(event) {
                  var prev;
                  before = prev.before;
                  decree(function() {
                    return _this.response = police(function() {
                      return this.response.join(prev.response);
                    });
                  });
                  prev.removeEventListener("response", callback);
                  if (keepGoing && prev.response.length) {
                    (prev = _this.prev()).addEventListener("response", callback);
                    return prev.start();
                  }
                };
                (prev = _this.prev()).addEventListener("response", callback);
                return prev.start();
              };
            })(this)
          }
        });
        return Object.freeze(this);
      };
      Object.defineProperty(TimelineRequest, "prototype", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Object.freeze(Object.create(Request.prototype, {
          constructor: {
            enumerable: false,
            value: TimelineRequest
          },
          prev: {
            enumerable: false,
            value: function() {}
          },
          next: {
            enumerable: false,
            value: function() {}
          },
          loadMore: {
            enumerable: false,
            value: function() {}
          },
          update: {
            enumerable: false,
            value: function() {}
          }
        }))
      });
      return TimelineRequest;
    })()
  });

  Store = null;

  (Laboratory.reset = reset = function() {
    Store = {
      auth: null,
      notifications: {},
      profiles: {},
      statuses: {}
    };
  })();

  window["🏪"] = Store;

  Object.defineProperty(window, "Laboratory", {
    value: Object.freeze(Laboratory),
    enumerable: true
  });

  dispatch("LaboratoryInitializationLoaded");

  run = function() {
    var handler, i, len, ref;
    ref = LaboratoryEvent.Handlers;
    for (i = 0, len = ref.length; i < len; i++) {
      handler = ref[i];
      listen(handler.type, handler);
    }
    Exposed.ready = true;
    return dispatch("LaboratoryInitializationReady");
  };

  if (document.readyState === "complete") {
    run();
  } else {
    window.addEventListener("load", run);
  }

}).call(this);
