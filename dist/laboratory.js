// Generated by CoffeeScript 1.12.4
(function() {
  "use strict";

  /*
  
      ............. LABORATORY ..............
  
      A client-side API for Mastodon, a free,
         open-source social network server
                - - by Kibigo! - -
  
          Licensed under the MIT License.
             Source code available at:
      https://github.com/marrus-sh/laboratory
  
                  Version 0.3.1
   */
  var Application, Attachment, Authorization, Client, Enumeral, Exposed, Failure, Laboratory, LaboratoryEvent, Post, Profile, Rolodex, Store, Timeline, dispatch, fn, forget, listen, prop, request, run, serverRequest,
    hasProp = {}.hasOwnProperty;

  Laboratory = {
    ℹ: "https://github.com/marrus-sh/laboratory",
    Nº: 3.1
  };

  (function() {
    var Mommy, code;
    if (!((code = (location.search.match(/code=([^&]*)/) || [])[1]) && (Mommy = window.opener.Laboratory))) {
      return;
    }
    Mommy.dispatch("LaboratoryAuthorizationGranted", {
      code: code
    });
  })();

  Exposed = {
    ready: false,
    auth: null
  };

  fn = function(prop) {
    return Object.defineProperty(Laboratory, prop, {
      get: (function() {
        return Exposed[prop];
      }),
      enumerable: true
    });
  };
  for (prop in Exposed) {
    fn(prop);
  }

  (function() {
    var CustomEvent;
    if (typeof CustomEvent === "function") {
      return;
    }
    CustomEvent = function(event, params) {
      var e;
      params = params || {
        bubbles: false,
        cancelable: false,
        detail: void 0
      };
      e = document.createEvent("CustomEvent");
      e.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return e;
    };
    CustomEvent.prototype = window.Event.prototype;
    Object.freeze(CustomEvent);
    return Object.freeze(CustomEvent.prototype);
  })();

  serverRequest = function(method, location, data, accessToken, onComplete, onError) {
    var callback, contents, key, request, subvalue, value;
    if (!(method === "GET" || method === "POST" || method === "DELETE")) {
      return;
    }
    location = String(location);
    data = Object(data);
    request = new XMLHttpRequest;
    contents = method === "POST" && (typeof FormData !== "undefined" && FormData !== null) && data instanceof FormData ? data : (((function() {
      var results;
      results = [];
      for (key in data) {
        value = data[key];
        if (value != null) {
          if (value instanceof Array) {
            results.push(((function() {
              var i, len, results1;
              results1 = [];
              for (i = 0, len = value.length; i < len; i++) {
                subvalue = value[i];
                results1.push((encodeURIComponent(key)) + "[]=" + (encodeURIComponent(subvalue)));
              }
              return results1;
            })()).join("&"));
          } else {
            results.push((encodeURIComponent(key)) + "=" + (encodeURIComponent(value)));
          }
        }
      }
      return results;
    })()).join("&")).replace(/%20/g, '+');
    if (!(contents === "" || method === "POST")) {
      location += ((location.indexOf("?")) !== -1 ? "&" : "?") + contents;
    }
    request.open(method, location);
    if (method === "POST" && !((typeof FormData !== "undefined" && FormData !== null) && contents instanceof FormData)) {
      request.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    }
    if (accessToken) {
      request.setRequestHeader("Authorization", "Bearer " + accessToken);
    }
    callback = function() {
      var params, ref, ref1, response, status;
      switch (request.readyState) {
        case 0:
          break;
        case 1:
          dispatch("LaboratoryRequestOpen", request);
          break;
        case 2:
        case 3:
          dispatch("LaboratoryRequestUpdate", request);
          break;
        case 4:
          status = request.status;
          response = (function() {
            try {
              if (request.responseText) {
                return JSON.parse(request.responseText);
              } else {
                return null;
              }
            } catch (error) {
              return {
                error: "The response could not be parsed."
              };
            }
          })();
          params = {
            status: status,
            url: location,
            prev: (((ref = request.getResponseHeader("Link")) != null ? ref.match(/<\s*([^,]*)\s*>\s*;[^,]*[;\s]rel="?prev(?:ious)?"?/) : void 0) || [])[1],
            next: (((ref1 = request.getResponseHeader("Link")) != null ? ref1.match(/<\s*([^,]*)\s*>\s*;[^,]*[;\s]rel="?next"?/) : void 0) || [])[1]
          };
          switch (false) {
            case !((200 <= status && status <= 205)):
              if ((response != null ? response.error : void 0) != null) {
                onError(response, data, params);
                dispatch("LaboratoryRequestError", request);
              } else {
                onComplete(response, data, params);
                dispatch("LaboratoryRequestComplete", request);
              }
              break;
            default:
              onError(response, data, params);
              dispatch("LaboratoryRequestError", request);
          }
          request.removeEventListener("readystatechange", callback);
      }
    };
    request.addEventListener("readystatechange", callback);
    if (method === "POST") {
      request.send(contents);
    } else {
      request.send();
    }
  };

  Laboratory.Enumeral = Enumeral = null;

  (function() {
    var generator;
    generator = false;
    Laboratory.Enumeral = Enumeral = function(value) {
      if (!generator) {
        throw new Error("Laboratory Error : The `Enumeral()` constructor cannot be called directly—try `Enumeral.generate()` instead");
      }
      if (!(this && this instanceof Enumeral)) {
        throw new Error("Laboratory Error : `Enumeral()` must be called as a constructor");
      }
      this.value = value | 0;
      return Object.freeze(this);
    };
    Object.defineProperty(Enumeral, "prototype", {
      value: Object.freeze({
        toString: function() {
          return "Enumeral(" + this.value + ")";
        },
        toSource: function() {
          return "Enumeral(" + this.value + ")";
        },
        valueOf: function() {
          return this.value;
        }
      })
    });
    return Enumeral.generate = function(data) {
      var byValue, enumeral, type, value;
      type = function(n) {
        return Enumeral.call(this, n);
      };
      type.prototype = Object.create(Enumeral.prototype);
      generator = true;
      byValue = {};
      for (enumeral in data) {
        if (!hasProp.call(data, enumeral)) continue;
        value = data[enumeral];
        if (byValue[value] != null) {
          continue;
        }
        type[enumeral] = new type(value);
        byValue[value] = type[enumeral];
      }
      generator = false;
      type.fromValue = function(n) {
        return byValue[n | 0];
      };
      return Object.freeze(type);
    };
  })();

  Laboratory.Application = Application = function(data) {
    if (!(this && this instanceof Application)) {
      throw new Error("Laboratory Error : `Application()` must be called as a constructor");
    }
    if (data == null) {
      throw new Error("Laboratory Error : `Application()` was called without any `data`");
    }
    this.name = data.name;
    this.href = data.website;
    return Object.freeze(this);
  };

  Object.defineProperty(Application, "prototype", {
    value: Object.freeze({})
  });

  Laboratory.Attachment = Attachment = function(data) {
    if (!(this && this instanceof Attachment)) {
      throw new Error("Laboratory Error : `Attachment()` must be called as a constructor");
    }
    if (data == null) {
      throw new Error("Laboratory Error : `Attachment()` was called without any `data`");
    }
    this.id = Number(data.id);
    this.href = String(data.url);
    this.preview = String(data.preview_url);
    this.type = (function() {
      switch (data.type) {
        case "image":
          return Attachment.Type.IMAGE;
        case "video":
          return Attachment.Type.VIDEO;
        case "gifv":
          return Attachment.Type.GIFV;
        default:
          return Attachment.Type.UNKNOWN;
      }
    })();
    return Object.freeze(this);
  };

  Object.defineProperty(Attachment, "prototype", {
    value: Object.freeze({})
  });

  Attachment.Type = Enumeral.generate({
    UNKNOWN: 0x0,
    PHOTO: 0x1,
    VIDEO: 0x2,
    GIFV: 0x3
  });

  Laboratory.Authorization = Authorization = function(data, origin, me) {
    var scopes;
    if (!(this && this instanceof Authorization)) {
      throw new Error("Laboratory Error : `Authorization()` must be called as a constructor");
    }
    if (data == null) {
      throw new Error("Laboratory Error : `Authorization()` was called without any `data`");
    }
    this.origin = String(origin);
    this.accessToken = String(data.access_token);
    this.datetime = new Date(data.created_at);
    this.scope = Authorization.Scope.fromValue(Authorization.Scope.READ * (((scopes = (String(data.scope)).split(/[\s\+]+/g)).indexOf("read")) !== -1) + Authorization.Scope.WRITE * ((scopes.indexOf("write")) !== -1) + Authorization.Scope.FOLLOW * ((scopes.indexOf("follow")) !== -1));
    this.tokenType = String(data.tokenType);
    this.me = +me;
    return Object.freeze(this);
  };

  Object.defineProperty(Authorization, "prototype", {
    value: Object.freeze({})
  });

  Authorization.Scope = Enumeral.generate({
    NONE: 0x0,
    READ: 0x1,
    WRITE: 0x2,
    READWRITE: 0x3,
    FOLLOW: 0x4,
    READFOLLOW: 0x5,
    WRITEFOLLOW: 0x6,
    READWRITEFOLLOW: 0x7
  });

  Laboratory.Client = Client = function(data, params, origin) {
    if (!(this && this instanceof Client)) {
      throw new Error("Laboratory Error : `Client()` must be called as a constructor");
    }
    if (data == null) {
      throw new Error("Laboratory Error : `Client()` was called without any `data`");
    }
    this.origin = origin;
    this.name = params.client_name;
    this.id = data.id;
    this.clientID = data.client_id;
    this.clientSecret = data.client_secret;
    this.scope = Authorization.Scope.fromValue(Authorization.Scope.READ * (params.scopes.indexOf("read") !== -1) + Authorization.Scope.WRITE * (params.scopes.indexOf("write") !== -1) + Authorization.Scope.FOLLOW * (params.scopes.indexOf("follow") !== -1));
    this.redirect = data.redirect_uri;
    return Object.freeze(this);
  };

  Object.defineProperty(Client, "prototype", {
    value: Object.freeze({})
  });

  Laboratory.Failure = Failure = function(data, request, code) {
    if (!(this && this instanceof Failure)) {
      throw new Error("Laboratory Error : `Failure()` must be called as a constructor");
    }
    if (data == null) {
      throw new Error("Laboratory Error : `Failure()` was called without any `data`");
    }
    this.request = String(request);
    this.error = String(data.error);
    if (!isFinite(this.code = Number(code))) {
      this.code = null;
    }
    return Object.freeze(this);
  };

  Object.defineProperty(Failure, "prototype", {
    value: Object.freeze({})
  });

  Laboratory.Post = Post = function(data) {
    var fromID, getProfile, item, profiles;
    if (!(this && this instanceof Post)) {
      throw new Error("Laboratory Error : `Post()` must be called as a constructor");
    }
    if (data == null) {
      throw new Error("Laboratory Error : `Post()` was called without any `data`");
    }
    profiles = Store.profiles;
    getProfile = function(id) {
      return profiles[id];
    };
    if (data.type != null) {
      this.id = data.id;
      fromID = data.account.id;
      if (data.status) {
        switch (data.type) {
          case "reblog":
            this.type = Post.Type.REBLOG;
            Object.defineProperty(this, "rebloggedBy", {
              get: getProfile.bind(this, fromID),
              enumerable: true
            });
            break;
          case "favourite":
            this.type = Post.Type.FAVOURITE;
            Object.defineProperty(this, "favouritedBy", {
              get: getProfile.bind(this, fromID),
              enumerable: true
            });
            break;
          case "mention":
            this.type = Post.Type.MENTION;
            break;
          default:
            this.type = Post.Type.REACTION;
        }
        data = data.status;
      } else {
        Object.defineProperty(this, "author", {
          get: getProfile.bind(this, fromID),
          enumerable: true
        });
        switch (data.type) {
          case "follow":
            this.type = Post.Type.FOLLOW;
            break;
          default:
            this.type = Post.Type.NOTIFICATION;
        }
        return Object.freeze(this);
      }
    } else {
      this.type = Post.Type.STATUS;
      this.id = data.id;
      if (data.reblog) {
        Object.defineProperty(this, "rebloggedBy", {
          get: getProfile.bind(this, data.account.id),
          enumerable: true
        });
        data = data.reblog;
      }
    }
    this.uri = String(data.uri);
    this.href = String(data.url);
    Object.defineProperty(this, "author", {
      get: getProfile.bind(this, data.account.id),
      enumerable: true
    });
    this.inReplyTo = Number(data.in_reply_to_id);
    this.content = String(data.content);
    this.datetime = new Date(data.created_at);
    this.reblogCount = Number(data.reblogs_count);
    this.favouriteCount = Number(data.favourites_count);
    this.isReblogged = !!data.reblogged;
    this.isFavourited = !!data.favourited;
    this.isNSFW = !!data.sensitive;
    this.message = String(data.spoiler_text);
    this.visibility = {
      "private": Post.Visibility.PRIVATE,
      unlisted: Post.Visibility.REBLOGGABLE,
      "public": Post.Visibility.PUBLIC
    }[data.visibility] || Post.Visibility.PRIVATE;
    this.mediaAttachments = (function() {
      var i, len, ref, results;
      ref = data.media_attachments;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        results.push(new Attachment(item));
      }
      return results;
    })();
    this.mentions = (function(_this) {
      return function() {
        var i, index, len, mention, mentions, ref;
        mentions = [];
        ref = data.mentions;
        for (index = i = 0, len = ref.length; i < len; index = ++i) {
          mention = ref[index];
          Object.defineProperty(mentions, index, {
            get: getProfile.bind(_this, mention.id),
            enumerable: true
          });
        }
        return mentions;
      };
    })(this)();
    this.application = data.application != null ? new Application(data.application) : null;
    return Object.freeze(this);
  };

  Object.defineProperty(Post, "prototype", {
    value: Object.freeze({
      compare: function(other) {
        if (!(this instanceof Post && other instanceof Post)) {
          return false;
        }
        return this.type === other.type && this.id === other.id && this.reblogCount === other.reblogCount && this.favouriteCount === other.favouriteCount && this.isReblogged === other.isReblogged && this.isFavourited === other.isFavourited;
      }
    })
  });

  Post.Type = Enumeral.generate({
    UNKNOWN: 0x00,
    STATUS: 0x10,
    NOTIFICATION: 0x20,
    FOLLOW: 0x21,
    REACTION: 0x30,
    FAVOURITE: 0x31,
    REBLOG: 0x32,
    MENTION: 0x33
  });

  Post.Visibility = Enumeral.generate({
    PRIVATE: 0x00,
    REBLOGGABLE: 0x01,
    LISTED: 0x02,
    PUBLIC: 0x03
  });

  Laboratory.Profile = Profile = function(data, relationship) {
    var origin, ref;
    if (!(this && this instanceof Profile)) {
      throw new Error("Laboratory Error : `Profile()` must be called as a constructor");
    }
    if (data == null) {
      throw new Error("Laboratory Error : `Profile()` was called without any `data`");
    }
    if (relationship == null) {
      relationship = (ref = Store.profiles[data.id]) != null ? ref.relationship : void 0;
    }
    if (data instanceof Profile) {
      this.id = data.id, this.username = data.username, this.account = data.account, this.localAccount = data.localAccount, this.displayName = data.displayName, this.bio = data.bio, this.href = data.href, this.avatar = data.avatar, this.header = data.header, this.isLocked = data.isLocked, this.followerCount = data.followerCount, this.followingCount = data.followingCount, this.statusCount = data.statusCount, this.relationship = data.relationship;
    } else {
      this.id = Number(data.id);
      this.username = String(data.username);
      this.account = String(data.acct + (((origin = Store.auth.origin) != null) && data.acct.indexOf("@") === -1 ? "@" + origin : ""));
      this.localAccount = String(data.acct);
      this.displayName = String(data.display_name);
      this.bio = String(data.note);
      this.href = String(data.url);
      this.avatar = String(data.avatar);
      this.header = String(data.header);
      this.isLocked = !!data.locked;
      this.followerCount = Number(data.followers_count);
      this.followingCount = Number(data.following_count);
      this.statusCount = Number(data.statuses_count);
      this.relationship = data.id === Store.auth.me ? Profile.Relationship.SELF : Profile.Relationship.UNKNOWN;
    }
    if (relationship != null) {
      this.relationship = Profile.Relationship.fromValue(relationship) || this.relationship;
    }
    return Object.freeze(this);
  };

  Object.defineProperty(Profile, "prototype", {
    value: Object.freeze({
      compare: function(other) {
        if (!(this instanceof Profile && other instanceof Profile)) {
          return false;
        }
        return this.id === other.id && this.relationship === other.relationship && this.followerCount === other.followerCount && this.followingCount === other.followingCount && this.statusCount === other.statusCount && this.bio === other.bio && this.displayName === other.displayName && this.avatar === other.avatar && this.header === other.header && this.isLocked === other.isLocked && this.username === other.username && this.localAccount === other.localAccount && this.account === other.account && this.href === other.href;
      }
    })
  });

  Profile.Relationship = Enumeral.generate({
    NOT_FOLLOWING: 0x0,
    FOLLOWER: 0x1,
    FOLLOWING: 0x2,
    MUTUAL: 0x3,
    REQUESTED: 0x4,
    REQUESTED_MUTUAL: 0x5,
    BLOCKING: 0x8,
    MUTING: 0x10,
    MUTING_FOLLOWER: 0x11,
    MUTING_FOLLOWING: 0x12,
    MUTING_MUTUAL: 0x13,
    MUTING_REQUESTED: 0x14,
    MUTING_REQUESTED_MUTUAL: 0x15,
    UNKNOWN: 0x40,
    SELF: 0x80
  });

  Laboratory.Rolodex = Rolodex = function(data, params) {
    var current, currentID, getProfile, i, index, j, len, prev, ref, value;
    if (!(this && this instanceof Rolodex)) {
      throw new Error("Laboratory Error : `Rolodex()` must be called as a constructor");
    }
    if (data == null) {
      throw new Error("Laboratory Error : `Rolodex()` was called without any `data`");
    }
    this.type = params.type instanceof Rolodex.Type ? params.type : Rolodex.Type.UNDEFINED;
    this.query = String(params.query);
    if (isFinite(params.before)) {
      this.before = Number(params.before);
    }
    if (isFinite(params.after)) {
      this.after = Number(params.after);
    }
    getProfile = function(id) {
      return Store.profiles[id];
    };
    data.sort(function(first, second) {
      return second.id - first.id;
    });
    prev = null;
    for (index = i = ref = data.length - 1; ref <= 0 ? i <= 0 : i >= 0; index = ref <= 0 ? ++i : --i) {
      currentID = (current = data[index]).id;
      if ((prev != null) && currentID === prev.id) {
        data.splice(index, 1);
        continue;
      }
      prev = current;
    }
    this.profiles = [];
    for (index = j = 0, len = data.length; j < len; index = ++j) {
      value = data[index];
      Object.defineProperty(this.profiles, index, {
        get: getProfile.bind(this, value.id),
        enumerable: true
      });
    }
    Object.freeze(this.profiles);
    return Object.freeze(this);
  };

  Object.defineProperty(Rolodex, "prototype", {
    value: Object.freeze({
      join: function(data) {
        var combined, i, j, len, len1, profile, ref, ref1;
        if (!(data instanceof Profile || data instanceof Array || data instanceof Rolodex)) {
          return this;
        }
        ref = (function() {
          switch (false) {
            case !(data instanceof Profile):
              return [data];
            case !(data instanceof Rolodex):
              return data.profiles;
            default:
              return data;
          }
        })();
        for (i = 0, len = ref.length; i < len; i++) {
          profile = ref[i];
          combined = profile;
        }
        ref1 = this.profiles;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          profile = ref1[j];
          combined.push(profile);
        }
        return new Rolodex(combined, (data instanceof Rolodex ? data.type === this.type && data.query === this.query ? {
          type: this.type,
          query: this.query,
          before: (function() {
            switch (false) {
              case !(data.before >= this.before):
                return data.before;
              case !(data.before <= this.before):
                return this.before;
              default:
                return void 0;
            }
          }).call(this),
          after: (function() {
            switch (false) {
              case !(data.after <= this.after):
                return data.after;
              case !(data.after >= this.after):
                return this.after;
              default:
                return void 0;
            }
          }).call(this)
        } : {
          type: data.type === this.type ? this.type : Rolodex.Type.UNDEFINED,
          query: "",
          before: void 0,
          after: void 0
        } : {
          type: this.type,
          query: this.query,
          before: this.before,
          after: this.after
        }));
      },
      remove: function(data) {
        var i, index, len, profile, redacted, ref;
        if (!(data instanceof Profile || data instanceof Array || data instanceof Rolodex)) {
          return this;
        }
        redacted = (function() {
          var i, len, ref, results;
          ref = this.profiles;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            profile = ref[i];
            results.push(profile);
          }
          return results;
        }).call(this);
        ref = ((function() {
          switch (false) {
            case !(data instanceof Profile):
              return [data];
            case !(data instanceof Rolodex):
              return data.profiles;
            default:
              return data;
          }
        })());
        for (i = 0, len = ref.length; i < len; i++) {
          profile = ref[i];
          if ((index = redacted.indexOf(profile)) !== -1) {
            redacted.splice(index, 1);
          }
        }
        return new Rolodex(redacted, {
          type: this.type,
          query: this.query,
          before: this.before,
          after: this.after
        });
      }
    })
  });

  Rolodex.Type = Enumeral.generate({
    UNDEFINED: 0x00,
    SEARCH: 0x10,
    FOLLOWERS: 0x21,
    FOLLOWING: 0x22,
    FAVOURITED_BY: 0x41,
    REBLOGGED_BY: 0x45,
    BLOCKS: 0x83,
    MUTES: 0x84
  });

  Laboratory.Timeline = Timeline = function(data, params) {
    var current, currentID, getPost, i, index, isNotification, j, len, prev, ref, value;
    if (!(this && this instanceof Timeline)) {
      throw new Error("Laboratory Error : `Timeline()` must be called as a constructor");
    }
    if (data == null) {
      throw new Error("Laboratory Error : `Timeline()` was called without any `data`");
    }
    this.type = params.type instanceof Timeline.Type ? params.type : Timeline.Type.UNDEFINED;
    this.query = String(params.query);
    if (isFinite(params.before)) {
      this.before = Number(params.before);
    }
    if (isFinite(params.after)) {
      this.after = Number(params.after);
    }
    isNotification = function(object) {
      return !!(((function() {
        switch (false) {
          case !(object instanceof Post):
            return object.type;
          case object.type == null:
            return Post.Type.NOTIFICATION;
          default:
            return Post.Type.STATUS;
        }
      })()) & Post.Type.NOTIFICATION);
    };
    getPost = function(id, isANotification) {
      if (isANotification) {
        return Store.notifications[id];
      } else {
        return Store.statuses[id];
      }
    };
    data.sort(function(first, second) {
      var a, b;
      if (!(isNotification(first)) && !(isNotification(second)) && (a = Number(first instanceof Post && first.datetime || Date(first.created_at))) !== (b = Number(second instanceof Post && second.datetime || Date(second.created_at)))) {
        return -1 + 2 * (a > b);
      } else {
        return second.id - first.id;
      }
    });
    prev = null;
    for (index = i = ref = data.length - 1; ref <= 0 ? i <= 0 : i >= 0; index = ref <= 0 ? ++i : --i) {
      currentID = (current = data[index]).id;
      if ((prev != null) && currentID === prev.id && (isNotification(prev)) === (isNotification(current))) {
        data.splice(index, 1);
        continue;
      }
      prev = current;
    }
    this.posts = [];
    for (index = j = 0, len = data.length; j < len; index = ++j) {
      value = data[index];
      Object.defineProperty(this.posts, index, {
        get: getPost.bind(this, value.id, isNotification(value)),
        enumerable: true
      });
    }
    Object.freeze(this.posts);
    return Object.freeze(this);
  };

  Object.defineProperty(Timeline, "prototype", {
    value: Object.freeze({
      join: function(data) {
        var combined, i, j, len, len1, post, ref, ref1;
        if (!(data instanceof Post || data instanceof Array || data instanceof Timeline)) {
          return this;
        }
        ref = (function() {
          switch (false) {
            case !(data instanceof Post):
              return [data];
            case !(data instanceof Timeline):
              return data.posts;
            default:
              return data;
          }
        })();
        for (i = 0, len = ref.length; i < len; i++) {
          post = ref[i];
          combined = post;
        }
        ref1 = this.posts;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          post = ref1[j];
          combined.push(post);
        }
        return new Timeline(combined, (data instanceof Timeline ? data.type === this.type && data.query === this.query ? {
          type: this.type,
          query: this.query,
          before: (function() {
            switch (false) {
              case !(data.before >= this.before):
                return data.before;
              case !(data.before <= this.before):
                return this.before;
              default:
                return void 0;
            }
          }).call(this),
          after: (function() {
            switch (false) {
              case !(data.after <= this.after):
                return data.after;
              case !(data.after >= this.after):
                return this.after;
              default:
                return void 0;
            }
          }).call(this)
        } : {
          type: data.type === this.type ? this.type : Timeline.Type.UNDEFINED,
          query: "",
          before: void 0,
          after: void 0
        } : {
          type: this.type,
          query: this.query,
          before: this.before,
          after: this.after
        }));
      },
      remove: function(data) {
        var i, index, len, post, redacted, ref;
        if (!(data instanceof Post || data instanceof Array || data instanceof Timeline)) {
          return this;
        }
        redacted = (function() {
          var i, len, ref, results;
          ref = this.posts;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            post = ref[i];
            results.push(post);
          }
          return results;
        }).call(this);
        ref = ((function() {
          switch (false) {
            case !(data instanceof Post):
              return [data];
            case !(data instanceof Timeline):
              return data.posts;
            default:
              return data;
          }
        })());
        for (i = 0, len = ref.length; i < len; i++) {
          post = ref[i];
          if ((index = redacted.indexOf(post)) !== -1) {
            redacted.splice(index, 1);
          }
        }
        return new Timeline(redacted, {
          type: this.type,
          query: this.query,
          before: this.before,
          after: this.after
        });
      }
    })
  });

  Timeline.Type = Enumeral.generate({
    UNDEFINED: 0x00,
    HASHTAG: 0x10,
    LOCAL: 0x11,
    GLOBAL: 0x12,
    HOME: 0x22,
    NOTIFICATIONS: 0x23,
    FAVOURITES: 0x24,
    ACCOUNT: 0x40
  });

  LaboratoryEvent = {
    Events: {},
    Handlers: [],
    create: function(type, detail) {
      if (LaboratoryEvent.Events[type] == null) {
        LaboratoryEvent.Events[type] = {
          detail: Object(detail)
        };
      }
      return LaboratoryEvent;
    },
    associate: function(request, response, failure) {
      var levent;
      if (typeof (levent = LaboratoryEvent.Events[request]) !== "object") {
        return LaboratoryEvent;
      }
      if (response != null) {
        levent.response = response;
      }
      if (failure != null) {
        levent.failure = failure;
      }
      return LaboratoryEvent;
    },
    handle: function(type, callback) {
      if (LaboratoryEvent.Events[type = String(type)] == null) {
        return LaboratoryEvent;
      }
      callback.type = type;
      LaboratoryEvent.Handlers.push(callback);
      return LaboratoryEvent;
    }
  };

  Laboratory.dispatch = dispatch = function(event, props) {
    var detail, initial, initials, levent;
    if ((levent = LaboratoryEvent.Events[event = String(event)]) == null) {
      return false;
    }
    if (typeof (initials = levent.detail) === "function") {
      if (!((detail = props) instanceof initials)) {
        return false;
      }
    } else {
      detail = {};
      for (prop in initials) {
        initial = initials[prop];
        detail[prop] = (props != null) && (props[prop] != null) ? props[prop] : initial;
      }
    }
    document.dispatchEvent(new CustomEvent(event, {
      detail: Object.freeze(detail)
    }));
    return true;
  };

  Laboratory.listen = listen = function(event, callback) {
    var levent;
    if (!(((levent = LaboratoryEvent.Events[event = String(event)]) != null) && typeof callback === "function")) {
      return false;
    }
    document.addEventListener(event, callback);
    return true;
  };

  Laboratory.forget = forget = function(event, callback) {
    var levent;
    if (!(((levent = LaboratoryEvent.Events[event = String(event)]) != null) && typeof callback === "function")) {
      return false;
    }
    document.removeEventListener(event, callback);
    return true;
  };

  Laboratory.request = request = function(event, detail) {
    return new Promise(function(resolve, reject) {
      var fail, failure, levent, respond, response;
      if ((levent = LaboratoryEvent.Events[event]) == null) {
        return;
      }
      respond = function(detail) {
        if (typeof response !== "undefined" && response !== null) {
          forget(response, respond);
        }
        if (typeof failure !== "undefined" && failure !== null) {
          forget(failure, fail);
        }
        return resolve(detail);
      };
      fail = function(detail) {
        if (typeof response !== "undefined" && response !== null) {
          forget(response, respond);
        }
        if (typeof failure !== "undefined" && failure !== null) {
          forget(failure, fail);
        }
        return reject(detail);
      };
      if ((response = levent.response) != null) {
        listen(response, respond);
      }
      if ((failure = levent.failure) != null) {
        listen(failure, fail);
      }
      dispatch(event, detail);
    });
  };

  LaboratoryEvent.create("LaboratoryAttachmentRequested", {
    file: void 0
  }).create("LaboratoryAttachmentReceived", Attachment).create("LaboratoryAttachmentFailed", Failure).associate("LaboratoryAttachmentRequested", "LaboratoryAttachmentReceived", "LaboratoryAttachmentFailed").handle("LaboratoryAttachmentRequested", function(event) {
    var file, form, onComplete, onError;
    if (!((typeof File !== "undefined" && File !== null) && (file = event.detail.file) instanceof File)) {
      dispatch("LaboratoryAttachmentFailed", new Failure("Unable to create attachment; none provided", "LaboratoryAttachmentRequested"));
      return;
    }
    if (typeof FormData === "undefined" || FormData === null) {
      dispatch("LaboratoryAttachmentFailed", new Failure("Unable to create attachment; `FormData` is not supported on this platform"));
    }
    onComplete = function(response, data, params) {
      dispatch("LaboratoryAttachmentReceived", new Attachment(response));
    };
    onError = function(response, data, params) {
      dispatch("LaboratoryAttachmentFailed", new Failure(response.error, "LaboratoryAttachmentRequested", params.status));
    };
    serverRequest("POST", Store.auth.origin + "/api/v1/media", (form = new FormData, form.append("file", file), form), Store.auth.accessToken, onComplete, onError);
  });

  (function() {
    var recalledClient, recalledOrigin, recalledSecret;
    recalledOrigin = void 0;
    recalledClient = void 0;
    recalledSecret = void 0;
    return LaboratoryEvent.create("LaboratoryAuthorizationRequested", {
      name: "Laboratory",
      url: "/",
      redirect: "",
      scope: Authorization.Scope.READ
    }).create("LaboratoryAuthorizationReceived", Authorization).create("LaboratoryAuthorizationFailed", Failure).associate("LaboratoryAuthorizationRequested", "LaboratoryAuthorizationReceived", "LaboratoryAuthorizationFailed").create("LaboratoryAuthorizationGranted", {
      code: void 0,
      accessToken: void 0,
      origin: void 0,
      scope: Authorization.Scope.NONE
    }).handle("LaboratoryAuthorizationRequested", function(event) {
      var a, accessToken, clientID, clientSecret, handleClient, makeRequest, origin, redirect, ref, scope, storedRedirect, storedScope, timeout;
      if (!((scope = event.detail.scope) instanceof Authorization.Scope)) {
        scope = Authorization.Scope.READ;
      }
      a = document.createElement("a");
      a.href = event.detail.url;
      origin = a.origin;
      a.href = event.detail.redirect || "";
      redirect = a.href;
      makeRequest = function() {
        var key, value;
        window.open(origin + "/oauth/authorize?" + (((function() {
          var ref, results;
          ref = {
            client_id: clientID,
            response_type: "code",
            redirect_uri: redirect,
            scope: (function() {
              var scopeList;
              scopeList = [];
              if (scope & Authorization.Scope.READ) {
                scopeList.push("read");
              }
              if (scope & Authorization.Scope.WRITE) {
                scopeList.push("write");
              }
              if (scope & Authorization.Scope.FOLLOW) {
                scopeList.push("follow");
              }
              return scopeList.join(" ");
            })()
          };
          results = [];
          for (key in ref) {
            value = ref[key];
            results.push((encodeURIComponent(key)) + "=" + (encodeURIComponent(value)));
          }
          return results;
        })()).join("&")), "LaboratoryOAuth");
        recalledOrigin = origin;
        recalledClient = clientID;
        recalledSecret = clientSecret;
      };
      if (typeof localStorage !== "undefined" && localStorage !== null ? localStorage.getItem("Laboratory | " + origin) : void 0) {
        ref = (localStorage.getItem("Laboratory | " + origin)).split(" ", 5), storedRedirect = ref[0], clientID = ref[1], clientSecret = ref[2], storedScope = ref[3], accessToken = ref[4];
      }
      if (accessToken && (scope & storedScope) === +scope) {
        dispatch("LaboratoryAuthorizationGranted", {
          accessToken: accessToken,
          origin: origin,
          scope: scope
        });
        return;
      }
      if (storedRedirect === redirect && (scope & storedScope) === +scope && (clientID != null) && (clientSecret != null)) {
        makeRequest();
      } else {
        handleClient = function(e) {
          var client;
          if (!((client = e.detail) instanceof Client && client.origin === origin && (scope & client.scope) === +scope && client.redirect === redirect && (client.clientID != null) && (client.clientSecret != null))) {
            return;
          }
          clientID = client.clientID, clientSecret = client.clientSecret, scope = client.scope;
          localStorage.setItem("Laboratory | " + origin, [redirect, clientID, clientSecret, +scope].join(" "));
          forget("LaboratoryClientReceived", handleClient);
          clearTimeout(timeout);
          makeRequest();
        };
        listen("LaboratoryClientReceived", handleClient);
        dispatch("LaboratoryClientRequested", {
          name: event.detail.name,
          url: origin,
          redirect: redirect,
          scope: Authorization.Scope.fromValue(scope)
        });
        timeout = setTimeout((function() {
          forget("LaboratoryClientReceived", handleClient);
          dispatch("LaboratoryAuthorizationFailed", new Failure("Unable to authorize client", "LaboratoryAuthorizationRequested"));
        }), 30000);
      }
    }).handle("LaboratoryAuthorizationGranted", function(event) {
      var accessToken, cleintSecret, clientID, clientSecret, code, datetime, onComplete, onError, origin, redirect, ref, scope, tokenType, verify;
      (window.open("about:blank", "LaboratoryOAuth")).close();
      if (!(origin = event.detail.origin || recalledOrigin)) {
        dispatch("LaboratoryAuthorizationFailed", new Failure("Authorization data wasn't associated with an origin", "LaboratoryAuthorizationRequested"));
        return;
      }
      scope = event.detail.scope instanceof Authorization.Scope ? (function() {
        var scopeList;
        scopeList = [];
        if (scope & Authorization.Scope.READ) {
          scopeList.push("read");
        }
        if (scope & Authorization.Scope.WRITE) {
          scopeList.push("write");
        }
        if (scope & Authorization.Scope.FOLLOW) {
          scopeList.push("follow");
        }
        return scopeList.join(" ");
      })() : "";
      datetime = 0/0;
      tokenType = "bearer";
      verify = function() {
        var verifyComplete, verifyError;
        verifyComplete = function(response, data, params) {
          var scopes;
          dispatch("LaboratoryAuthorizationReceived", new Authorization({
            access_token: String(accessToken),
            created_at: String(+datetime),
            scope: scope,
            token_type: tokenType
          }, origin, response.id));
          localStorage.setItem("Laboratory | " + origin, [redirect, clientID, clientSecret, Authorization.Scope.READ * (((scopes = scope.split(/[\s\+]+/g)).indexOf("read")) !== -1) + Authorization.Scope.WRITE * ((scopes.indexOf("write")) !== -1) + Authorization.Scope.FOLLOW * ((scopes.indexOf("follow")) !== -1), accessToken].join(" "));
          dispatch("LaboratoryProfileReceived", new Profile(response));
        };
        verifyError = function(response, data, params) {
          dispatch("LaboratoryAuthorizationFailed", new Failure(response.error, "LaboratoryAuthorizationRequested", params.status));
        };
        return serverRequest("GET", origin + "/api/v1/accounts/verify_credentials", null, accessToken, verifyComplete, verifyError);
      };
      if (accessToken = event.detail.accessToken) {
        verify();
      } else if (code = event.detail.code) {
        if (origin = recalledOrigin) {
          clientID = recalledClient;
          cleintSecret = recalledSecret;
        } else {
          if (typeof localStorage !== "undefined" && localStorage !== null ? localStorage.getItem("Laboratory | " + origin) : void 0) {
            ref = (localStorage.getItem("Laboratory | " + origin)).split(" ", 5), redirect = ref[0], clientID = ref[1], clientSecret = ref[2];
          }
        }
        onComplete = function(response, data, params) {
          accessToken = response.access_token;
          datetime = new Date(response.created_at);
          scope = response.scope;
          tokenType = response.token_type;
          verify();
        };
        onError = function(response, data, params) {
          dispatch("LaboratoryAuthorizationFailed", new Failure(response.error, "LaboratoryAuthorizationRequested", params.status));
        };
        serverRequest("POST", origin + "/oauth/token", {
          client_id: clientID,
          client_secret: clientSecret,
          redirect_uri: redirect,
          grant_type: "authorization_code",
          code: code
        }, null, onComplete, onError);
      } else {
        dispatch("LaboratoryAuthorizationFailed", new Failure("No authorization code or access token was granted", "LaboratoryAuthorizationRequested"));
      }
      recalledOrigin = recalledClient = recalledSecret = void 0;
    }).handle("LaboratoryAuthorizationReceived", function(event) {
      if (!(event.detail instanceof Authorization)) {
        return;
      }
      Exposed.auth = Store.auth = event.detail;
    });
  })();

  LaboratoryEvent.create("LaboratoryClientRequested", {
    name: "Laboratory",
    url: "/",
    redirect: "",
    scope: Authorization.Scope.READ
  }).create("LaboratoryClientReceived", Client).create("LaboratoryClientFailed", Failure).associate("LaboratoryClientRequested", "LaboratoryClientReceived", "LaboratoryClientFailed").handle("LaboratoryClientRequested", function(event) {
    var a, onComplete, onError, origin, redirect, scope;
    if (!((scope = event.detail.scope) instanceof Authorization.Scope)) {
      scope = Authorization.Scope.READ;
    }
    a = document.createElement("a");
    a.href = event.detail.url;
    origin = a.origin;
    a.href = event.detail.redirect || "";
    redirect = a.href;
    onComplete = function(response, data, params) {
      dispatch("LaboratoryClientReceived", new Client(response, data, origin));
    };
    onError = function(response, data, params) {
      dispatch("LaboratoryClientFailed", new Failure(response.error, "LaboratoryClientRequested", params.status));
    };
    return serverRequest("POST", origin + "/api/v1/apps", {
      client_name: event.detail.name,
      redirect_uris: event.detail.redirect,
      scopes: (function() {
        var scopeList;
        scope = event.detail.scope;
        scopeList = [];
        if (scope & Authorization.Scope.READ) {
          scopeList.push("read");
        }
        if (scope & Authorization.Scope.WRITE) {
          scopeList.push("write");
        }
        if (scope & Authorization.Scope.FOLLOW) {
          scopeList.push("follow");
        }
        return scopeList.join(" ");
      })()
    }, null, onComplete, onError);
  });

  LaboratoryEvent.create("LaboratoryInitializationLoaded").create("LaboratoryInitializationReady");

  LaboratoryEvent.create("LaboratoryPostRequested", {
    id: void 0,
    type: Post.Type.STATUS
  }).create("LaboratoryPostReceived", Post).create("LaboratoryPostFailed", Failure).associate("LaboratoryPostRequested", "LaboratoryPostReceived", "LaboratoryPostFailed").create("LaboratoryPostCreation", {
    text: "",
    visibility: Post.Visibility.PRIVATE,
    inReplyTo: void 0,
    attachments: void 0,
    message: void 0,
    makeNSFW: true
  }).create("LaboratoryPostDeletion", {
    id: void 0
  }).create("LaboratoryPostSetReblog", {
    id: void 0,
    value: true
  }).create("LaboratoryPostSetFavourite", {
    id: void 0,
    value: true
  }).handle("LaboratoryPostRequested", function(event) {
    var id, isANotification, onComplete, onError, type;
    if (!isFinite(id = Number(event.detail.id))) {
      dispatch("LaboratoryPostFailed", new Failure("Unable to fetch post; no id specified", "LaboratoryPostRequested"));
      return;
    }
    if (!((type = event.detail.type) instanceof Post.Type)) {
      dispatch("LaboratoryPostFailed", new Failure("Unable to fetch post; no type specified", "LaboratoryPostRequested"));
      return;
    }
    isANotification = type & Post.Type.Notification;
    if (!isANotification && (Store.statuses[id] != null)) {
      dispatch("LaboratoryPostReceived", Store.statuses[id]);
    }
    if (isANotification && (Store.notifications[id] != null)) {
      dispatch("LaboratoryPostReceived", Store.notifications[id]);
    }
    onComplete = function(response, data, params) {
      var post, store;
      if (response.id !== id) {
        dispatch("LaboratoryPostFailed", new Failure("Unable to fetch post; returned post did not match requested id", "LaboratoryPostRequested"));
        return;
      }
      post = new Post(response);
      if ((post.type & Post.Type.NOTIFICATION) !== isANotification) {
        dispatch("LaboratoryPostFailed", new Failure("Unable to fetch post; returned post was not of specified type", "LaboratoryPostRequested"));
        return;
      }
      store = isANotification ? Store.notifications : Store.statuses;
      if (!post.compare(store[id])) {
        dispatch("LaboratoryPostReceived", post);
      }
    };
    onError = function(response, data, params) {
      dispatch("LaboratoryPostFailed", new Failure(response.error, "LaboratoryPostRequested", params.status));
    };
    serverRequest("GET", Store.auth.origin + (isANotification ? "/api/v1/notifications/" : "/api/v1/statuses/") + id, null, Store.auth.accessToken, onComplete, onError);
  }).handle("LaboratoryPostReceived", function(event) {
    var id;
    if (!(event.detail instanceof Post && event.detail.type instanceof Post.Type && isFinite(id = Number(event.detail.id)))) {
      return;
    }
    (event.detail.type & Post.Type.NOTIFICATION ? Store.notifications : Store.statuses)[id] = event.detail;
  }).handle("LaboratoryPostCreation", function(event) {
    var attachment, attachments, inReplyTo, message, onComplete, onError;
    onComplete = function(response, data, params) {
      dispatch("LaboratoryPostReceived", new Post(response));
    };
    onError = function(response, data, params) {
      dispatch("LaboratoryPostFailed", new Failure(response.error, "LaboratoryPostCreation", params.status));
    };
    return serverRequest("POST", Store.auth.origin + "/api/v1/statuses/", {
      status: event.detail.text,
      in_reply_to_id: (inReplyTo = event.detail.inReplyTo) > 0 && isFinite(inReplyTo) ? inReplyTo : void 0,
      media_ids: (attachments = event.detail.attachments) instanceof Array ? (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = attachments.length; i < len; i++) {
          attachment = attachments[i];
          if (attachment instanceof Attachment) {
            results.push(attachment.id);
          }
        }
        return results;
      })() : void 0,
      sensitive: event.detail.makeNSFW ? "true" : void 0,
      spoiler_text: (message = event.detail.message) ? String(message) : void 0,
      visibility: (function() {
        switch (event.detail.visibility) {
          case Post.Visibility.PUBLIC:
            return "public";
          case Post.Visibility.REBLOGGABLE:
            return "unlisted";
          default:
            return "private";
        }
      })()
    }, Store.auth.accessToken, onComplete, onError);
  }).handle("LaboratoryPostDeletion", function(event) {
    var id, onComplete, onError;
    if (!isFinite(id = Number(event.detail.id))) {
      dispatch("LaboratoryPostFailed", new Failure("Unable to delete post; no id specified", "LaboratoryPostDeletion"));
      return;
    }
    onComplete = function() {};
    onError = function(response, data, params) {
      dispatch("LaboratoryPostFailed", new Failure(response.error, "LaboratoryPostDeletion", params.status));
    };
    return serverRequest("DELETE", Store.auth.origin + "/api/v1/statuses/" + id, null, Store.auth.accessToken, onComplete, onError);
  }).handle("LaboratoryPostSetReblog", function(event) {
    var id, onComplete, onError, ref, value;
    if (!(((value = !!event.detail.value) != null) && isFinite(id = Number(event.detail.id)))) {
      dispatch("LaboratoryPostFailed", new Failure("Cannot set reblog status for post: Either value or id is missing", "LaboratoryPostSetReblog"));
    }
    onComplete = function(response, data, params) {
      dispatch("LaboratoryPostReceived", new Post(response));
    };
    onError = function(response, data, params) {
      dispatch("LaboratoryPostFailed", new Failure(response.error, "LaboratoryPostSetReblog", params.status));
    };
    if (((ref = Store.statuses[id]) != null ? ref.isReblogged : void 0) !== value) {
      serverRequest("POST", Store.auth.origin + "/api/v1/statuses/" + id + (value ? "/reblog" : "/unreblog"), null, Store.auth.accessToken, onComplete, onError);
    }
  }).handle("LaboratoryPostSetFavourite", function(event) {
    var id, onComplete, onError, ref, value;
    if (!(((value = !!event.detail.value) != null) && isFinite(id = Number(event.detail.id)))) {
      dispatch("LaboratoryPostFailed", new Failure("Cannot set favourite status for post: Either value or id is missing", "LaboratoryPostSetFavourite"));
    }
    onComplete = function(response, data, params) {
      dispatch("LaboratoryPostReceived", new Post(response));
    };
    onError = function(response, data, params) {
      dispatch("LaboratoryPostFailed", new Failure(response.error, "LaboratoryPostSetFavourite", params.status));
    };
    if (((ref = Store.statuses[id]) != null ? ref.isFavourited : void 0) !== value) {
      serverRequest("POST", Store.auth.origin + "/api/v1/statuses/" + id + (value ? "/favourite" : "/unfavourite"), null, Store.auth.accessToken, onComplete, onError);
    }
  });

  LaboratoryEvent.create("LaboratoryProfileRequested", {
    id: void 0,
    requestRelationships: true
  }).create("LaboratoryProfileReceived", Profile).create("LaboratoryProfileFailed", Failure).associate("LaboratoryProfileRequested", "LaboratoryProfileReceived", "LaboratoryProfileFailed").create("LaboratoryProfileSetRelationship", {
    id: void 0,
    relationship: void 0
  }).handle("LaboratoryProfileRequested", function(event) {
    var id, onComplete, onError, onRelationshipsComplete;
    if (!isFinite(id = Number(event.detail.id))) {
      dispatch("LaboratoryProfileFailed", new Failure("Unable to fetch profile; no id specified", "LaboratoryProfileRequested"));
      return;
    }
    if (Store.profiles[id] != null) {
      dispatch("LaboratoryProfileReceived", Store.profiles[id]);
    }
    onComplete = function(response, data, params) {
      var profile;
      if (response.id !== id) {
        dispatch("LaboratoryProfileFailed", new Failure("Unable to fetch profile; returned profile did not match requested id", "LaboratoryProfileRequested"));
        return;
      }
      profile = new Profile(response);
      if (!profile.compare(Store.profiles[id])) {
        dispatch("LaboratoryProfileReceived", profile);
      }
      if (event.detail.requestRelationships) {
        serverRequest("GET", Store.auth.origin + "/api/v1/accounts/relationships", {
          id: id
        }, Store.auth.accessToken, onRelationshipsComplete, onError);
      }
    };
    onRelationshipsComplete = function(response, data, params) {
      var ref, relationship, relationships;
      relationships = response[0];
      if (((ref = Store.profiles[id]) != null ? ref.relationship : void 0) === (relationship = Profile.Relationship.fromValue((Profile.Relationship.FOLLOWER * relationships.followed_by + Profile.Relationship.FOLLOWING * relationships.following + Profile.Relationship.REQUESTED * relationships.requested + Profile.Relationship.BLOCKING * relationships.blocking + Profile.Relationship.MUTING * relationships.muting + Profile.Relationship.SELF * (relationships.id === Store.auth.me)) || Profile.Relationship.UNKNOWN))) {
        return;
      }
      dispatch("LaboratoryProfileReceived", new Profile(Store.profiles[id], relationship));
    };
    onError = function(response, data, params) {
      dispatch("LaboratoryProfileFailed", new Failure(response.error, "LaboratoryProfileRequested", params.status));
    };
    serverRequest("GET", Store.auth.origin + "/api/v1/accounts/" + id, null, Store.auth.accessToken, onComplete, onError);
  }).handle("LaboratoryProfileReceived", function(event) {
    var id;
    if (!(event.detail instanceof Profile && isFinite(id = Number(event.detail.id)))) {
      return;
    }
    Store.profiles[id] = event.detail;
  }).handle("LaboratoryProfileSetRelationship", function(event) {
    var changes, id, onComplete, onError, profile, relationship;
    if (!((relationship = event.detail.relationship) instanceof Profile.Relationship && isFinite(id = Number(event.detail.id)))) {
      dispatch("LaboratoryProfileFailed", new Failure("Cannot set relationship for account: Either relationship or id is missing", "LaboratoryProfileSetRelationship"));
    }
    onComplete = function(response, data, params) {
      dispatch("LaboratoryProfileReceived", new Profile(response));
    };
    onError = function(response, data, params) {
      dispatch("LaboratoryProfileFailed", new Failure(response.error, "LaboratoryProfileSetRelationship", params.status));
    };
    if ((profile = Store.profiles[id]) instanceof Profile) {
      changes = profile.relationship ^ relationship;
      if (changes & Profile.FOLLOWING) {
        serverRequest("POST", Store.auth.origin + "/api/v1/accounts/" + id + (relationship & Profile.FOLLOWING ? "/follow" : "/unfollow"), null, Store.auth.accessToken, onComplete, onError);
      } else if (changes & Profile.REQUESTED) {
        serverRequest("POST", Store.auth.origin + "/api/v1/accounts/" + id + (relationship & Profile.REQUESTED ? "/follow" : "/unfollow"), null, Store.auth.accessToken, onComplete, onError);
      }
      if (changes & Profile.BLOCKING) {
        serverRequest("POST", Store.auth.origin + "/api/v1/accounts/" + id + (relationship & Profile.BLOCKING ? "/block" : "/unblock"), null, Store.auth.accessToken, onComplete, onError);
      }
      if (changes & Profile.MUTING) {
        serverRequest("POST", Store.auth.origin + "/api/v1/accounts/" + id + (relationship & Profile.MUTING ? "/mute" : "/unmute"), null, Store.auth.accessToken, onComplete, onError);
      }
    } else {
      serverRequest("POST", Store.auth.origin + "/api/v1/accounts/" + id + (relationship & Profile.FOLLOWING || relationship & Profile.REQUESTED ? "/follow" : "/unfollow"), null, Store.auth.accessToken, onComplete, onError);
      serverRequest("POST", Store.auth.origin + "/api/v1/accounts/" + id + (relationship & Profile.BLOCKING ? "/block" : "/unblock"), null, Store.auth.accessToken, onComplete, onError);
      serverRequest("POST", Store.auth.origin + "/api/v1/accounts/" + id + (relationship & Profile.MUTING ? "/mute" : "/unmute"), null, Store.auth.accessToken, onComplete, onError);
    }
  });

  LaboratoryEvent.create("LaboratoryRequestOpen", XMLHttpRequest).create("LaboratoryRequestUpdate", XMLHttpRequest).create("LaboratoryRequestComplete", XMLHttpRequest).create("LaboratoryRequestError", XMLHttpRequest);

  LaboratoryEvent.create("LaboratoryRolodexRequested", {
    type: Rolodex.Type.SEARCH,
    query: "",
    before: void 0,
    after: void 0,
    limit: void 0
  }).create("LaboratoryRolodexReceived", Rolodex).create("LaboratoryRolodexFailed", Failure).associate("LaboratoryRolodexRequested", "LaboratoryRolodexReceived", "LaboratoryRolodexFailed").handle("LaboratoryRolodexRequested", function(event) {
    var after, before, limit, onComplete, onError, query, type;
    query = String(event.detail.query);
    if (!isFinite(limit = Number(event.detail.limit))) {
      limit = null;
    }
    if (!isFinite(before = Number(event.detail.before))) {
      before = null;
    }
    if (!isFinite(after = Number(event.detail.after))) {
      after = null;
    }
    if (!((type = event.detail.type) instanceof Rolodex.Type && type !== Rolodex.Type.UNDEFINED)) {
      dispatch("LaboratoryRolodexFailed", new Failure("Unable to fetch rolodex; no type specified", "LaboratoryRolodexRequested"));
      return;
    }
    onComplete = function(response, data, params) {
      var account, i, ids, len;
      ids = [];
      for (i = 0, len = response.length; i < len; i++) {
        account = response[i];
        if ((ids.indexOf(account.id)) === -1 && ids.push(account.id)) {
          dispatch("LaboratoryProfileReceived", account);
        }
      }
      dispatch("LaboratoryRolodexReceived", new Rolodex(response, {
        type: type,
        query: query,
        before: ((params.prev.match(/.*since_id=([0-9]+)/)) || [])[1],
        after: ((params.next.match(/.*max_id=([0-9]+)/)) || [])[1]
      }));
    };
    onError = function(response, data, params) {
      dispatch("LaboratoryRolodexFailed", new Failure(response.error, "LaboratoryRolodexRequested", params.status));
    };
    serverRequest("GET", Store.auth.origin + ((function() {
      switch (type) {
        case Rolodex.Type.SEARCH:
          return "/api/v1/accounts/search";
        case Rolodex.Type.FOLLOWERS:
          return "/api/v1/accounts/" + query + "/followers";
        case Rolodex.Type.FOLLOWING:
          return "/api/v1/accounts/" + query + "/following";
        case Rolodex.Type.FAVOURITED_BY:
          return "/api/v1/statuses/" + query + "/favourited_by";
        case Rolodex.Type.REBLOGGED_BY:
          return "/api/v1/statuses/" + query + "/reblogged_by";
        case Rolodex.Type.BLOCKS:
          return "/api/v1/blocks";
        case Rolodex.Type.MUTES:
          return "/api/v1/mutes";
        default:
          return "/api/v1";
      }
    })()), ((function() {
      switch (type) {
        case Rolodex.Type.SEARCH:
          return {
            q: query,
            limit: limit
          };
        case Rolodex.Type.FOLLOWERS:
        case Rolodex.Type.FOLLOWING:
        case Rolodex.Type.FAVOURITED_BY:
        case Rolodex.Type.REBLOGGED_BY:
        case Rolodex.Type.BLOCKS:
        case Rolodes.Type.MUTES:
          return {
            max_id: before,
            since_id: after
          };
        default:
          return null;
      }
    })()), Store.auth.accessToken, onComplete, onError);
  });

  LaboratoryEvent.create("LaboratoryTimelineRequested", {
    type: Timeline.Type.HOME,
    query: "",
    before: void 0,
    after: void 0
  }).create("LaboratoryTimelineReceived", Timeline).create("LaboratoryTimelineFailed", Failure).associate("LaboratoryTimelineRequested", "LaboratoryTimelineReceived", "LaboratoryTimelineFailed").handle("LaboratoryTimelineRequested", function(event) {
    var after, before, onComplete, onError, query, type;
    query = String(event.detail.query);
    if (!isFinite(before = Number(event.detail.before))) {
      before = null;
    }
    if (!isFinite(after = Number(event.detail.after))) {
      after = null;
    }
    if (!((type = event.detail.type) instanceof Timeline.Type && type !== Timeline.Type.UNDEFINED)) {
      dispatch("LaboratoryTimelineFailed", new Failure("Unable to fetch timeline; no type specified", "LaboratoryTimelineRequested"));
      return;
    }
    onComplete = function(response, data, params) {
      var account, acctIDs, i, ids, j, k, len, len1, len2, mention, mentionIDs, mentions, ref, ref1, ref2, status;
      acctIDs = [];
      mentions = [];
      mentionIDs = [];
      ids = [];
      for (i = 0, len = response.length; i < len; i++) {
        status = response[i];
        if (!((ids.indexOf(status.id)) === -1 && ids.push(status.id))) {
          continue;
        }
        if ((acctIDs.indexOf(status.account.id)) === -1 && acctIDs.push(status.account.id)) {
          dispatch("LaboratoryProfileReceived", new Profile(status.account));
        }
        if ((((ref = status.status) != null ? ref.account : void 0) != null) && (acctIDs.indexOf(status.status.account.id)) === -1 && acctIDs.push(status.status.account.id)) {
          dispatch("LaboratoryProfileReceived", new Profile(status.status.account));
        }
        if ((((ref1 = status.reblog) != null ? ref1.account : void 0) != null) && (acctIDs.indexOf(status.reblog.account.id)) === -1 && acctIDs.push(status.reblog.account.id)) {
          dispatch("LaboratoryProfileReceived", new Profile(status.reblog.account));
        }
        if (status.mentions instanceof Array) {
          ref2 = status.mentions;
          for (j = 0, len1 = ref2.length; j < len1; j++) {
            account = ref2[j];
            if (!((mentionIDs.indexOf(account.id)) === -1)) {
              continue;
            }
            mentionIDs.push(account.id);
            mentions.push(account);
          }
        }
        dispatch("LaboratoryPostReceived", new Post(status));
      }
      for (k = 0, len2 = mentions.length; k < len2; k++) {
        mention = mentions[k];
        if ((acctIDs.indexOf(mention.id)) === -1 && (Store.profiles[mention.id] == null)) {
          dispatch("LaboratoryProfileReceived", new Profile(mention));
        }
      }
      dispatch("LaboratoryTimelineReceived", new Timeline(response, {
        type: type,
        query: query,
        before: ((params.prev.match(/.*since_id=([0-9]+)/)) || [])[1],
        after: ((params.next.match(/.*max_id=([0-9]+)/)) || [])[1]
      }));
    };
    onError = function(response, data, params) {
      dispatch("LaboratoryTimelineFailed", new Failure(response.error, "LaboratoryTimelineRequested", params.status));
    };
    serverRequest("GET", Store.auth.origin + ((function() {
      switch (type) {
        case Timeline.Type.HASHTAG:
          return "/api/v1/timelines/tag/" + query;
        case Timeline.Type.LOCAL:
          return "/api/v1/timelines/public";
        case Timeline.Type.GLOBAL:
          return "/api/v1/timelines/public";
        case Timeline.Type.HOME:
          return "/api/v1/timelines/home";
        case Timeline.Type.NOTIFICATIONS:
          return "/api/v1/notifications";
        case Timeline.Type.FAVOURITES:
          return "/api/v1/favourites";
        case Timeline.Type.ACCOUNT:
          return "/api/v1/accounts/" + query + "/statuses";
        default:
          return "/api/v1";
      }
    })()), ((function() {
      switch (type) {
        case Timeline.Type.LOCAL:
          return {
            local: true,
            max_id: before,
            since_id: after
          };
        default:
          return {
            max_id: before,
            since_id: after
          };
      }
    })()), Store.auth.accessToken, onComplete, onError);
  });

  Store = {
    auth: null,
    notifications: {},
    profiles: {},
    statuses: {}
  };

  window["🏪"] = Store;

  Object.defineProperty(window, "Laboratory", {
    value: Object.freeze(Laboratory),
    enumerable: true
  });

  dispatch("LaboratoryInitializationLoaded");

  run = function() {
    var handler, i, len, ref;
    ref = LaboratoryEvent.Handlers;
    for (i = 0, len = ref.length; i < len; i++) {
      handler = ref[i];
      listen(handler.type, handler);
    }
    Exposed.ready = true;
    dispatch("LaboratoryInitializationReady");
  };

  if (document.readyState === "complete") {
    run();
  } else {
    window.addEventListener("load", run);
  }

}).call(this);
