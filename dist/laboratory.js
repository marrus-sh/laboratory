// Generated by CoffeeScript 1.12.4
(function() {
  "use strict";

  /*
  
      ............. LABORATORY ..............
  
      A client-side API for Mastodon, a free,
         open-source social network server
                - - by Kibigo! - -
  
          Licensed under the MIT License.
             Source code available at:
      https://github.com/marrus-sh/laboratory
  
                  Version 0.5.0
   */
  var Application, Attachment, Authorization, Client, CustomEvent, Enumeral, Exposed, Failure, Laboratory, LaboratoryEvent, Post, Profile, Request, Rolodex, Store, Timeline, checkDecree, decree, dispatch, fn, give, isArray, police, prop, reflection, reset, run,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Laboratory = {
    ℹ: "https://github.com/marrus-sh/laboratory",
    Nº: 5.0
  };

  (function() {
    var Mommy, code;
    if ((code = (location.search.match(/code=([^&]*)/) || [])[1]) && (Mommy = window.opener)) {
      return Mommy.postMessage(code, window.location.origin);
    }
  })();

  Exposed = {
    ready: false,
    auth: null
  };

  fn = function(prop) {
    return Object.defineProperty(Laboratory, prop, {
      enumerable: true,
      configurable: false,
      get: function() {
        return Exposed[prop];
      }
    });
  };
  for (prop in Exposed) {
    fn(prop);
  }

  decree = police = checkDecree = null;

  (function() {
    var isPrivileged;
    isPrivileged = false;
    decree = function(callback) {
      var result, wasPrivileged;
      wasPrivileged = isPrivileged;
      isPrivileged = true;
      result = callback();
      isPrivileged = wasPrivileged;
      return result;
    };
    police = function(callback) {
      var result, wasPrivileged;
      wasPrivileged = isPrivileged;
      isPrivileged = false;
      result = callback();
      isPrivileged = wasPrivileged;
      return result;
    };
    return checkDecree = function() {
      return isPrivileged;
    };
  })();

  CustomEvent = (function() {
    var CE;
    if (typeof window.CustomEvent === "function") {
      return window.CustomEvent;
    }
    CE = function(event, params) {
      var e;
      params = params || {
        bubbles: false,
        cancelable: false,
        detail: void 0
      };
      e = document.createEvent("CustomEvent");
      e.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return e;
    };
    CE.prototype = Object.freeze(Object.create(window.Event.prototype));
    return Object.freeze(CE);
  })();

  reflection = function() {
    return this;
  };

  give = function(n) {
    return reflection.bind(n);
  };

  isArray = typeof Array.isArray === "function" ? Array.isArray : function(n) {
    return (Object.prototype.toString.call(n)) === "[object Array]";
  };

  Enumeral = function(value) {
    if (!(this && this instanceof Enumeral)) {
      throw new TypeError("this is not a Enumeral");
    }
    this.value = value | 0;
    return Object.freeze(this);
  };

  Laboratory.Enumeral = function(value) {
    throw new TypeError("Illegal constructor");
  };

  Object.defineProperty(Enumeral, "prototype", {
    configurable: false,
    enumerable: false,
    writable: false,
    value: Object.freeze(Object.defineProperties({}, {
      constructor: {
        enumerable: false,
        value: Laboratory.Enumeral
      },
      toString: {
        enumerable: false,
        value: function() {
          return "Enumeral(" + this.value + ")";
        }
      },
      toSource: {
        enumerable: false,
        value: function() {
          return "Enumeral(" + this.value + ")";
        }
      },
      valueOf: {
        enumerable: false,
        value: function() {
          return this.value;
        }
      }
    }))
  });

  Object.defineProperty(Laboratory.Enumeral, "prototype", {
    configurable: false,
    enumerable: false,
    writable: false,
    value: Enumeral.prototype
  });

  Enumeral.generate = function(data) {
    var byValue, enumeral, type, value;
    type = function(n) {
      return Enumeral.call(this, n);
    };
    type.prototype = Object.create(Enumeral.prototype);
    byValue = {};
    for (enumeral in data) {
      if (!hasProp.call(data, enumeral)) continue;
      value = data[enumeral];
      if (byValue[value] != null) {
        continue;
      }
      type[enumeral] = new type(value);
      byValue[value] = type[enumeral];
    }
    type.fromValue = function(n) {
      return byValue[n | 0];
    };
    return Object.freeze(type);
  };

  Laboratory.Application = Application = function(data) {
    if (!(this && this instanceof Application)) {
      throw new TypeError("this is not an Application");
    }
    if (data == null) {
      throw new TypeError("Unable to create Application; no data provided");
    }
    this.name = data.name;
    this.href = data.website;
    return Object.freeze(this);
  };

  Object.defineProperty(Application, "prototype", {
    value: Object.freeze({})
  });

  Laboratory.Attachment = Attachment = function(data) {
    if (!(this && this instanceof Attachment)) {
      throw new TypeError("this is not an Attachment");
    }
    if (data == null) {
      throw new TypeError("Unable to create Attachment; no data provided");
    }
    this.id = Number(data.id);
    this.href = String(data.url);
    this.preview = String(data.preview_url);
    this.type = (function() {
      switch (data.type) {
        case "image":
          return Attachment.Type.IMAGE;
        case "video":
          return Attachment.Type.VIDEO;
        case "gifv":
          return Attachment.Type.GIFV;
        default:
          return Attachment.Type.UNKNOWN;
      }
    })();
    return Object.freeze(this);
  };

  Object.defineProperty(Attachment, "prototype", {
    value: Object.freeze({})
  });

  Attachment.Type = Enumeral.generate({
    UNKNOWN: 0x0,
    PHOTO: 0x1,
    VIDEO: 0x2,
    GIFV: 0x3
  });

  Laboratory.Authorization = Authorization = function(data, origin, me) {
    var scopes;
    if (!(this && this instanceof Authorization)) {
      throw new TypeError("this is not an Authorization");
    }
    if (data == null) {
      throw new TypeError("Unable to create Authorization; no data provided");
    }
    this.origin = String(origin);
    this.accessToken = String(data.access_token);
    this.datetime = new Date(data.created_at);
    this.scope = Authorization.Scope.fromValue(Authorization.Scope.READ * (indexOf.call((scopes = (String(data.scope)).split(/[\s\+]+/g)), "read") < 0) + Authorization.Scope.WRITE * (indexOf.call(scopes, "write") < 0) + Authorization.Scope.FOLLOW * (indexOf.call(scopes, "follow") < 0));
    this.tokenType = String(data.tokenType);
    this.me = +me;
    return Object.freeze(this);
  };

  Object.defineProperty(Authorization, "prototype", {
    value: Object.freeze({})
  });

  Authorization.Scope = Enumeral.generate({
    NONE: 0x0,
    READ: 0x1,
    WRITE: 0x2,
    READWRITE: 0x3,
    FOLLOW: 0x4,
    READFOLLOW: 0x5,
    WRITEFOLLOW: 0x6,
    READWRITEFOLLOW: 0x7
  });

  Laboratory.Client = Client = function(data, origin, name, scope) {
    if (!(this && this instanceof Client)) {
      throw new TypeError("this is not a Client");
    }
    if (data == null) {
      throw new TypeError("Unable to create Client; no data provided");
    }
    this.origin = origin;
    this.name = name;
    this.id = data.id;
    this.clientID = data.client_id;
    this.clientSecret = data.client_secret;
    this.scope = scope;
    this.redirect = data.redirect_uri;
    return Object.freeze(this);
  };

  Object.defineProperty(Client, "prototype", {
    value: Object.freeze({})
  });

  Laboratory.Failure = Failure = function(data, code) {
    if (!(this && this instanceof Failure)) {
      throw new TypeError("this is not a Failure");
    }
    if (data == null) {
      throw new TypeError("Unable to create Failure; no data provided");
    }
    this.error = String(data.error);
    if (!isFinite(this.code = Number(code))) {
      this.code = null;
    }
    return Object.freeze(this);
  };

  Object.defineProperty(Failure, "prototype", {
    value: Object.freeze({})
  });

  Laboratory.Post = Post = function(data) {
    var fromID, getProfile, item, profiles;
    if (!(this && this instanceof Post)) {
      throw new TypeError("this is not a Post");
    }
    if (data == null) {
      throw new TypeError("Unable to create Post; no data provided");
    }
    profiles = Store.profiles;
    getProfile = function(id) {
      return profiles[id];
    };
    if (data.type != null) {
      this.id = data.id;
      fromID = data.account.id;
      if (data.status) {
        switch (data.type) {
          case "reblog":
            this.type = Post.Type.REBLOG;
            Object.defineProperty(this, "rebloggedBy", {
              get: getProfile.bind(this, fromID),
              enumerable: true
            });
            break;
          case "favourite":
            this.type = Post.Type.FAVOURITE;
            Object.defineProperty(this, "favouritedBy", {
              get: getProfile.bind(this, fromID),
              enumerable: true
            });
            break;
          case "mention":
            this.type = Post.Type.MENTION;
            break;
          default:
            this.type = Post.Type.REACTION;
        }
        data = data.status;
      } else {
        Object.defineProperty(this, "author", {
          get: getProfile.bind(this, fromID),
          enumerable: true
        });
        switch (data.type) {
          case "follow":
            this.type = Post.Type.FOLLOW;
            break;
          default:
            this.type = Post.Type.NOTIFICATION;
        }
        return Object.freeze(this);
      }
    } else {
      this.type = Post.Type.STATUS;
      this.id = data.id;
      if (data.reblog) {
        Object.defineProperty(this, "rebloggedBy", {
          get: getProfile.bind(this, data.account.id),
          enumerable: true
        });
        data = data.reblog;
      }
    }
    this.uri = String(data.uri);
    this.href = String(data.url);
    Object.defineProperty(this, "author", {
      get: getProfile.bind(this, data.account.id),
      enumerable: true
    });
    this.inReplyTo = Number(data.in_reply_to_id);
    this.content = String(data.content);
    this.datetime = new Date(data.created_at);
    this.reblogCount = Number(data.reblogs_count);
    this.favouriteCount = Number(data.favourites_count);
    this.isReblogged = !!data.reblogged;
    this.isFavourited = !!data.favourited;
    this.isNSFW = !!data.sensitive;
    this.message = String(data.spoiler_text);
    this.visibility = {
      direct: Post.Visibility.DIRECT,
      "private": Post.Visibility.IN_HOME,
      unlisted: Post.Visibility.UNLISTED,
      "public": Post.Visibility.PUBLIC
    }[data.visibility] || Post.Visibility.IN_HOME;
    this.mediaAttachments = (function() {
      var i, len, ref, results;
      ref = data.media_attachments;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        results.push(new Attachment(item));
      }
      return results;
    })();
    this.mentions = (function(_this) {
      return function() {
        var i, index, len, mention, mentions, ref;
        mentions = [];
        ref = data.mentions;
        for (index = i = 0, len = ref.length; i < len; index = ++i) {
          mention = ref[index];
          Object.defineProperty(mentions, index, {
            enumerable: true,
            get: getProfile.bind(_this, mention.id)
          });
        }
        return Object.freeze(mentions);
      };
    })(this)();
    this.application = data.application != null ? new Application(data.application) : null;
    return Object.freeze(this);
  };

  Object.defineProperty(Post, "prototype", {
    value: Object.freeze({
      compare: function(other) {
        if (!(this instanceof Post && other instanceof Post)) {
          return false;
        }
        return this.type === other.type && this.id === other.id && this.reblogCount === other.reblogCount && this.favouriteCount === other.favouriteCount && this.isReblogged === other.isReblogged && this.isFavourited === other.isFavourited;
      }
    })
  });

  Post.Type = Enumeral.generate({
    UNKNOWN: 0x00,
    STATUS: 0x10,
    NOTIFICATION: 0x20,
    FOLLOW: 0x21,
    REACTION: 0x30,
    FAVOURITE: 0x31,
    REBLOG: 0x32,
    MENTION: 0x33
  });

  Post.Visibility = Enumeral.generate({
    DIRECT: 0x0,
    REBLOGGABLE: 0x1,
    IN_HOME: 0x2,
    UNLISTED: 0x3,
    LISTED: 0x4,
    NOT_IN_HOME: 0x5,
    UNREBLOGGABLE: 0x6,
    PUBLIC: 0x7
  });

  Laboratory.Profile = Profile = function(data, relationship) {
    var origin, ref;
    if (!(this && this instanceof Profile)) {
      throw new TypeError("this is not a Profile");
    }
    if (data == null) {
      throw new TypeError("Unable to create Profile; no data provided");
    }
    if (relationship == null) {
      relationship = (ref = Store.profiles[data.id]) != null ? ref.relationship : void 0;
    }
    if (data instanceof Profile) {
      this.id = data.id, this.username = data.username, this.account = data.account, this.localAccount = data.localAccount, this.displayName = data.displayName, this.bio = data.bio, this.href = data.href, this.avatar = data.avatar, this.header = data.header, this.isLocked = data.isLocked, this.followerCount = data.followerCount, this.followingCount = data.followingCount, this.statusCount = data.statusCount, this.relationship = data.relationship;
    } else {
      this.id = Number(data.id);
      this.username = String(data.username);
      this.account = String(data.acct + (((origin = Store.auth.origin) != null) && indexOf.call(data.acct, "@") < 0 ? "@" + origin.substr(8) : ""));
      this.localAccount = String(data.acct);
      this.displayName = String(data.display_name);
      this.bio = String(data.note);
      this.href = String(data.url);
      this.avatar = String(data.avatar);
      this.header = String(data.header);
      this.isLocked = !!data.locked;
      this.followerCount = Number(data.followers_count);
      this.followingCount = Number(data.following_count);
      this.statusCount = Number(data.statuses_count);
      this.relationship = data.id === Store.auth.me ? Profile.Relationship.SELF : Profile.Relationship.UNKNOWN;
    }
    if (relationship != null) {
      this.relationship = Profile.Relationship.fromValue(relationship) || this.relationship;
    }
    return Object.freeze(this);
  };

  Object.defineProperty(Profile, "prototype", {
    value: Object.freeze({
      compare: function(other) {
        if (!(this instanceof Profile && other instanceof Profile)) {
          return false;
        }
        return this.id === other.id && this.relationship === other.relationship && this.followerCount === other.followerCount && this.followingCount === other.followingCount && this.statusCount === other.statusCount && this.bio === other.bio && this.displayName === other.displayName && this.avatar === other.avatar && this.header === other.header && this.isLocked === other.isLocked && this.username === other.username && this.localAccount === other.localAccount && this.account === other.account && this.href === other.href;
      }
    })
  });

  Profile.Relationship = Enumeral.generate({
    NOT_FOLLOWING: 0x0,
    FOLLOWER: 0x1,
    FOLLOWING: 0x2,
    MUTUAL: 0x3,
    REQUESTED: 0x4,
    REQUESTED_MUTUAL: 0x5,
    BLOCKING: 0x8,
    MUTING: 0x10,
    MUTING_FOLLOWER: 0x11,
    MUTING_FOLLOWING: 0x12,
    MUTING_MUTUAL: 0x13,
    MUTING_REQUESTED: 0x14,
    MUTING_REQUESTED_MUTUAL: 0x15,
    UNKNOWN: 0x40,
    SELF: 0x80
  });

  Request = void 0;

  (function() {
    var assign, finish, getResponse, remove, setResponse, start, stop;
    setResponse = function(stored, n) {
      if (checkDecree()) {
        return police((function(_this) {
          return function() {
            var callback, i, len, ref;
            stored.response = n;
            ref = stored.callbacks;
            for (i = 0, len = ref.length; i < len; i++) {
              callback = ref[i];
              if (typeof callback === "function") {
                callback.call(_this, _this.response);
              }
            }
          };
        })(this));
      }
    };
    getResponse = function(stored) {
      return stored.response;
    };
    finish = function(request, onComplete) {
      var link, params, result, status;
      switch (request.readyState) {
        case 0:
          break;
        case 1:
          dispatch("LaboratoryRequestOpen", request);
          break;
        case 2:
        case 3:
          dispatch("LaboratoryRequestUpdate", request);
          break;
        case 4:
          status = request.status;
          result = (function() {
            try {
              if (request.responseText) {
                return JSON.parse(request.responseText);
              } else {
                return {};
              }
            } catch (error) {
              return {
                error: "The response could not be parsed."
              };
            }
          })();
          link = request.getResponseHeader("Link");
          params = {
            status: status,
            url: location,
            prev: ((link != null ? link.match(/<\s*([^,]*)\s*>\s*;(?:[^,]*[;\s])?rel="?prev(?:ious)?"?/) : void 0) || [])[1],
            next: ((link != null ? link.match(/<\s*([^,]*)\s*>\s*;(?:[^,]*[;\s])?rel="?next"?/) : void 0) || [])[1]
          };
          switch (false) {
            case !((200 <= status && status <= 205)):
              if ((result != null ? result.error : void 0) != null) {
                decree((function(_this) {
                  return function() {
                    return _this.response = police(function() {
                      return new Failure(result, status);
                    });
                  };
                })(this));
                dispatch("LaboratoryRequestError", request);
              } else {
                if (typeof onComplete === "function") {
                  onComplete(result, params);
                }
                dispatch("LaboratoryRequestComplete", request);
              }
              break;
            default:
              decree((function(_this) {
                return function() {
                  return _this.response = police(function() {
                    return new Failure(result, status);
                  });
                };
              })(this));
              dispatch("LaboratoryRequestError", request);
          }
      }
    };
    assign = function(stored, callback) {
      if (typeof callback !== "function") {
        throw new TypeError("Provided callback was not a function");
      }
      if (indexOf.call(stored.callbacks, callback) < 0) {
        stored.callbacks.push(callback);
      }
      return this;
    };
    remove = function(stored, callback) {
      var index;
      while ((index = stored.callbacks.indexOf(callback)) !== -1) {
        stored.callbacks.splice(index, 1);
      }
      return this;
    };
    start = function(stored) {
      var contents, method, request, token;
      if (!((request = stored.request) instanceof XMLHttpRequest)) {
        return;
      }
      this.stop();
      contents = stored.contents;
      token = stored.token;
      request.open(method = stored.method, stored.location);
      if (method === "POST" && !((typeof FormData !== "undefined" && FormData !== null) && contents instanceof FormData)) {
        request.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
      }
      if (token != null) {
        request.setRequestHeader("Authorization", "Bearer " + token);
      }
      request.addEventListener("readystatechange", stored.callback);
      request.send(method === "POST" ? contents : void 0);
    };
    stop = function(stored) {
      var request;
      if (!((request = stored.request) instanceof XMLHttpRequest)) {
        return;
      }
      request.removeEventListener("readystatechange", stored.callback);
      request.abort();
    };
    Request = function(method, location, data, token, onComplete) {
      var contents, key, stored, subvalue, value;
      if (!(this && this instanceof Request)) {
        throw new TypeError("this is not a Request");
      }
      data = Object(data);
      stored = {
        callback: void 0,
        callbacks: [],
        contents: void 0,
        location: location = String(location),
        method: method = String(method),
        request: void 0,
        response: null,
        token: token != null ? String(token) : void 0
      };
      Object.defineProperties(this, {
        assign: {
          configurable: true,
          enumerable: false,
          writable: false,
          value: assign.bind(this, stored)
        },
        remove: {
          configurable: true,
          enumerable: false,
          writable: false,
          value: remove.bind(this, stored)
        },
        response: {
          configurable: true,
          enumerable: true,
          get: getResponse.bind(this, stored),
          set: setResponse.bind(this, stored)
        },
        start: {
          configurable: true,
          enumerable: false,
          writable: false,
          value: start.bind(this, stored)
        },
        stop: {
          configurable: true,
          enumerable: false,
          writable: false,
          value: stop.bind(this, stored)
        }
      });
      if (!(method === "GET" || method === "POST" || method === "DELETE")) {
        return this;
      }
      stored.callback = finish.bind(this, stored.request = new XMLHttpRequest, onComplete);
      stored.contents = contents = method === "POST" && typeof FormData === "function" && data instanceof FormData ? data : (((function() {
        var results;
        results = [];
        for (key in data) {
          value = data[key];
          if (value != null) {
            if (isArray(value)) {
              results.push(((function() {
                var i, len, results1;
                results1 = [];
                for (i = 0, len = value.length; i < len; i++) {
                  subvalue = value[i];
                  results1.push((encodeURIComponent(key)) + "[]=" + encodeURIComponent(subvalue));
                }
                return results1;
              })()).join("&"));
            } else {
              results.push((encodeURIComponent(key)) + "=" + encodeURIComponent(value));
            }
          }
        }
        return results;
      })()).join("&")).replace(/%20/g, '+');
      if (!(contents === "" || method === "POST")) {
        stored.location += (indexOf.call(location, "?") >= 0 ? "&" : "?") + contents;
      }
      return this;
    };
    Laboratory.Request = function(data) {
      throw new TypeError("Illegal constructor");
    };
    Object.defineProperty(Request, "prototype", {
      configurable: false,
      enumerable: false,
      writable: false,
      value: Object.freeze(Object.create(Object.prototype, {
        assign: {
          enumerable: false,
          value: function() {}
        },
        constructor: {
          enumerable: false,
          value: Laboratory.Request
        },
        go: {
          enumerable: false,
          value: function() {
            return new Promise((function(_this) {
              return function(resolve, reject) {
                var callback;
                callback = function(response) {
                  (response instanceof Failure ? reject : resolve).call(_this, response);
                  return _this.remove(callback);
                };
                _this.assign(callback);
                return _this.start;
              };
            })(this));
          }
        },
        remove: {
          enumerable: false,
          value: function() {}
        },
        start: {
          enumerable: false,
          value: function() {}
        },
        stop: {
          enumerable: false,
          value: function() {}
        }
      }))
    });
    return Object.defineProperty(Laboratory.Request, "prototype", {
      configurable: false,
      enumerable: false,
      writable: false,
      value: Request.prototype
    });
  })();

  Laboratory.Rolodex = Rolodex = function(data) {
    var current, currentID, getProfile, i, index, j, len, prev, ref, value;
    if (!(this && this instanceof Rolodex)) {
      throw new TypeError("this is not a Rolodex");
    }
    if (data == null) {
      throw new TypeError("Unable to create Rolodex; no data provided");
    }
    getProfile = function(id) {
      return Store.profiles[id];
    };
    data.sort(function(first, second) {
      return second.id - first.id;
    });
    prev = null;
    if (data.length > 0) {
      for (index = i = ref = data.length - 1; ref <= 0 ? i <= 0 : i >= 0; index = ref <= 0 ? ++i : --i) {
        currentID = (current = data[index]).id;
        if ((prev != null) && currentID === prev.id) {
          data.splice(index, 1);
          continue;
        }
        prev = current;
      }
    }
    this.profiles = [];
    for (index = j = 0, len = data.length; j < len; index = ++j) {
      value = data[index];
      Object.defineProperty(this.profiles, index, {
        enumerable: true,
        get: getProfile.bind(this, value.id)
      });
    }
    Object.freeze(this.profiles);
    this.length = data.length;
    return Object.freeze(this);
  };

  Object.defineProperty(Rolodex, "prototype", {
    value: Object.freeze({
      join: function(data) {
        var combined, i, j, len, len1, profile, ref, ref1;
        if (!(data instanceof Profile || data instanceof Array || data instanceof Rolodex)) {
          return this;
        }
        ref = (function() {
          switch (false) {
            case !(data instanceof Profile):
              return [data];
            case !(data instanceof Rolodex):
              return data.profiles;
            default:
              return data;
          }
        })();
        for (i = 0, len = ref.length; i < len; i++) {
          profile = ref[i];
          combined = profile;
        }
        ref1 = this.profiles;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          profile = ref1[j];
          combined.push(profile);
        }
        return new Rolodex(combined);
      },
      remove: function(data) {
        var i, index, len, profile, redacted, ref;
        if (!(data instanceof Profile || data instanceof Array || data instanceof Rolodex)) {
          return this;
        }
        redacted = (function() {
          var i, len, ref, results;
          ref = this.profiles;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            profile = ref[i];
            results.push(profile);
          }
          return results;
        }).call(this);
        ref = ((function() {
          switch (false) {
            case !(data instanceof Profile):
              return [data];
            case !(data instanceof Rolodex):
              return data.profiles;
            default:
              return data;
          }
        })());
        for (i = 0, len = ref.length; i < len; i++) {
          profile = ref[i];
          if ((index = redacted.indexOf(profile)) !== -1) {
            redacted.splice(index, 1);
          }
        }
        return new Rolodex(redacted);
      }
    })
  });

  Rolodex.Type = Enumeral.generate({
    UNDEFINED: 0x00,
    SEARCH: 0x10,
    FOLLOWERS: 0x21,
    FOLLOWING: 0x22,
    FAVOURITED_BY: 0x41,
    REBLOGGED_BY: 0x45,
    BLOCKS: 0x83,
    MUTES: 0x84,
    FOLLOW_REQUESTS: 0x86
  });

  Laboratory.Timeline = Timeline = function(data) {
    var current, currentID, getPost, i, index, isNotification, j, len, prev, ref, value;
    if (!(this && this instanceof Timeline)) {
      throw new TypeError("this is not a Timeline");
    }
    if (data == null) {
      throw new TypeError("Unable to create Timeline; no data provided");
    }
    isNotification = function(object) {
      return !!(((function() {
        switch (false) {
          case !(object instanceof Post):
            return object.type;
          case object.type == null:
            return Post.Type.NOTIFICATION;
          default:
            return Post.Type.STATUS;
        }
      })()) & Post.Type.NOTIFICATION);
    };
    getPost = function(id, isANotification) {
      if (isANotification) {
        return Store.notifications[id];
      } else {
        return Store.statuses[id];
      }
    };
    data.sort(function(first, second) {
      var a, b;
      if (!(isNotification(first)) && !(isNotification(second)) && (a = Number(first instanceof Post && first.datetime || Date(first.created_at))) !== (b = Number(second instanceof Post && second.datetime || Date(second.created_at)))) {
        return -1 + 2 * (a > b);
      } else {
        return second.id - first.id;
      }
    });
    prev = null;
    if (data.length > 0) {
      for (index = i = ref = data.length - 1; ref <= 0 ? i <= 0 : i >= 0; index = ref <= 0 ? ++i : --i) {
        currentID = (current = data[index]).id;
        if ((prev != null) && currentID === prev.id && (isNotification(prev)) === (isNotification(current))) {
          data.splice(index, 1);
          continue;
        }
        prev = current;
      }
    }
    this.posts = [];
    for (index = j = 0, len = data.length; j < len; index = ++j) {
      value = data[index];
      Object.defineProperty(this.posts, index, {
        enumerable: true,
        get: getPost.bind(this, value.id, isNotification(value))
      });
    }
    Object.freeze(this.posts);
    this.length = data.length;
    return Object.freeze(this);
  };

  Object.defineProperty(Timeline, "prototype", {
    value: Object.freeze({
      join: function(data) {
        var combined, i, j, len, len1, post, ref, ref1;
        if (!(data instanceof Post || data instanceof Array || data instanceof Timeline)) {
          return this;
        }
        ref = (function() {
          switch (false) {
            case !(data instanceof Post):
              return [data];
            case !(data instanceof Timeline):
              return data.posts;
            default:
              return data;
          }
        })();
        for (i = 0, len = ref.length; i < len; i++) {
          post = ref[i];
          combined = post;
        }
        ref1 = this.posts;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          post = ref1[j];
          combined.push(post);
        }
        return new Timeline(combined);
      },
      remove: function(data) {
        var i, index, len, post, redacted, ref;
        if (!(data instanceof Post || data instanceof Array || data instanceof Timeline)) {
          return this;
        }
        redacted = (function() {
          var i, len, ref, results;
          ref = this.posts;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            post = ref[i];
            results.push(post);
          }
          return results;
        }).call(this);
        ref = ((function() {
          switch (false) {
            case !(data instanceof Post):
              return [data];
            case !(data instanceof Timeline):
              return data.posts;
            default:
              return data;
          }
        })());
        for (i = 0, len = ref.length; i < len; i++) {
          post = ref[i];
          if ((index = redacted.indexOf(post)) !== -1) {
            redacted.splice(index, 1);
          }
        }
        return new Timeline(redacted);
      }
    })
  });

  Timeline.Type = Enumeral.generate({
    UNDEFINED: 0x00,
    PUBLIC: 0x10,
    HOME: 0x20,
    NOTIFICATIONS: 0x21,
    FAVOURITES: 0x22,
    ACCOUNT: 0x40,
    HASHTAG: 0x80
  });

  LaboratoryEvent = {
    Events: {},
    Handlers: [],
    create: function(type, detail) {
      if (LaboratoryEvent.Events[type] == null) {
        LaboratoryEvent.Events[type] = Object(detail);
      }
      return LaboratoryEvent;
    },
    handle: function(type, callback) {
      if (LaboratoryEvent.Events[type = String(type)] == null) {
        return LaboratoryEvent;
      }
      callback.type = type;
      LaboratoryEvent.Handlers.push(callback);
      return LaboratoryEvent;
    }
  };

  Laboratory.dispatch = dispatch = function(event, props) {
    var detail, initial, initials;
    if ((initials = LaboratoryEvent.Events[event = String(event)]) == null) {
      return false;
    }
    if (typeof initials === "function") {
      if (!((detail = props) instanceof initials)) {
        return false;
      }
    } else if (props != null) {
      detail = {};
      for (prop in initials) {
        initial = initials[prop];
        detail[prop] = props[prop] != null ? props[prop] : initial;
      }
      Object.freeze(detail);
    }
    document.dispatchEvent(new CustomEvent(event, {
      detail: detail
    }));
    return true;
  };

  Object.defineProperty(Attachment, "Request", {
    configurable: false,
    enumerable: true,
    writable: false,
    value: (function() {
      var AttachmentRequest;
      AttachmentRequest = function(data) {
        var file, form;
        if (!(this && this instanceof AttachmentRequest)) {
          throw new TypeError("this is not an AttachmentRequest");
        }
        if (!(typeof File === "function" && (file = data.file) instanceof File)) {
          throw new TypeError("Unable to create attachment; none provided");
        }
        if (typeof FormData !== "function") {
          throw new TypeError("Unable to create attachment; `FormData` not supported");
        }
        form = new FormData;
        form.append("file", file);
        Request.call(this, "POST", Store.auth.origin + "/api/v1/media", form, Store.auth.accessToken, (function(_this) {
          return function(result) {
            return dispatch("LaboratoryAttachmentReceived", decree(function() {
              return _this.response = police(function() {
                return new Attachment(result);
              });
            }));
          };
        })(this));
        return Object.freeze(this);
      };
      Object.defineProperty(AttachmentRequest, "prototype", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Object.freeze(Object.create(Request.prototype, {
          constructor: {
            enumerable: false,
            value: AttachmentRequest
          }
        }))
      });
      return AttachmentRequest;
    })()
  });

  Object.defineProperty(Authorization, "Request", {
    configurable: false,
    enumerable: true,
    writable: false,
    value: (function() {
      var AuthorizationRequest, finishRequest, getToken, makeRequest, startRequest, stopRequest;
      stopRequest = function() {
        var ref;
        if (!((this != null ? this.currentRequest : void 0) instanceof Authorization.Request)) {
          throw new TypeError("No defined AuthorizationRequest");
        }
        if (typeof this.wrapup === "function") {
          this.wrapup();
        }
        if (typeof ((ref = this.waitingRequest) != null ? ref.stop : void 0) === "function") {
          this.waitingRequest.stop();
        }
        if (this.window instanceof Window) {
          this.window.close();
        }
        this.waitingRequest = this.callback = this.window = void 0;
      };
      startRequest = function(window) {
        var accessToken, handleClient, ref, scopeList, storedAccessToken, storedRedirect, storedScope, timeout;
        if (!((this != null ? this.currentRequest : void 0) instanceof Authorization.Request)) {
          throw new TypeError("No defined AuthorizationRequest");
        }
        this.currentRequest.stop();
        if ((window != null) && !window.closed) {
          this.window = window;
        }
        ref = (typeof localStorage !== "undefined" && localStorage !== null ? localStorage.getItem("Laboratory | " + this.origin) : void 0) ? (localStorage.getItem("Laboratory | " + this.origin)).split(" ", 5) : [], storedRedirect = ref[0], this.clientID = ref[1], this.clientSecret = ref[2], storedScope = ref[3], storedAccessToken = ref[4];
        if ((accessToken = this.accessToken) || (accessToken = storedAccessToken) && (this.scope & storedScope) === +this.scope) {
          finishRequest.call(this, {
            access_token: accessToken,
            created_at: 0/0,
            scope: (scopeList = [], this.scope & Authorization.Scope.READ ? scopeList.push("read") : void 0, this.scope & Authorization.Scope.WRITE ? scopeList.push("write") : void 0, this.scope & Authorization.Scope.FOLLOW ? scopeList.push("follow") : void 0, scopeList.join(" ")),
            token_type: "bearer"
          });
          return;
        }
        if (storedRedirect === this.redirect && (this.scope & storedScope) === +this.scope && this.clientID && this.clientSecret) {
          makeRequest.call(this);
        } else {
          handleClient = (function(_this) {
            return function(client) {
              var ref1;
              if (!(client instanceof Client && _this.currentRequest && client.origin === _this.origin && (_this.scope & client.scope) === +_this.scope && client.redirect === _this.redirect && client.clientID && client.clientSecret)) {
                return;
              }
              ref1 = [client.clientID, client.clientSecret], _this.clientID = ref1[0], _this.clientSecret = ref1[1];
              localStorage.setItem("Laboratory | " + _this.origin, [client.redirect, client.clientID, client.clientSecret, +client.scope].join(" "));
              clearTimeout(timeout);
              _this.wrapup = void 0;
              _this.waitingRequest.stop();
              _this.waitingRequest.remove(handleClient);
              return makeRequest.call(_this);
            };
          })(this);
          this.waitingRequest = new Client.Request({
            name: this.name,
            origin: this.origin,
            redirect: this.redirect,
            scope: this.scope
          });
          this.waitingRequest.assign(handleClient);
          this.wrapup = (function(_this) {
            return function() {
              return _this.waitingRequest.remove(handleClient);
            };
          })(this);
          this.waitingRequest.start();
          timeout = setTimeout(((function(_this) {
            return function() {
              _this.currentRequest.stop();
              _this.waitingRequest.stop();
              return decree(function() {
                return _this.response = police(function() {
                  return new Failure("Unable to authorize client");
                });
              });
            };
          })(this)), 30000);
        }
      };
      makeRequest = function() {
        var callback, key, location, scopeList, value;
        if (!((this != null ? this.currentRequest : void 0) instanceof Authorization.Request)) {
          throw new TypeError("No defined AuthorizationRequest");
        }
        location = this.origin + "/oauth/authorize?" + (((function() {
          var ref, results;
          ref = {
            client_id: this.clientID,
            response_type: "code",
            redirect_uri: this.redirect,
            scope: (scopeList = [], this.scope & Authorization.Scope.READ ? scopeList.push("read") : void 0, this.scope & Authorization.Scope.WRITE ? scopeList.push("write") : void 0, this.scope & Authorization.Scope.FOLLOW ? scopeList.push("follow") : void 0, scopeList.join(" "))
          };
          results = [];
          for (key in ref) {
            value = ref[key];
            results.push((encodeURIComponent(key)) + "=" + (encodeURIComponent(value)));
          }
          return results;
        }).call(this)).join("&"));
        if (this.window) {
          this.window.location = location;
        } else {
          this.window = window.open(location, "LaboratoryOAuth");
        }
        callback = (function(_this) {
          return function(event) {
            if (!(event.source === _this.window && event.origin === window.location.origin)) {
              return;
            }
            getToken.call(_this, event.data);
            event.source.close();
            _this.window = null;
            _this.wrapup = void 0;
            window.removeEventListener("message", callback);
            return callback = void 0;
          };
        })(this);
        window.addEventListener("message", callback);
        return this.wrapup = function() {
          return window.removeEventListener("message", callback);
        };
      };
      getToken = function(code) {
        var ref;
        if (!((this != null ? this.currentRequest : void 0) instanceof Authorization.Request)) {
          throw new TypeError("No defined AuthorizationRequest");
        }
        if (typeof ((ref = this.waitingRequest) != null ? ref.stop : void 0) === "function") {
          this.waitingRequest.stop();
        }
        return (this.waitingRequest = new Request("POST", this.origin + "/oauth/token", {
          client_id: this.clientID,
          client_secret: this.clientSecret,
          redirect_uri: this.redirect,
          grant_type: "authorization_code",
          code: code
        }, null, finishRequest.bind(this))).start();
      };
      finishRequest = function(result) {
        var location, ref;
        if (!((this != null ? this.currentRequest : void 0) instanceof Authorization.Request)) {
          throw new TypeError("No defined AuthorizationRequest");
        }
        if (typeof ((ref = this.waitingRequest) != null ? ref.stop : void 0) === "function") {
          this.waitingRequest.stop();
        }
        location = this.origin + "/api/v1/accounts/verify_credentials";
        this.accessToken = String(result.access_token);
        return (this.waitingRequest = new Request("GET", location, null, this.accessToken, (function(_this) {
          return function(mine) {
            var scopes;
            decree(function() {
              return _this.currentRequest.response = police(function() {
                return new Authorization(result, _this.origin, mine.id);
              });
            });
            dispatch("LaboratoryAuthorizationReceived", _this.currentRequest.response);
            localStorage.setItem("Laboratory | " + _this.origin, [_this.redirect, _this.clientID, _this.clientSecret, Authorization.Scope.READ * (indexOf.call((scopes = result.scope.split(/[\s\+]+/g)), "read") >= 0) + Authorization.Scope.WRITE * (indexOf.call(scopes, "write") >= 0) + Authorization.Scope.FOLLOW * (indexOf.call(scopes, "follow") >= 0), _this.accessToken].join(" "));
            dispatch("LaboratoryProfileReceived", new Profile(mine));
            return _this.currentRequest.stop();
          };
        })(this))).start();
      };
      AuthorizationRequest = function(data) {
        var a, recalled;
        if (!(this && this instanceof AuthorizationRequest)) {
          throw new TypeError("this is not an AuthorizationRequest");
        }
        recalled = {
          currentRequest: this,
          waitingRequest: void 0,
          callback: void 0,
          scope: data.scope instanceof Authorization.Scope ? data.scope : Authorization.Scope.READ,
          name: data.name != null ? String(data.name) : "Laboratory",
          accessToken: data.accessToken != null ? String(data.accessToken) : void 0,
          window: void 0,
          clientID: void 0,
          clientSecret: void 0,
          origin: (a = document.createElement("a"), a.href = data.origin || "/", a.origin),
          redirect: (a.href = data.redirect || "", a.href)
        };
        Request.call(this);
        Object.defineProperties(this, {
          start: {
            enumerable: false,
            value: startRequest.bind(recalled)
          },
          stop: {
            enumerable: false,
            value: stopRequest.bind(recalled)
          }
        });
        return Object.freeze(this);
      };
      Object.defineProperty(AuthorizationRequest, "prototype", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Object.freeze(Object.create(Request.prototype, {
          constructor: {
            enumerable: false,
            value: AuthorizationRequest
          }
        }))
      });
      return AuthorizationRequest;
    })()
  }, LaboratoryEvent.create("LaboratoryAuthorizationReceived", Authorization).handle("LaboratoryAuthorizationReceived", function(event) {
    if (event.detail instanceof Authorization) {
      reset();
      return Exposed.auth = Store.auth = event.detail;
    }
  }));

  Object.defineProperty(Client, "Request", {
    configurable: false,
    enumerable: true,
    writable: false,
    value: (function() {
      var ClientRequest;
      ClientRequest = function(data) {
        var a, name, origin, redirect, scope, scopeList;
        if (!(this && this instanceof ClientRequest)) {
          throw new TypeError("this is not a ClientRequest");
        }
        name = (String(data.name)) || "Laboratory";
        scope = data.scope instanceof Authorization.Scope ? data.scope : Authorization.Scope.READ;
        a = document.createElement("a");
        a.href = data.origin || "/";
        origin = a.origin;
        a.href = data.redirect || "";
        redirect = a.href;
        Request.call(this, "POST", origin + "/api/v1/apps", {
          client_name: name,
          redirect_uris: redirect,
          scopes: (scopeList = [], scope & Authorization.Scope.READ ? scopeList.push("read") : void 0, scope & Authorization.Scope.WRITE ? scopeList.push("write") : void 0, scope & Authorization.Scope.FOLLOW ? scopeList.push("follow") : void 0, scopeList.join(" "))
        }, null, (function(_this) {
          return function(result) {
            return dispatch("LaboratoryClientReceived", decree(function() {
              return _this.response = police(function() {
                return new Client(result, origin, name, scope);
              });
            }));
          };
        })(this));
        return Object.freeze(this);
      };
      Object.defineProperty(ClientRequest, "prototype", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Object.freeze(Object.create(Request.prototype, {
          constructor: {
            enumerable: false,
            value: ClientRequest
          }
        }))
      });
      return ClientRequest;
    })()
  });

  LaboratoryEvent.create("LaboratoryClientReceived", Client);

  LaboratoryEvent.create("LaboratoryInitializationLoaded").create("LaboratoryInitializationReady");

  Object.defineProperties(Post, {
    Request: {
      configurable: false,
      enumerable: true,
      writable: false,
      value: (function() {
        var PostRequest;
        PostRequest = function(data, isLive, useCached) {
          var callback, isNotification, postID, ref, requestStart, requestStop, store, type;
          if (isLive == null) {
            isLive = true;
          }
          if (useCached == null) {
            useCached = true;
          }
          if (!(this && this instanceof PostRequest)) {
            throw new TypeError("this is not a PostRequest");
          }
          if (!((2e308 > (ref = (postID = Math.floor(data != null ? data.id : void 0))) && ref > 0))) {
            throw new TypeError("Unable to request post; no id provided");
          }
          if (!((type = Post.Type.fromValue(data.type)) && type !== Post.Type.UNKNOWN)) {
            type = Post.Type.STATUS;
          }
          isNotification = type & Post.Type.NOTIFICATION;
          store = isNotification ? Store.notifications : Store.statuses;
          callback = (function(_this) {
            return function(event) {
              var response;
              response = event.detail;
              if (response instanceof Post && response.id === postID && (response.type & Post.Type.NOTIFICATION) === isNotification) {
                if (!((response.compare != null) && response.compare(_this.response))) {
                  decree(function() {
                    return _this.response = response;
                  });
                }
                if (!isLive) {
                  return _this.stop();
                }
              }
            };
          })(this);
          Request.call(this, "GET", Store.auth.origin + (isNotification ? "/api/v1/notifications/" : "/api/v1/statuses/") + postID, null, Store.auth.accessToken, (function(_this) {
            return function(result) {
              var post;
              if (result.id !== postID) {
                _this.dispatchEvent(new CustomEvent("failure", {
                  request: _this,
                  response: new Failure("Unable to fetch post; returned post did not match requested id")
                }));
                return;
              }
              post = new Post(result);
              if ((post.type & Post.Type.NOTIFICATION) !== isNotification) {
                _this.dispatchEvent(new CustomEvent("failure", {
                  request: _this,
                  response: new Failure("Unable to fetch post; returned post was not of specified type")
                }));
                return;
              }
              return dispatch("LaboratoryPostReceived", post);
            };
          })(this));
          requestStart = this.start;
          requestStop = this.stop;
          Object.defineProperties(this, {
            start: {
              enumerable: false,
              value: function() {
                if (useCached && store[postID] instanceof Post) {
                  decree((function(_this) {
                    return function() {
                      return _this.response = store[postID];
                    };
                  })(this));
                  if (!isLive) {
                    return;
                  }
                }
                document.addEventListener("LaboratoryPostReceived", callback);
                return requestStart();
              }
            },
            stop: {
              enumerable: false,
              value: function() {
                document.removeEventListener("LaboratoryPostReceived", callback);
                return requestStop();
              }
            }
          });
          return Object.freeze(this);
        };
        Object.defineProperty(PostRequest, "prototype", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: Object.freeze(Object.create(Request.prototype, {
            constructor: {
              enumerable: false,
              value: PostRequest
            }
          }))
        });
        return PostRequest;
      })()
    },
    Create: {
      configurable: false,
      enumerable: true,
      writable: false,
      value: (function() {
        var PostCreate;
        PostCreate = function(data) {
          var attachment, attachments, inReplyTo, makeNSFW, message, ref, text, visibility;
          if (!(this && this instanceof PostCreate)) {
            throw new TypeError("this is not a PostCreate");
          }
          if (!(data != null ? data.text : void 0)) {
            throw new TypeError("Unable to create post; no text provided");
          }
          text = String(data.text);
          if (!(visibility = Post.Visibility.fromValue(data.visibility))) {
            visibility = Post.Visibility.PRIVATE;
          }
          if (!((2e308 > (ref = (inReplyTo = Math.floor(data.inReplyTo))) && ref > 0))) {
            inReplyTo = void 0;
          }
          attachments = (data.attachments instanceof Array ? data.attachments : void 0);
          message = data.message != null ? String(data.message) : void 0;
          makeNSFW = data.makeNSFW != null ? !!data.makeNSFW : void 0;
          Request.call(this, "POST", Store.auth.origin + "/api/v1/statuses/", {
            status: text,
            in_reply_to_id: inReplyTo,
            media_ids: attachments ? (function() {
              var i, len, results;
              results = [];
              for (i = 0, len = attachments.length; i < len; i++) {
                attachment = attachments[i];
                if (attachment instanceof Attachment) {
                  results.push(attachment.id);
                }
              }
              return results;
            })() : void 0,
            sensitive: makeNSFW ? "true" : void 0,
            spoiler_text: message,
            visibility: (function() {
              switch (visibility) {
                case Post.Visibility.PUBLIC:
                  return "public";
                case Post.Visibility.UNLISTED:
                  return "unlisted";
                case Post.Visibility.DIRECT:
                  return "direct";
                default:
                  return "private";
              }
            })()
          }, Store.auth.accessToken, (function(_this) {
            return function(result) {
              return dispatch("LaboratoryPostReceived", decree(function() {
                return _this.response = police(function() {
                  return new Post(result);
                });
              }));
            };
          })(this));
          return Object.freeze(this);
        };
        Object.defineProperty(PostCreate, "prototype", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: Object.freeze(Object.create(Request.prototype, {
            constructor: {
              enumerable: false,
              value: PostCreate
            }
          }))
        });
        return PostCreate;
      })()
    },
    Delete: {
      configurable: false,
      enumerable: true,
      writable: false,
      value: (function() {
        var PostDelete;
        PostDelete = function(data) {
          var postID, ref;
          if (!(this && this instanceof PostDelete)) {
            throw new TypeError("this is not a PostDelete");
          }
          if (!((2e308 > (ref = (postID = Math.floor(data != null ? data.id : void 0))) && ref > 0))) {
            throw new TypeError("Unable to create post; no id provided");
          }
          Request.call(this, "DELETE", Store.auth.origin + "/api/v1/statuses/" + postID, null, Store.auth.accessToken, (function(_this) {
            return function(result) {
              return dispatch("LaboratoryPostDeleted", {
                id: postID
              });
            };
          })(this));
          return Object.freeze(this);
        };
        Object.defineProperty(PostDelete, "prototype", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: Object.freeze(Object.create(Request.prototype, {
            constructor: {
              enumerable: false,
              value: PostDelete
            }
          }))
        });
        return PostDelete;
      })()
    },
    SetReblog: {
      configurable: false,
      enumerable: true,
      writable: false,
      value: (function() {
        var PostSetReblog;
        PostSetReblog = function(data) {
          var postID, ref, value;
          if (!(this && this instanceof PostSetReblog)) {
            throw new TypeError("this is not a PostSetReblog");
          }
          if (!((2e308 > (ref = (postID = Math.floor(data != null ? data.id : void 0))) && ref > 0))) {
            throw new TypeError("Unable to reblog post; no id provided");
          }
          value = data.value ? !!data.value : true;
          Request.call(this, "POST", Store.auth.origin + "/api/v1/statuses/" + postID + (value ? "/reblog" : "/unreblog"), null, Store.auth.accessToken, (function(_this) {
            return function(result) {
              return dispatch("LaboratoryPostReceived", decree(function() {
                return _this.response = police(function() {
                  return new Post(result);
                });
              }));
            };
          })(this));
          return Object.freeze(this);
        };
        Object.defineProperty(PostSetReblog, "prototype", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: Object.freeze(Object.create(Request.prototype, {
            constructor: {
              enumerable: false,
              value: PostSetReblog
            }
          }))
        });
        return PostSetReblog;
      })()
    },
    SetFavourite: {
      configurable: false,
      enumerable: true,
      writable: false,
      value: (function() {
        var PostSetFavourite;
        PostSetFavourite = function(data) {
          var postID, ref, value;
          if (!(this && this instanceof PostSetFavourite)) {
            throw new TypeError("this is not a PostSetFavourite");
          }
          if (!((2e308 > (ref = (postID = Math.floor(data != null ? data.id : void 0))) && ref > 0))) {
            throw new TypeError("Unable to favourite post; no id provided");
          }
          value = data.value ? !!data.value : true;
          Request.call(this, "POST", Store.auth.origin + "/api/v1/statuses/" + postID + (value ? "/favourite" : "/unfavourite"), null, Store.auth.accessToken, (function(_this) {
            return function(result) {
              return dispatch("LaboratoryPostReceived", decree(function() {
                return _this.response = police(function() {
                  return new Post(result);
                });
              }));
            };
          })(this));
          return Object.freeze(this);
        };
        Object.defineProperty(PostSetFavourite, "prototype", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: Object.freeze(Object.create(Request.prototype, {
            constructor: {
              enumerable: false,
              value: PostSetFavourite
            }
          }))
        });
        return PostSetFavourite;
      })()
    }
  });

  LaboratoryEvent.create("LaboratoryPostReceived", Post).create("LaboratoryPostDeleted", {
    id: void 0
  }).handle("LaboratoryPostReceived", function(event) {
    var id, post, ref, type;
    if ((post = event.detail) instanceof Post && (type = post.type) instanceof Post.Type && (2e308 > (ref = (id = Math.floor(post.id))) && ref > 0)) {
      return Store[["notifications", "statuses"][+(!(type & Post.Type.NOTIFICATION))]][id] = post;
    }
  }).handle("LaboratoryPostDeleted", function(event) {
    var id, ref;
    if ((2e308 > (ref = (id = Math.floor(event.detail.id))) && ref > 0)) {
      return delete Store.statuses[id];
    }
  });

  Object.defineProperties(Profile, {
    Request: {
      configurable: false,
      enumerable: true,
      writable: false,
      value: (function() {
        var ProfileRequest;
        ProfileRequest = function(data, isLive, useCached) {
          var callback, profileID, ref, relationshipRequest, requestStart, requestStop;
          if (isLive == null) {
            isLive = true;
          }
          if (useCached == null) {
            useCached = true;
          }
          if (!(this && this instanceof ProfileRequest)) {
            throw new TypeError("this is not a ProfileRequest");
          }
          if (!((2e308 > (ref = (profileID = Math.floor(data != null ? data.id : void 0))) && ref > 0))) {
            throw new TypeError("Unable to request profile; no id provided");
          }
          callback = (function(_this) {
            return function(event) {
              var response;
              response = event.detail;
              if (response instanceof Profile && response.id === profileID) {
                if (!((response.compare != null) && response.compare(_this.response))) {
                  decree(function() {
                    return _this.response = response;
                  });
                }
                if (!isLive) {
                  return _this.stop();
                }
              }
            };
          })(this);
          Request.call(this, "GET", Store.auth.origin + "/api/v1/accounts/" + profileID, null, Store.auth.accessToken, (function(_this) {
            return function(result) {
              if (result.id !== profileID) {
                _this.dispatchEvent(new CustomEvent("failure", {
                  id: _this.id,
                  request: _this,
                  response: new Failure("Unable to fetch profile; returned profile did not match requested id")
                }));
                return;
              }
              dispatch("LaboratoryProfileReceived", new Profile(result));
              return relationshipRequest.start();
            };
          })(this));
          relationshipRequest = new Request("GET", Store.auth.origin + "/api/v1/accounts/relationships", {
            id: profileID
          }, Store.auth.accessToken, (function(_this) {
            return function(result) {
              var ref1, relID, relationship, relationships;
              relationships = result[0];
              relID = relationships.id;
              relationship = Profile.Relationship.fromValue((Profile.Relationship.FOLLOWER * relationships.followed_by + Profile.Relationship.FOLLOWING * relationships.following + Profile.Relationship.REQUESTED * relationships.requested + Profile.Relationship.BLOCKING * relationships.blocking + Profile.Relationship.MUTING * relationships.muting + Profile.Relationship.SELF * (relID === Store.auth.me)) || Profile.Relationship.UNKNOWN);
              if (((ref1 = Store.profiles[relID]) != null ? ref1.relationship : void 0) !== relationship) {
                return dispatch("LaboratoryProfileReceived", new Profile(Store.profiles[relID] || {
                  id: relID
                }, relationship));
              }
            };
          })(this));
          requestStart = this.start;
          requestStop = this.stop;
          Object.defineProperties(this, {
            start: {
              enumerable: false,
              value: function() {
                if (useCached && Store.profiles[profileID] instanceof Profile) {
                  decree((function(_this) {
                    return function() {
                      return _this.response = Store.profiles[profileID];
                    };
                  })(this));
                  if (!isLive) {
                    return;
                  }
                }
                document.addEventListener("LaboratoryProfileReceived", callback);
                return requestStart();
              }
            },
            stop: {
              enumerable: false,
              value: function() {
                document.removeEventListener("LaboratoryProfileReceived", callback);
                requestStop();
                return relationshipRequest.stop();
              }
            }
          });
          return Object.freeze(this);
        };
        Object.defineProperty(ProfileRequest, "prototype", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: Object.freeze(Object.create(Request.prototype, {
            constructor: {
              enumerable: false,
              value: ProfileRequest
            }
          }))
        });
        return ProfileRequest;
      })()
    },
    SetFollow: {
      configurable: false,
      enumerable: true,
      writable: false,
      value: (function() {
        var ProfileSetFollow;
        ProfileSetFollow = function(data) {
          var profileID, ref, value;
          if (!(this && this instanceof ProfileSetFollow)) {
            throw new TypeError("this is not a ProfileSetFollow");
          }
          if (!((2e308 > (ref = (profileID = Math.floor(data != null ? data.id : void 0))) && ref > 0))) {
            throw new TypeError("Unable to follow account; no id provided");
          }
          value = data.value ? !!data.value : true;
          Request.call(this, "POST", Store.auth.origin + "/api/v1/accounts/" + profileID + (value ? "/follow" : "/unfollow"), null, Store.auth.accessToken, (function(_this) {
            return function(result) {
              return dispatch("LaboratoryProfileReceived", decree(function() {
                return _this.response = police(function() {
                  return new Profile(result);
                });
              }));
            };
          })(this));
          return Object.freeze(this);
        };
        Object.defineProperty(ProfileSetFollow, "prototype", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: Object.freeze(Object.create(Request.prototype, {
            constructor: {
              enumerable: false,
              value: ProfileSetFollow
            }
          }))
        });
        return ProfileSetFollow;
      })()
    },
    SetBlock: {
      configurable: false,
      enumerable: true,
      writable: false,
      value: (function() {
        var ProfileSetBlock;
        ProfileSetBlock = function(data) {
          var profileID, ref, value;
          if (!(this && this instanceof ProfileSetBlock)) {
            throw new TypeError("this is not a ProfileSetBlock");
          }
          if (!((2e308 > (ref = (profileID = Math.floor(data != null ? data.id : void 0))) && ref > 0))) {
            throw new TypeError("Unable to block account; no id provided");
          }
          value = data.value ? !!data.value : true;
          Request.call(this, "POST", Store.auth.origin + "/api/v1/accounts/" + profileID + (value ? "/block" : "/unblock"), null, Store.auth.accessToken, (function(_this) {
            return function(result) {
              return dispatch("LaboratoryProfileReceived", decree(function() {
                return _this.response = police(function() {
                  return new Profile(result);
                });
              }));
            };
          })(this));
          return Object.freeze(this);
        };
        Object.defineProperty(ProfileSetBlock, "prototype", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: Object.freeze(Object.create(Request.prototype, {
            constructor: {
              enumerable: false,
              value: ProfileSetBlock
            }
          }))
        });
        return ProfileSetBlock;
      })()
    },
    SetMute: {
      configurable: false,
      enumerable: true,
      writable: false,
      value: (function() {
        var ProfileSetMute;
        ProfileSetMute = function(data) {
          var profileID, ref, value;
          if (!(this && this instanceof ProfileSetMute)) {
            throw new TypeError("this is not a ProfileSetMute");
          }
          if (!((2e308 > (ref = (profileID = Math.floor(data != null ? data.id : void 0))) && ref > 0))) {
            throw new TypeError("Unable to mute account; no id provided");
          }
          value = data.value ? !!data.value : true;
          Request.call(this, "POST", Store.auth.origin + "/api/v1/accounts/" + profileID + (value ? "/mute" : "/unmute"), null, Store.auth.accessToken, (function(_this) {
            return function(result) {
              return dispatch("LaboratoryProfileReceived", decree(function() {
                return _this.response = police(function() {
                  return new Profile(result);
                });
              }));
            };
          })(this));
          return Object.freeze(this);
        };
        Object.defineProperty(ProfileSetMute, "prototype", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: Object.freeze(Object.create(Request.prototype, {
            constructor: {
              enumerable: false,
              value: ProfileSetMute
            }
          }))
        });
        return ProfileSetMute;
      })()
    },
    LetFollow: {
      configurable: false,
      enumerable: true,
      writable: false,
      value: (function() {
        var ProfileLetFollow;
        ProfileLetFollow = function(data) {
          var profileID, ref, value;
          if (!(this && this instanceof ProfileLetFollow)) {
            throw new TypeError("this is not a ProfileLetFollow");
          }
          if (!((2e308 > (ref = (profileID = Math.floor(data != null ? data.id : void 0))) && ref > 0))) {
            throw new TypeError("Unable to follow account; no id provided");
          }
          value = data.value ? !!data.value : true;
          Request.call(this, "POST", Store.auth.origin + "/api/v1/follow_requests" + (value ? "/authorize" : "/reject"), {
            id: profileID
          }, Store.auth.accessToken, (function(_this) {
            return function(result) {};
          })(this));
          return Object.freeze(this);
        };
        Object.defineProperty(ProfileLetFollow, "prototype", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: Object.freeze(Object.create(Request.prototype, {
            constructor: {
              enumerable: false,
              value: ProfileLetFollow
            }
          }))
        });
        return ProfileLetFollow;
      })()
    }
  });

  LaboratoryEvent.create("LaboratoryProfileReceived", Profile).handle("LaboratoryProfileReceived", function(event) {
    var id, profile, ref;
    if ((profile = event.detail) instanceof Profile && (2e308 > (ref = (id = Math.floor(profile.id))) && ref > 0)) {
      return Store.profiles[id] = profile;
    }
  });

  LaboratoryEvent.create("LaboratoryRequestOpen", XMLHttpRequest).create("LaboratoryRequestUpdate", XMLHttpRequest).create("LaboratoryRequestComplete", XMLHttpRequest).create("LaboratoryRequestError", XMLHttpRequest);

  Object.defineProperty(Rolodex, "Request", {
    configurable: false,
    enumerable: true,
    writable: false,
    value: (function() {
      var RolodexRequest;
      RolodexRequest = function(data, before, after) {
        var limit, query, ref, type;
        if (!(this && this instanceof RolodexRequest)) {
          throw new TypeError("this is not a RolodexRequest");
        }
        if (!((type = Rolodex.Type.fromValue(data.type)) && type !== Rolodex.Type.UNDEFINED)) {
          throw new TypeError("Unable to request rolodex; no type provided");
        }
        query = data.query != null ? String(data.query) : void 0;
        limit = (2e308 > (ref = data.limit) && ref > 0) ? Math.floor(data.limit) : void 0;
        if (!((2e308 > before && before > 0))) {
          before = void 0;
        }
        if (!((2e308 > after && after > 0))) {
          after = void 0;
        }
        Request.call(this, "GET", Store.auth.origin + ((function() {
          switch (type) {
            case Rolodex.Type.SEARCH:
              return "/api/v1/accounts/search";
            case Rolodex.Type.FOLLOWERS:
              return "/api/v1/accounts/" + query + "/followers";
            case Rolodex.Type.FOLLOWING:
              return "/api/v1/accounts/" + query + "/following";
            case Rolodex.Type.FAVOURITED_BY:
              return "/api/v1/statuses/" + query + "/favourited_by";
            case Rolodex.Type.REBLOGGED_BY:
              return "/api/v1/statuses/" + query + "/reblogged_by";
            case Rolodex.Type.BLOCKS:
              return "/api/v1/blocks";
            case Rolodex.Type.MUTES:
              return "/api/v1/mutes";
            case Rolodex.Type.FOLLOW_REQUESTS:
              return "/api/v1/follow_requests";
          }
        })()), ((function() {
          switch (type) {
            case Rolodex.Type.SEARCH:
              return {
                q: query,
                limit: limit
              };
            default:
              return {
                max_id: before,
                since_id: after
              };
          }
        })()), Store.auth.accessToken, (function(_this) {
          return function(result, params) {
            var account, i, ids, len, ref1, ref2, ref3;
            ids = [];
            before = (((ref1 = params.prev) != null ? ref1.match(/.*since_id=([0-9]+)/) : void 0) || [])[1];
            after = (((ref2 = params.next) != null ? ref2.match(/.*max_id=([0-9]+)/) : void 0) || [])[1];
            for (i = 0, len = result.length; i < len; i++) {
              account = result[i];
              if (!(ref3 = account.id, indexOf.call(ids, ref3) < 0)) {
                continue;
              }
              ids.push(account.id);
              dispatch("LaboratoryProfileReceived", new Profile(account));
            }
            return decree(function() {
              return _this.response = police(function() {
                return new Rolodex(result);
              });
            });
          };
        })(this));
        Object.defineProperties(this, {
          before: {
            enumerable: true,
            get: function() {
              return before;
            }
          },
          after: {
            enumerable: true,
            get: function() {
              return after;
            }
          },
          prev: {
            enumerable: false,
            value: function() {
              return new RolodexRequest({
                type: type,
                query: query,
                limit: limit
              }, void 0, before);
            }
          },
          next: {
            enumerable: false,
            value: function() {
              return new RolodexRequest({
                type: type,
                query: query,
                limit: limit
              }, after);
            }
          },
          loadMore: {
            enumerable: false,
            value: (function(_this) {
              return function() {
                var callback, next;
                callback = function(response) {
                  after = next.after;
                  decree(function() {
                    return _this.response = police(function() {
                      return this.response.join(response);
                    });
                  });
                  next.stop();
                  return next.remove(callback);
                };
                (next = _this.next()).assign(callback);
                return next.start();
              };
            })(this)
          },
          update: {
            enumerable: false,
            value: (function(_this) {
              return function(keepGoing) {
                var callback, prev;
                callback = function(response) {
                  var prev;
                  before = prev.before;
                  decree(function() {
                    return _this.response = police(function() {
                      return this.response.join(response);
                    });
                  });
                  prev.stop();
                  prev.remove(callback);
                  if (keepGoing && response.length) {
                    (prev = _this.prev()).assign(callback);
                    return prev.start();
                  }
                };
                (prev = _this.prev()).assign(callback);
                return prev.start();
              };
            })(this)
          }
        });
        return Object.freeze(this);
      };
      Object.defineProperty(RolodexRequest, "prototype", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Object.freeze(Object.create(Request.prototype, {
          constructor: {
            enumerable: false,
            value: RolodexRequest
          },
          prev: {
            enumerable: false,
            value: function() {}
          },
          next: {
            enumerable: false,
            value: function() {}
          },
          loadMore: {
            enumerable: false,
            value: function() {}
          },
          update: {
            enumerable: false,
            value: function() {}
          }
        }))
      });
      return RolodexRequest;
    })()
  });

  Object.defineProperty(Timeline, "Request", {
    configurable: false,
    enumerable: true,
    writable: false,
    value: (function() {
      var TimelineRequest;
      TimelineRequest = function(data, before, after) {
        var isLocal, limit, query, ref, type;
        if (!(this && this instanceof TimelineRequest)) {
          throw new TypeError("this is not a TimelineRequest");
        }
        if (!((type = Timeline.Type.fromValue(data.type)) && type !== Timeline.Type.UNDEFINED)) {
          throw new TypeError("Unable to request rolodex; no type provided");
        }
        query = data.query != null ? String(data.query) : void 0;
        isLocal = !!data.isLocal;
        limit = (2e308 > (ref = data.limit) && ref > 0) ? Math.floor(data.limit) : void 0;
        if (!((2e308 > before && before > 0))) {
          before = void 0;
        }
        if (!((2e308 > after && after > 0))) {
          after = void 0;
        }
        Request.call(this, "GET", Store.auth.origin + ((function() {
          switch (type) {
            case Timeline.Type.HASHTAG:
              return "/api/v1/timelines/tag/" + query;
            case Timeline.Type.PUBLIC:
              return "/api/v1/timelines/public";
            case Timeline.Type.HOME:
              return "/api/v1/timelines/home";
            case Timeline.Type.NOTIFICATIONS:
              return "/api/v1/notifications";
            case Timeline.Type.FAVOURITES:
              return "/api/v1/favourites";
            case Timeline.Type.ACCOUNT:
              return "/api/v1/accounts/" + query + "/statuses";
            default:
              return "/api/v1";
          }
        })()), {
          local: isLocal || void 0,
          max_id: before,
          since_id: after
        }, Store.auth.accessToken, (function(_this) {
          return function(result, params) {
            var account, acctIDs, i, ids, j, k, l, len, len1, len2, len3, mention, mentionIDs, mentions, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, srcMentions, status;
            acctIDs = [];
            mentions = [];
            mentionIDs = [];
            ids = [];
            before = (((ref1 = params.prev) != null ? ref1.match(/.*since_id=([0-9]+)/) : void 0) || [])[1];
            after = (((ref2 = params.next) != null ? ref2.match(/.*max_id=([0-9]+)/) : void 0) || [])[1];
            for (i = 0, len = result.length; i < len; i++) {
              status = result[i];
              if (!(ref3 = status.id, indexOf.call(ids, ref3) < 0)) {
                continue;
              }
              ids.push(status.id);
              ref6 = [status.account, (ref4 = status.status) != null ? ref4.account : void 0, (ref5 = status.reblog) != null ? ref5.account : void 0];
              for (j = 0, len1 = ref6.length; j < len1; j++) {
                account = ref6[j];
                if (!(account)) {
                  continue;
                }
                acctIDs.push(account.id);
                dispatch("LaboratoryProfileReceived", new Profile(account));
              }
              if ((srcMentions = status.mentions || ((ref7 = status.status) != null ? ref7.mentions : void 0) || ((ref8 = status.reblog) != null ? ref8.mentions : void 0)) instanceof Array) {
                for (k = 0, len2 = srcMentions.length; k < len2; k++) {
                  account = srcMentions[k];
                  if (!(ref9 = account.id, indexOf.call(mentionIDs, ref9) < 0)) {
                    continue;
                  }
                  mentionIDs.push(account.id);
                  mentions.push(account);
                }
              }
              dispatch("LaboratoryPostReceived", new Post(status));
            }
            for (l = 0, len3 = mentions.length; l < len3; l++) {
              mention = mentions[l];
              if ((ref10 = mention.id, indexOf.call(acctIDs, ref10) < 0) && (Store.profiles[mention.id] == null)) {
                dispatch("LaboratoryProfileReceived", new Profile(mention));
              }
            }
            return decree(function() {
              return _this.response = police(function() {
                return new Timeline(result);
              });
            });
          };
        })(this));
        Object.defineProperties(this, {
          before: {
            enumerable: true,
            get: function() {
              return before;
            }
          },
          after: {
            enumerable: true,
            get: function() {
              return after;
            }
          },
          prev: {
            enumerable: false,
            value: function() {
              return new TimelineRequest({
                type: type,
                query: query,
                isLocal: isLocal
              }, void 0, before);
            }
          },
          next: {
            enumerable: false,
            value: function() {
              return new TimelineRequest({
                type: type,
                query: query,
                isLocal: isLocal
              }, after);
            }
          },
          loadMore: {
            enumerable: false,
            value: (function(_this) {
              return function() {
                var callback, next;
                callback = function(response) {
                  after = next.after;
                  decree(function() {
                    return _this.response = police(function() {
                      return this.response.join(response);
                    });
                  });
                  next.stop();
                  return next.remove(callback);
                };
                (next = _this.next()).assign(callback);
                return next.start();
              };
            })(this)
          },
          update: {
            enumerable: false,
            value: (function(_this) {
              return function(keepGoing) {
                var callback, prev;
                callback = function(response) {
                  var prev;
                  before = prev.before;
                  decree(function() {
                    return _this.response = police(function() {
                      return this.response.join(response);
                    });
                  });
                  prev.stop();
                  prev.remove(callback);
                  if (keepGoing && response.length) {
                    (prev = _this.prev()).assign(callback);
                    return prev.start();
                  }
                };
                (prev = _this.prev()).assign(callback);
                return prev.start();
              };
            })(this)
          }
        });
        return Object.freeze(this);
      };
      Object.defineProperty(TimelineRequest, "prototype", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Object.freeze(Object.create(Request.prototype, {
          constructor: {
            enumerable: false,
            value: TimelineRequest
          },
          prev: {
            enumerable: false,
            value: function() {}
          },
          next: {
            enumerable: false,
            value: function() {}
          },
          loadMore: {
            enumerable: false,
            value: function() {}
          },
          update: {
            enumerable: false,
            value: function() {}
          }
        }))
      });
      return TimelineRequest;
    })()
  });

  Store = null;

  (Laboratory.reset = reset = function() {
    Store = {
      auth: null,
      notifications: {},
      profiles: {},
      statuses: {}
    };
  })();

  window["🏪"] = Store;

  Object.defineProperty(window, "Laboratory", {
    value: Object.freeze(Laboratory),
    enumerable: true
  });

  dispatch("LaboratoryInitializationLoaded");

  run = function() {
    var handler, i, len, ref;
    ref = LaboratoryEvent.Handlers;
    for (i = 0, len = ref.length; i < len; i++) {
      handler = ref[i];
      document.addEventListener(handler.type, handler);
    }
    Exposed.ready = true;
    return dispatch("LaboratoryInitializationReady");
  };

  if (document.readyState === "complete") {
    run();
  } else {
    window.addEventListener("load", run);
  }

}).call(this);
